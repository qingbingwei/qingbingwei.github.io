<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on 清兵卫的博客</title>
    <link>https://qingbingwei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on 清兵卫的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 30 Mar 2024 21:29:57 +0800</lastBuildDate><atom:link href="https://qingbingwei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>KMP</title>
      <link>https://qingbingwei.github.io/post/kmp/</link>
      <pubDate>Sat, 30 Mar 2024 21:29:57 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/kmp/</guid>
      <description>字符串算法:KMP算法
字符串:由若干个字符组成的有序序列
字符串：末尾有一个隐含的结束符&amp;rsquo;\0&#39; 字符数组：末尾没有隐含结束符
字符串匹配问题:给出一个主串p 和一个模式串s，问s有没有在p中出现过，出现过几次，每次出现位置在哪里
p:dfghahjsgfhjas&amp;mdash;&amp;gt;m s:hjdj&amp;mdash;&amp;gt;n
1.BF算法(暴力匹配) O(n*m) for(int i = 0;i + LS &amp;lt; LP ;++i) { int j(0); int k(i); while(j &amp;lt; LS) { if(p[k] == s[j]) { ++j; ++k; } else { break; } } if(j == LS) { cout &amp;laquo; i &amp;laquo; endl; } }
2.KMP算法 O(n+m) next[0]=-1 next[1]=0 //以上均为默认 代码思路:模式串自己(错位)匹配自己</description>
    </item>
    
    <item>
      <title>数据结构 B&#43;树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b&#43;%E6%A0%91/</link>
      <pubDate>Sun, 24 Mar 2024 15:02:02 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b&#43;%E6%A0%91/</guid>
      <description>B树的缺点: 1.B树节点既存储了索引(主键),又存储了对应的地址
优化:在内部非终端节点中只存储索引(主键), 在终端节点中既存储索引(主键),又存储对应的地址 2.B树不支持区间查询 优化:让终端节点形成链表,支持区间查询 3.B树查找效率不稳定 优化:B+树查找效率稳定 B+树在B树基础上进行改进。
m阶B+树的性质: 1.有序性 2.其节点中最多有m个关键字和m个孩子&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;父亲节点是孩子节点的索引 3.节点中最少要有ceil(m/2)个关键字和孩子 4.终端节点保存所有的关键字和真实数据，并且终端节点之间要有指针相连 4.非终端节点只保存关键字，终端节点保存真实数据
B+树的操作 1.查找 (1)单点查找 注意要找到终端节点上(相等时判断孩子是否为空，为空则为终端节点) (2)区间查找 [l,r],先对左边界数据进行单点查找，再沿着终端节点之间的指针进行顺序遍历 2.插入 和B树类似，先查找到插入位置&amp;mdash;-&amp;gt;插入&amp;mdash;-&amp;gt;判断是否超过上限,超过则分裂 (1)单点查询插入位置 (2)把数据插入到终端节点上 (3)判断插入节点的关键字个数是否&amp;gt;m,如果大于，分裂上传 特殊情况:如果插入的是节点中的最大值，其父亲的关键字(索引数据)要发生改变
注:为了更加实用，忽略掉特殊情况，一棵m阶B+树，其非终端节点关键字个数最多可以是m-1个 3.删除 和B树类似，先查找删除位置---&amp;gt;删除----&amp;gt;判断是否低于下限，低于则调整 (1)查找删除数据(在终端节点上) (2)删除，如果删除的是节点中的最大值，记得向上修改父亲节点 (3)判断删除节点中的关键字个数是否&amp;lt;ceil(m/2),如果小于: 1.兄弟够借，则借 2.兄弟不够借，则合并 应用场景:数据库 外存管理</description>
    </item>
    
    <item>
      <title>数据结构 红黑树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
      <pubDate>Tue, 05 Mar 2024 19:34:13 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
      <description>AVL树缺点: 1.不适合动态查找，为了保持平衡，不停的进行旋转调整，浪费时间 2.不直观
多路平衡树:多路平衡二叉树 B树 B+树 红黑树
索引存储
1.外存和内存进行数据交互比较慢 2.数据管理方案:通常会使用索引表进行数据查找和交互，由于外存中数据比较多，建立的索引表中的索引数据也会比较多，所以索引表也往往存储在外存中
多路平衡树:2-3-4-&amp;hellip;-n树:树的度(阶):n &amp;mdash;-&amp;gt; n阶B树 (不允许有高度差) 以2-3树为例(3阶B树) 由以下节点组成: (1)二叉节点:含有一个数据和两个孩子的节点，其中左子树的值均小于父亲节点，右子树的值均大于父亲节点 (2)三叉节点:含有两个数据和三个孩子的节点，并且数据之间保持顺序性
红黑树:用二叉树表示的4(或3)阶B树 把4阶B树中的3-，4-节点拆分为2-节点 注:红黑树一定是BST树 性质: 1.节点为红色或者黑色 2.根节点是黑色 3.所有外部叶子节点(NULL节点)是黑色 4.每个红色节点的两个子节点都是黑色(从根节点到每个叶子节点的路径不能有两个连续的红色节点) 5.从根节点到每个叶子节点的所有路径都包含相同数目黑色节点 注：从根节点到到叶子节点的黑色节点个数(黑高) 黑高相同&amp;mdash;&amp;ndash;&amp;gt;黑路同
结论: 1.从根节点到叶子节点的最长路径不大于最短路径的两倍 最短路径(bh):只有黑色节点 最长路径(2*bh):在最短路径基础上，每个黑色节点分下去一个红色节点 2.有n个内部节点的红黑树，其高度h&amp;lt;=2log(n+1) ----&amp;gt;红黑树操作时间复杂度O(logn) 证明:b&amp;lt;=2*bh-----&amp;gt;bh&amp;gt;=h/2 黑高bh 内部节点的数目最少:只有黑色节点的满二叉树 2^bh-1 n &amp;gt;= 2^bh-1 log(n+1)&amp;gt;=bh&amp;gt;=h/2 h&amp;lt;=2log(n+1) 红黑树的优点: BST----&amp;gt;AVL----&amp;gt;平衡因子的约束太严格了，需要频繁调整 -----&amp;gt;红黑树:一棵子树的高度最多可以是另一棵子树的2倍 1.⼤多数⾃平衡BST(self-balancing BST) 库函数都是⽤红⿊树实现的，⽐如C++中的map 和 set （或者 Java 中的 TreeSet 和 TreeMap）。 2.红⿊树也⽤于实现 Linux 操作系统的 CPU 调度。 完全公平调度（Completely Fair Scheduler）使⽤的就是红⿊树。 3.红⿊树也⽤于Linux提供的epoll多路复⽤的底层结构，便于快速增加、删除和查找⽹络连接的节点。 操作: 查找:特殊的BST,同BST RBT的插入:在一棵RBT中插入一个节点z 1.</description>
    </item>
    
    <item>
      <title>数据结构 基础查找</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Fri, 01 Mar 2024 15:28:19 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE/</guid>
      <description>基本概念 静态查找 数据集合稳定，不需要添加，删除元素的查找操作 动态查找 在数据集合进行查找的过程中，需要同时添加或删除元素的查找操作 关键字 数据元素中某个项的值，用它可以唯一标识一个数据元素 内查找和外查找 若整个查找过程都在内存中进⾏，则称之为内查找(internalsearch)； 反之，若查找过程的需要访问外存，则称之为外查找(external search)。 平均查找⻓度(Average Search Length，ASL) 注:ASL是衡量查找算法性能好坏的重要指标。 ⼀个査找算法的ASL越⼤，其时间性能越差； 反之，⼀个查找算法的ASL越⼩，其时间性能越好。 线性查找:顺序查找 二分查找 分块查找&amp;mdash;&amp;mdash;&amp;gt;静态查找 注:以上均基于比较查找 1.顺序查找 从表中的第⼀个（或者最后⼀个）记录开始，逐个进⾏记录的关键字和给定值的⽐较， 若某个记录的关键字和给定值⽐较相等，则查找成功。 如果查找了所有的记录仍然找不到与给定值相等的关键字，则查找不成功。
时间复杂度:O(n) 2.二分查找----前提，数据有序存放，存放在数组中(链表不适合) 确定待查记录所在的范围（区间），然后逐步缩⼩范围直到找到或者找不到该记录为⽌。 注意⼆分查找是在有序表上进⾏的，且⼆分查找也是分治思想的很好例证。 时间复杂度:O(logn) 判定树: 折半查找过程可⽤⼆叉树来描述，把当前查找区间的中间位置上的元素作为根， 由左⼦表和右⼦表构造的⼆叉树分别作为根的左⼦树和右⼦树，由此得到的⼆叉树称为描述折半查找过程的判定树 (deecision tree)或⽐较树(comparison tree)。 注:显然，判定树是⼀棵平衡⼆叉树,反之不成立 3.分块查找 索引存储结构 索引存储结构是在存储数据的同时还建⽴附加的索引表。索引表中的每⼀项称为索引项，索引项的⼀般形式为(关键字，地址)。 其中，关键字唯⼀标识⼀个结点，地址作为指向该关键字对应结点的指针，也可以是相对地址(如数组的下标)。 将査找表分为若⼲⼦块。块内的元素可以⽆序，但块之间是有序的，即第⼀个块中的最⼤关键字 ⼩于第⼆个块中的所有记录的关键字，第⼆个块中的最⼤关键字⼩于第三个块中的所有记录的关键字,以此类推。 再建⽴⼀个索引表，索引表中的每个元素含有各块的最⼤关键字和各块中的第⼀个元素的地址，索引表按关键字有序排列。 分块查找步骤 分块查找的过程分为两步： 第⼀步是在索引表中确定待查记录所在的块，可以顺序查找或折半査找索引表； 第⼆步是在块内顺序查找。
基于散列表的查找:哈希&amp;mdash;&amp;mdash;&amp;gt;动态查找 注:散列存储也叫hash存储 哈希查找&amp;mdash;散列查找&amp;mdash;&amp;ndash;&amp;gt;散列存储
哈希: key &amp;mdash;&amp;ndash;&amp;gt; 哈希函数 &amp;mdash;&amp;mdash;&amp;gt; Add(地址) 冲突:两个不同数据，计算出同一个地址 哈希函数如何设计 1.直接定址法:哈希函数设计为一次函数 h(key)=a*key+b 优点:不产生冲突 缺点:空间浪费大 2.除留余数法:哈希函数设计为对一个质数取余 h(key)=key%p p&amp;lt;=m的质数,m是散列表大小 缺点:冲突几乎必然存在，只能尽可能降低 3.平方取中法 4.数字分析法 5.折叠法</description>
    </item>
    
    <item>
      <title>数据结构 归并和计数排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BD%92%E5%B9%B6%E5%92%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 04 Feb 2024 17:45:25 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BD%92%E5%B9%B6%E5%92%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>1.2-路归并排序：先将所有的数据完全分开，然后两两合并，在合并过程中将其排好序，最终得到一个完整的有序表。 时间复杂度：O(nlogn) 是否稳定：稳定 为非就地排序 2.基于统计的排序 1.计数排序：统计一下每个数出现的次数，然后直接按次数输出 //以空间换时间 时间复杂度：O(n) 是否稳定：稳定 缺点： 1.无法对负整数和浮点数排序 优化：引入偏移量便可以对负整数进行排序 对浮点数全部乘以10^n,便可以对浮点数排序 2.极其浪费空间内存 2.桶排序:桶编号规则人为确定，可以n/10，也可以n/100,将数据放入桶后，对每个桶进行排序 //以空间换时间 时间复杂度：O(nlogn) 3.基数排序：类似于将桶排序与计数排序结合，从待排序数组当中，元素的最低有效位到最⾼有效位,逐位进⾏⽐较排序；此外，基数排序使⽤计数排序作为⼀个排序的⼦过程。 时间复杂度:O(n * log以b为底n),b为进制数 为非就地排序 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; //将区间[left,mid][mid+1,right]数据合并 void Merge(vector&amp;lt;int&amp;gt;(&amp;amp;v), int left, int mid, int right) { int i(left); int j(mid + 1); //临时存储 vector&amp;lt;int&amp;gt; v2(v); int k(0); while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if (v[i] &amp;lt;= v[j]) { v2[k] = v[i]; ++i; ++k; } else { v2[k] = v[j]; ++j; ++k; } } while (i &amp;lt;= mid) { v2[k] = v[i]; ++i; ++k; } while (j &amp;lt;= right) { v2[k] = v[j]; ++j; ++k; } for (int q = 0; q &amp;lt; k; ++q) { v[left + q] = v2[q]; } } //将区间[left,right]数据二分 void Merge_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v),int left,int right) { //元素大于等于两个 if (left &amp;lt; right) { int mid((left + right) / 2); //left---mid Merge_Sort(v, left, mid); //mid + 1---right Merge_Sort(v, mid + 1, right); //合并函数,mid为合并的位置 Merge(v, left, mid, right); } } void Count_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v)) { vector&amp;lt;int&amp;gt; count; int max(-1); for (auto a : v) { if (a &amp;gt; max) { max = a; } } count.</description>
    </item>
    
    <item>
      <title>数据结构 选择排序和堆排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 02 Feb 2024 19:58:39 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>选择：每次选出一个合法（最大/最小）的数据放到其最终应该在的位置 1.（简单）选择排序：每趟从待排序区中，选择一个最小的数，放到待排序区的第一个位置，从而实现升序排列。 时间复杂度：O(n^2) 是否稳定：不稳定 为就地排序 2.对选择排序进行优化----&amp;gt;堆排序 对于一棵完全二叉树，进行编号，编号规则为：根节点为1，然后从上到下，从左到右。除根节点外，节点i的父亲节点编号为i/2(向下取整)。除叶子节点外，节点i的左孩子节点编号为2*i，右节点为2*i+1（可直接用数组存储） 堆(Heap):是一类基于完全二叉树的特殊数据结构 1.大顶堆：在大顶堆中，根节点的值必须大于等于其孩子节点的值，且所有子树均满足 2.小顶堆：在小顶堆中，根节点的值必须小于等于其孩子节点的值，且所有子树均满足 1.建堆：用一个数组保存 （1）自我初始化：在原数组基础上进行初始化 从子树入手，由小及大去调整每棵子树（不包含叶子节点）： 对于每棵子树，我们向下调整： 让根节点和其左右孩子作比较，最小值和根节点交换，继续向下调整子树 （2）通过插入建堆 数组中每多一个数据就调整一次，新插入的数据放在最后，如果其比父亲大或者新插入的数据是根节点就不用调整，否则就向上调整 堆排序： （1）建堆 （2）循环n次，每次输出最小数----&amp;gt;a[0] （3）删掉a[0]----&amp;gt;让堆中最后一个节点替换a[0],然后重新对a[0]向下调整 时间复杂度：O(nlogn) 是否稳定：不稳定 为就地排序 堆的应用： 1.优先队列：基于堆 2.1亿个数，选出前一百个最大的数，不能使用大顶堆，使用小顶堆 a[100]---&amp;gt;堆 先读入100个数，建立小顶堆 接下来，当读入一个数x时，如果x&amp;lt;=a[0],直接读入下一个数 否则a[0]=x,向下调整小顶堆 最后留下来的小顶堆就是答案 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; //i为根节点下标 void Down_Adjust(vector&amp;lt;int&amp;gt;(&amp;amp;v), int i,int size) { int parent(i);//根节点下标 int l_child(2 * i);//左孩子下标 int tmp(0); //因为调整后可能子树不再是小顶堆，所以循环向下调整 while (parent * 2 &amp;lt;= size) { l_child = 2 * parent; if (l_child + 1 &amp;lt;= size &amp;amp;&amp;amp; v[l_child + 1] &amp;lt; v[l_child]) { l_child = l_child + 1; } //此时，l_child是值较小的孩子 if (v[parent] &amp;lt; v[l_child]) { break; } else { tmp = v[l_child]; v[l_child] = v[parent]; v[parent] = tmp; parent = l_child; } } } void Up_Adjust(vector&amp;lt;int&amp;gt;(&amp;amp;v),int i) { int tmp(0); int child(i); int parent(0); //不是根节点就继续调整 while (child &amp;gt; 1) { parent = child / 2; if (v[parent] &amp;lt; v[child]) { break; } else { tmp = v[parent]; v[parent] = v[child]; v[child] = tmp; child = parent; } } } void Heap_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v)) { //1.</description>
    </item>
    
    <item>
      <title>数据结构 冒泡排序和快速排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 31 Jan 2024 11:42:51 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>交换：根据数据之间的比较，把每个数据都放在自己应该的位置 （1）冒泡排序：通过不断的比较两个相邻的元素，若这两个元素是乱序的，则交换位置。从而实现每趟都把最大的数据交换到最后面 时间复杂度：O(n^2) 是否稳定：稳定 为就地排序 （2）快速排序：首先选定一个基准数（比较的标准），把比基准数x小的数据放在x前面，比基准数x大的数据放在后面。排好一趟后，x把序列划分为了两部分，这两部分还都是乱序的，再分别对这两部分进行快速排序。//递归 选择基准数（排序区间[l.r]）:理论上谁都可以 (1)选择排序区间第一个 a[l]----为例 1.两个下标i=l,j=r;相对遍历 2.先用j找一个比x小的数，放在i位置，i++ 3.再用i找一个比x大的数，放在j位置，j-- 4.不断循环，直到i==j为止，此时i/j位置就是x的位置 5.然后再对x前后两个区域进行递归调用 (2)选择排序区间最后一个 a[r] (3)选择排序区间中间位置 a[(l+r)/2] 时间复杂度：O(nlogn) 是否稳定：不稳定 为就地排序 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; //left和right分别为排序区间范围 void Quick_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v), int left, int right) { int i(left); int j(right); //递归出口,即排序区间只有一个元素时不进行排序 if (left &amp;lt; right) { int x(v[i]); //排序 while (i &amp;lt; j) { while (i &amp;lt; j &amp;amp;&amp;amp; v[j] &amp;gt; x) { j--; } if (i &amp;lt; j) { v[i] = v[j]; i++; } while (i &amp;lt; j &amp;amp;&amp;amp; v[i] &amp;lt; x) { i++; } if (i &amp;lt; j) { v[j] = v[i]; j--; } } v[i] = x; //递归调用，以v[i] = x为基准 Quick_Sort(v, left, i - 1); Quick_Sort(v, i + 1, right); } //选取区间第一个作为基准数 } void Quick_Sort_2(vector&amp;lt;int&amp;gt;(&amp;amp;v),int left,int right) { int i(left); int j(right); //递归出口,即排序区间只有一个元素时不进行排序 if (left &amp;lt; right) { int x(v[j]); //排序 while (i &amp;lt; j) { while (i &amp;lt; j &amp;amp;&amp;amp; v[i] &amp;lt; x) { i++; } if (i &amp;lt; j) { v[j] = v[i]; j--; } while (i &amp;lt; j &amp;amp;&amp;amp; v[j] &amp;gt; x) { j--; } if (i &amp;lt; j) { v[i] = v[j]; i++; } } v[i] = x; //递归调用，以v[i] = x为基准 Quick_Sort(v,left,i-1); Quick_Sort(v,i+1,right); } //选取区间最后一个作为基准数 } void Bubble_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v)) { int tmp(0); //枚举趟数 for (int i = 0; i &amp;lt; v.</description>
    </item>
    
    <item>
      <title>数据结构 插入排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 29 Jan 2024 22:00:10 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>排序：基本概念 1.基于插入： （1）直接插入排序 （2）希尔（shell）排序算法 2.基于交换： （1）冒泡排序 （2）快速排序 3.基于选择： （1）简单选择排序 （2）堆排序 4.其他： （1）归并排序 （2）基于计数的排序 如何判断排序好坏： 1.就地排序/非就地排序（反映空间复杂度） （1）如果在排序过程中，只使用到了存储数据的空间，没有使用其他额外空间，称为是就地排序 2.内部排序/外部排序 （1）待排序数据能够一次性放到内存中----&amp;gt;内部排序 （2）待排序数据不能够一次性放到内存中----&amp;gt;外部排序 注：目前只有归并排序是外部排序 3.稳定排序/不稳定排序 （1）排序前后相同数据的相对位置没有发生变化----&amp;gt;稳定的 （2）排序前后相同数据的相对位置发生变化----&amp;gt;不稳定的 4.时间复杂度 （1）直接插入排序：在添加新的数据时，我们使用顺序查找（遍历）的方式，找到其要插入的位置，将其插入 //（将数据分为有序区与待排序区，基本所有排序算法都会将数据分为这两个区域） 时间复杂度：O(n^2) 注：第一版代码不稳定，略加优化后稳定，时间复杂度不变 是否稳定：稳定 为就地排序 -折半插入排序 //优化：将直接插入排序中顺序查找换成二分查找，时间复杂度不变，为稳定排序 -2路插入排序 //优化：在折半插入排序基础上，引入一个循环数组，将排序过程中移动次数减少，时间复杂度不变，为非就地排序 注：在使用直接插入排序时，如果表中记录只有个别是无序的，多数保持有序，这种情况下算法的效率也会比较高，此外，如果需要排序数据总量较少，算法效率同样会很高。下述希尔排序便是基于这两点进行改进。 （2）希尔（shell）排序算法（缩小增量排序算法）：在直接插入排序算法的基础上，对待排序数据进行分组，先对每组进行排序，然后不断缩小组数，不断排序，最终缩小为一组。 分组：分成组数与数据下标增量相同，如0--3四个数据，分为0 2，1 3 增量的选择：对n个数据进行排序，依次分为 n/2，n/4，n/8...1组 ----&amp;gt;希尔增量序列 时间复杂度：最坏为O(n^2) 是否稳定：不稳定 为就地排序 //上述为取希尔增量序列时的情况 注：直接插入排序就是增量为一的希尔排序 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; //直接插入排序（不稳定） void Insert_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v)) { //保存待排序数据 int tmp(0); //保存待排序数据应该所处位置下标 int ind(0); //第一趟可以不排 for (int i = 1; i &amp;lt; v.</description>
    </item>
    
    <item>
      <title>数据结构 关键路径</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 29 Jan 2024 20:36:40 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</guid>
      <description>AOV网：在DAG中，用顶点表示活动，用弧表示活动之间的优先关系的有向图称为顶点表示活动的网----&amp;gt;工程中小项目次序 AOE网：在DAG中，用顶点表示事件，用带权有向边表示活动，边权表示活动持续时间 ----&amp;gt;工程中小项目次序，每个小项目多久做完，整个工程多久做完 事件：刹那间发生的一件事情 活动：一个完整流程，可能由很多事件组成，有开始和结束 关键路径：整个项目工程中，耗时最长的路径称为关键路径，关键路径上的活动称为关键活动。----&amp;gt;注：关键路径不唯一，我们需要关注所有关键路径 关键路径：从起点到终点，最长的路径（们），由关键活动组成。 关键活动：最早开始时间 == 最晚开始时间 ETE == LTE 非关键活动：最早开始时间 != 最晚开始时间 ETE != LTE （1）事件最早发生时间（ETV） 1.起点事件start最早发生时间 == 0 ETV[start] == 0 2.其余事件的最早发生时间基于拓扑序列去算 ETV[j] = max(ETV[j],ETV[i]+wi) i------&amp;gt;j （2）事件最晚发生时间（LTV） 1.终点事件end的最晚发生时间 LTV[end] = ETV[end] (若未给出的话则按左式计算) 2.其余事件最晚发生时间基于逆拓扑序列计算 LTV[i] = min(LTV[i],LTV[j]-wj) i------&amp;gt;j 3.起点事件start最晚发生时间 == 0 LTV[start] == 0 == ETV[start] （3）活动最早开始时间（ETE/ES） 1.ETE==该边起点事件的ETV ETE = ETV[i] （4）活动最晚开始时间（LTE/LS） 注：保证终点事件在DDL之前按时发生 1.LTE==该边终点事件LTV - 该边权值 注：终点事件最早发生时间就是工程完成时间 时间复杂度：O(n+m) 注：n为点数，m为边数 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; //引入一个栈，用于保存所有入度为零的的点的下标 class Stack_Node { public: int data; Stack_Node* next; }; class m_stack { public: Stack_Node* head; public: m_stack() { head = new Stack_Node; if (head == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { head-&amp;gt;next = nullptr; } } void m_push(int k) { Stack_Node* p = new Stack_Node; p-&amp;gt;data = k; p-&amp;gt;next = head-&amp;gt;next; head-&amp;gt;next = p; } int m_pop() { if (head-&amp;gt;next == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;栈空&amp;quot; &amp;lt;&amp;lt; endl; return -1; } Stack_Node* p = head-&amp;gt;next; int ret = p-&amp;gt;data; head-&amp;gt;next = p-&amp;gt;next; delete p; p = nullptr; return ret; } }; class List_Node { public: int data; int wi;//权值 List_Node* next; }; class Graph_Node { public: char vi; List_Node* first; }; class Graph { public: int size1;//点的个数 int size2;//边的个数 Graph_Node* g;//邻接表 int* ind;//入度数组 int* topo;//拓扑序列,改为记录下标便于计算 int* etv;//事件最早发生时间 int* ltv;//事件最晚发生时间 public: Graph(int sz1,int sz2):size1(sz1),size2(sz2) { g = new Graph_Node[sz1]; ind = new int[sz1]; topo = new int[sz1]; etv = new int[sz1]; ltv = new int[sz1]; if (g == nullptr || ind == nullptr || topo == nullptr|| etv == nullptr || ltv == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { //初始化点 for (int i = 0; i &amp;lt; sz1; ++i) { cin &amp;gt;&amp;gt; g[i].</description>
    </item>
    
    <item>
      <title>数据结构 拓扑排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 27 Jan 2024 20:09:41 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>注：有向无环图（DAG图） AOV网：用顶点表示活动，用弧表示活动之间的优先关系的有向图称为顶点表示活动的网 注：AOV网一定是有向无环图 拓扑序列：对于一个有n个顶点的有向图，顶点序列v1,v2...vn若满足从顶点vi到vj有一条路径，则顶点序列中vi必在vj之前，这样的一个顶点序列为一个拓扑序列 拓扑排序：对一个有向无环图构造拓扑排序的过程（同时还可以判断图内部是否成环） 1.在有向图中选一个没有前驱的顶点并输出 2.从图中删除该顶点和所有以他为尾的弧 重复上述两步，直至全部顶点均已输出，或者当前图不存在无前驱的顶点为止，后一种情况说明有向图中存在环 应用：拓扑序列，关键路径 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; //引入一个栈，用于保存所有入度为零的的点的下标 class Stack_Node { public: int data; Stack_Node* next; }; class m_Stack { public: Stack_Node* head; public: m_Stack() { head = new Stack_Node; if (head == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { head-&amp;gt;next = nullptr; } } void m_push(int k) { Stack_Node* s = new Stack_Node; s-&amp;gt;data = k; s-&amp;gt;next = head-&amp;gt;next; head-&amp;gt;next = s; } int m_pop() { if (head-&amp;gt;next == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;栈空&amp;quot; &amp;lt;&amp;lt; endl; return -1; } else { int ret(0); Stack_Node* p = head-&amp;gt;next; head-&amp;gt;next = p-&amp;gt;next; ret = p-&amp;gt;data; delete p; p = nullptr; return ret; } } }; //邻接表存有向图 class List_Node { public: int data;//邻接点下标 List_Node* next; }; class Graph_Node { public: char data;//顶点编号 List_Node* first;//出边链表头指针 }; class Graph { public: int size1;//点的个数 int size2;//边的个数 Graph_Node* g;//邻接表 int* ind;//入度数组 char* topo;//拓扑序列 public: Graph(int sz1,int sz2):size1(sz1),size2(sz2) { g = new Graph_Node[sz1]; ind = new int[sz1]; topo = new char[sz1]; if (g == nullptr || ind == nullptr || topo == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { //初始化点 for (int i = 0; i &amp;lt; sz1; ++i) { cin &amp;gt;&amp;gt; g[i].</description>
    </item>
    
    <item>
      <title>数据结构 最短路径</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 27 Jan 2024 10:19:17 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>注：对于无向无权图而言，最短路径就是经过边的条数，可以通过BFS求 对于无向带权图，有如下常用算法 单源最短路径算法 1.dijkstra算法----&amp;gt;贪心 单源最短路 O(n^2) 不能解决带负边权问题 多源最短路径算法 2.Floyd算法----&amp;gt;动态规划 多源最短路 o(n^3) 不能解决负边权回路 最短路径算法核心思想：用中转点找更短的路径 注：源点（即起点） dijkstra算法 循环n-1次，每次找到一 最小并且未确定最短路径的点y，点y的最短路径就确定下来，然后用y去更新y的邻接点到源点的最短路径长度 时间复杂度：O(n^2) 注：n为点的个数 dijkstra算法: #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; class Graph { public: int size1;//点的个数 int size2;//边的个数 int** graph; bool* visit;//标记点到源点的最短路径是否确定下来 int* pre;//记录点的上一个中转点下标，源点中转点为其自身 int* dist;//记录点到源点最小距离 public: Graph(int sz1, int sz2) :size1(sz1), size2(sz2) { graph = new int* [sz1]; visit = new bool[sz1]; pre = new int[sz1]; dist = new int[sz1]; if (graph == nullptr || visit == nullptr || pre == nullptr || dist == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { for (int i = 0; i &amp;lt; sz1; ++i) { graph[i] = new int[sz1]; if (graph[i] == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } } //初始化 for (int i = 0; i &amp;lt; sz1; ++i) { for (int j = 0; j &amp;lt; sz1; ++j) { if (i == j) { graph[i][j] = 0; } else { graph[i][j] = 999999; } } visit[i] = false; pre[i] = -1; dist[i] = 999999; } //输入边 int x(0); int y(0); int wi(0); for (int i = 0; i &amp;lt; sz2; ++i) { cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; wi; graph[x][y] = graph[y][x] = wi; } } } void dijkstra() { //输入起点 int x(0); cin &amp;gt;&amp;gt; x; visit[x] = true; pre[x] = x; dist[x] = 0; //更新邻接点 for (int i = 0; i &amp;lt; size1; ++i) { dist[i] = graph[x][i]; } //循环n-1次 int min_n(999999); int k(0);//dist[k]最小 for (int i = 0; i &amp;lt; size1 - 1; ++i) { min_n = 999999; for (int j = 0; j &amp;lt; size1; ++j) { if (visit[j] == false &amp;amp;&amp;amp; dist[j] &amp;lt; min_n) { k = j; min_n = dist[j]; } } //以k为中转点更新其邻接点dist //注：因为第一个k对应pre无法更新，所以单独判断 if (i == 0) { visit[k] = true; pre[k] = x; } else { visit[k] = true; } for (int j = 0; j &amp;lt; size1; ++j) { if (visit[j] == false &amp;amp;&amp;amp; dist[j] &amp;gt; (dist[k] + graph[k][j])) { dist[j] = dist[k] + graph[k][j]; pre[j] = k; } } } } }; int main() { Graph g(9, 16); g.</description>
    </item>
    
    <item>
      <title>数据结构 最小生成树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Wed, 24 Jan 2024 16:32:01 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>生成树：一个连通图的生成树时一个极小连通子图，包含n个顶点，但只有构成一棵树的n-1条边 注：包含n个顶点的无向完全图最多包含n^(n-2)棵生成树 注：只有无向图才有生成树（且必须为连通图），有向图对应概念为树型生成图 生成树的属性： 1.一个连通图可以有多个生成树 2.一个连通图的所有生成树都包含相同的顶点个数和边数 3.生成树当中不存在环 4.移除生成树中的任意一条边都会导致图的不连通 5.在生成树中添加一条边会构成环 6.对于包含n个顶点的连通图，生成树包含n个顶点和n-1条边 7.对于包含n个顶点的无向完全图最多包含包含n^(n-2)棵生成树 最小生成树：一个带权图的生成树，该生成树边权之和最小，则称该生成树为最小生成树 注：只有无向连通带权图才有最小生成树，且最小生成树不一定唯一 1.Kruskal算法----&amp;gt;从边出发 //基于贪心和并查集 1.选择权值尽可能小的n-1条边----&amp;gt;排序：选择排序算法 2.选边时，选的每一条边都得是连接未连通的两个节点才行，否则成环---&amp;gt;通过并查集判断一条边的两个点是否属于同一个集合，若不属于，则该边可选，并合并两个不同集合 时间复杂度：主要分为两块 选择排序O(m^2)+并查集O(m)----&amp;gt;O(m^2) 注：即Kruskal算法时间复杂度取决于排序算法时间复杂度，比如使用快速排序将会变为mlogm （m为边的数目） 2.Prim算法-----&amp;gt;从点出发 //基于贪心 点到生成树的距离dist： 1.已经在生成树中的点：0 2.不在生成树中的点：该点与生成树中任意若干点直接相连，其每条连接边对应的权值就是dist 注：不考虑间接相连，间接相连dist视为无穷大 点分为两类： 1.已经选中的点，已经构成一部分生成树 2.还未选中的点 选择n次： 第一次：任意选择一个点 接下来n-1一次：选则第二类中点，该点dist最小，同时通过选中的点更新与其相连的点到生成树的dist 思路： 维护一个点到生成树的最小距离dist[],初始化为无穷大 维护一个标记数组visit[] 1.任选一个点作为起点，把起点x加入到生成树中：visit[x]=1,dist[x]=0 2.更新x邻接点到生成树最小距离 3.执行n-1次循环（1）找到visit[]==0且dist[]最小的点下（2）把起点x加入到生成树中：visit[x]=1,dist[x]=0 (3)更新x邻接点到生成树最小距离 时间复杂度：O(n^2) 注：n为点的个数 注：点多边多（稠密图）Prim算法，点多边少（稀疏图）Kruskal算法 Kruskal算法: #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; //并查集 class Tree_Node { public: int fi; int data;//注：本图所有点编号与其下标对应 }; class Tree { public: Tree_Node* pN; int size; public: Tree(int sz) :size(sz) { pN = new Tree_Node[size]; for (int i = 0; i &amp;lt; size; ++i) { pN[i].</description>
    </item>
    
    <item>
      <title>数据结构 图</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</link>
      <pubDate>Wed, 27 Dec 2023 19:57:55 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</guid>
      <description>图的概念： 逻辑结构：多对多 graph 图 g vertex 顶点 v edge 边\弧 e 图G是由两个集合V和E构成，G = (V,E),其中V是顶点的有限非空集合，E是V中顶点偶对的有限集，这些顶点偶对称为边（弧） 重边：两个顶点不只有一条边 自边：顶点自身形成一条边 图的分类： 不同的维度： 1.方向性：有向图和无向图 2.环：带环图和无环图 //环：从一个点x出发，沿着边走，最终可以回到x 注：有向无环图（DAG） 3.边权：无权图 带权图 图的基本术语： 1.简单图：若不存在顶点到自身的边，且同一条边不重复出现，则称这样的图为简单图 2.无向图：在图中，如果代表边的顶点偶对是无序的，则为无向图 3.有向图：在图中，如果代表边的顶点偶对是有序的，则为有向图 //有向边（弧） //起点：弧尾 //终点：弧头 //注：无向图可以看成有向图 4.完全图：图中每两个顶点都有一条边 //完全有向图：n（n-1）条边 //完全无向图：n（n-1）/2条边 5.端点，邻接点； 端点：边的两个顶点 邻接点：上述两个顶点互为邻接点 6.顶点的度，入度和出度 //对于无向图而言 度：该点所连的边数 //对于有向图而言 入度；入边的个数 出度：出边的个数 度：出度+入度（一定为偶数） 7.子集：与子树类似 8.路径，路径长度： 路径：顶点序列 路径长度：边的数目 简单路径：一条路径上除开始点和结束点可以相同外，其余顶点均不相同（路径中不含环） 9.回路，环 欧拉环路：经过图中各边一次且恰好一次的环路 哈密尔顿环路：经过图中各顶点一次且恰好一次的环路 10.连通，连通图和连通分量（针对无向图） 1.连通：如果顶点x和y之间存在可以相互抵达的路径，则称两个顶点连通 2.连通图：图中任意两个顶点都连通 3.连通分量：无向图中的极大连通子图称为图的连通分量 注：连通图只有一个极大连通子图（自身） 非连通图有多个极大连通子图 注:极大连通子图（连通分量） 极小连通子图（图的生成树）：在保证各点连通的情况下，边最少 11.强连通图和强连通分量（针对有向图，含义同上） 12.稠密图和稀疏图 一个图接近完全图时，称为稠密图，当一个图含有较少边数时，称为稀疏图，一般以nlogn作为分界线（n为节点个数） 13.权和网 边上带有权的图称为带权图，也称之为网 //注：自边权值看作零，两个点之间没有连接权值看作无穷大 14.连通图的生成树（针对无向图） 连通图的生成树是一个极小的连通子图 图的存储： 1.</description>
    </item>
    
    <item>
      <title>数据结构 时间复杂度</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Wed, 27 Dec 2023 19:57:28 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构 树,二叉树和森林的转换</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Wed, 20 Dec 2023 19:41:57 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid>
      <description>扩展补充一下树,二叉树和森林的转换
1.普通树转换为二叉树 1.加线，在所有兄弟节点之间加一条连线 2.断线，只保留每个节点第一个孩子（从左到右）
2.二叉树转换为普通树 上述过程的逆过程
3.森林转换为二叉树 1.先把森林中每棵树转换为二叉树 2.加线，第一棵二叉树不动，从第二棵树开始，依次把后一棵二叉树根节点作为前一棵二叉树的根节点的右孩子
4.二叉树转换为森林 上述过程逆过程
注：如何判断一棵二叉树是由森林还是普通的树转换而来呢？ 根据二叉树根节点是否有右孩子来判断： 1.由普通树转换而来没有右孩子 2.由森林转换而来的有右孩子</description>
    </item>
    
    <item>
      <title>数据结构 哈夫曼树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</link>
      <pubDate>Wed, 20 Dec 2023 16:49:51 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</guid>
      <description>1.节点i的路径长度：从根节点到节点i的路径上所经过边数
2.树的路径长度：所有节点的路径长度之和
内部路径长度：所有内部节点路径长度之和
外部路径长度（有时会把树的路径长度当作外部路径长度）：所有叶子节点路径长度之和
3.节点i的带权路径长度：节点i的路径长度*节点i权值
4.树的带权路径长度（WPL）：所有叶子节点的带权路径长度之和
给出n个节点（都带有权值），可以再自行加入若干节点（不确定），用这n个节点全部做叶子节点，自行加入的节点做内部节点去建立一棵二叉树，其中WPL最小的一棵二叉树称为哈夫曼树（最优二叉树）
注：哈夫曼树WPL的值唯一
但WPL的值最小的哈夫曼树不唯一
如何构建哈夫曼树？
给定n个节点（带权值且只做叶子节点）
1.一开始认为n个节点为n棵树
2.每次找根节点权值最小的两棵树（x，y），再新加入一个节点z做x和y的父亲，新的根节点权值为（x，y），此时将x，y两棵树合并出一棵新树，这棵树的根节点为z
哈夫曼树应用：通过编码进行数据压缩
哈夫曼编码&amp;mdash;&amp;gt;变长编码，压缩空间
定长编码：ASCII编码（8bit），Unicode编码（16bit）
缺陷：浪费空间
变长编码：比定长编码省空间
可以使用哈夫曼树来构造变长编码&amp;mdash;&amp;gt;哈夫曼编码
1.先统计一条消息中n个字符分别出现频率&amp;mdash;&amp;gt;节点权值
2.构造哈夫曼树
3.标上1和0
注：哈夫曼树WPL值即为信息编码所占bit位数
注：变长编码中遵循前缀属性原则（短的编码不能是长编码的前缀，避免二义性）
哈夫曼编码树实现：
1.建立哈夫曼树：把每个字符的频率看作节点的权值，建立哈夫曼树，通过结构体数组模拟存储
节点：权值，父亲的下标，左右孩子节点的下标
（1）查找最小的两个根节点 （2）合并，加入一个新的根节点 注：n个叶子节点，总共有2*n-1个节点
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; class Node { public: int w;//权值 int fi;//父亲节点坐标 int left;//左右孩子节点下标 int right; }; class HFM_Tree { public: int size;//节点个数 Node* tree;//指针模拟开数组 public: HFM_Tree(int w_arr[], int sz) :size(2 * sz - 1) { tree = new Node[size]; if (tree == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { //初始化哈夫曼树（从下标为零开始存储） for (int i = 0; i &amp;lt; size; ++i) { tree[i].</description>
    </item>
    
    <item>
      <title>数据结构 并查集</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Wed, 20 Dec 2023 16:28:15 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>今天学习并查集，一种常用的树的算法，之后还会学习哈夫曼树
并查集：利用树型结构来处理一些不相交的集合的合并和查询问题
合并两个集合（两棵树）：只需要合并两棵树的根节点，先找到各自的根节点，把根节点设立父子关系即可
查询两个节点是否在同一个集合（树）：只需要找到两个节点的根节点，看根节点是否相同
并查集用树型结构实现：双亲表示法
并查集算法优化：路径压缩（递归实现）
例题：洛谷p1551&amp;mdash;亲戚
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; class Tree_Node { public: int fi; int data; public: }; class Tree { public: int size; Tree_Node* pN; public: Tree(int sz):size(sz) { pN = new Tree_Node[sz]; for (int i = 0; i &amp;lt; sz; ++i) { pN[i].fi = pN[i].data = i + 1; } } int Find_fi(int k)//找祖先 { while (pN[k - 1].fi != k) { k = pN[k - 1].</description>
    </item>
    
    <item>
      <title>数据结构 平衡二叉树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 11 Dec 2023 22:25:55 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>开始学习AVL树了，目前简单了解了其相关概念
平衡因子：
基本旋转方式：
1.左单旋 记失衡节点为x x右孩子为y x-&amp;gt;right = y-&amp;gt;left y-&amp;gt;left = x 2.右单旋 记失衡节点为x x左孩子为y x-&amp;gt;left = y-&amp;gt;right y-&amp;gt;right = x 最小失衡子树：在新插入的节点向上查找，以第一个平衡因子的绝对值超过一的节点为根节点的子树 插入：
1.进行BST插入 2.算插入节点的所有祖先节点的平衡因子 节点x高度x-&amp;gt;h = max(x-&amp;gt;left-&amp;gt;h,x-&amp;gt;right-&amp;gt;h) + 1 节点平衡因子:x-&amp;gt;left-&amp;gt;h - x-&amp;gt;right-&amp;gt;h(左右子树高度差的绝对值) 3.插入导致失衡情况，进行旋转（优先调整最小失衡子树） 判断失衡：
1.先找出x-&amp;gt;left和x-&amp;gt;right中高度较高的 2.再去高度子树里面去看根节点的哪边的子树高 4.调用对应调整函数
假设最小失衡子树根节点为A 1.LL 在A节点左孩子的左子树插入节点破坏平衡 调整策略：对A进行一次右旋 2.LR 在A节点左孩子的右子树插入节点破坏平衡 调整策略：（1）以A-&amp;gt;left为中心进行左旋，转换成为了LL (2)按照LL情况进行操作 3.RR 在A节点右孩子的右子树插入节点破坏平衡 调整策略：对A进行一次左旋 4.RL 在A节点右孩子的左子树插入节点破坏平衡 调整策略：（1）以A-&amp;gt;right为中心进行右旋，转换为RR (2)按照RR情况进行操作 删除操作
1.执行二叉排序树删除 2.判断是否失衡 在x节点的一边子树中删除了一个节点，就等价于在其另一边子树插入了一个节点导致的失衡---&amp;gt;删除的失衡类型及调整方式和插入的一模一样 左删除 相当于 右边插入：RR RL 右删除 相当于 左边插入：LL LR 终于完成了AVL树了，接下来就学习一下哈夫曼树（似乎是另一条路线的样子）和时间复杂度了
日常：麻了，四级好像要寄了，算了一下，似乎430~440的样子（作文翻译全按及格算的），希望能过 下周二考工程师职业素养期末，坐大牢，本来说周末复习的，装一个远行星号装了一上午，下午还有文明经典，属实难绷
代码实现如下
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class AVL_Node { public: T data; AVL_Node&amp;lt;T&amp;gt;* left = nullptr; AVL_Node&amp;lt;T&amp;gt;* right = nullptr; int h = 1;//记录节点高度 }; template&amp;lt;class T&amp;gt; class AVL_Tree { public: AVL_Tree() { root = new AVL_Node&amp;lt;T&amp;gt;; if (root == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { root-&amp;gt;left = nullptr; root-&amp;gt;right = nullptr; } } AVL_Tree(T k) { root = new AVL_Node&amp;lt;T&amp;gt;; if (root == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { root-&amp;gt;left = nullptr; root-&amp;gt;right = nullptr; root-&amp;gt;data = k; } } AVL_Node&amp;lt;T&amp;gt;* AVL_Insert(AVL_Node&amp;lt;T&amp;gt;* ro, T k) { if (ro == nullptr) { AVL_Node&amp;lt;T&amp;gt;* s = new AVL_Node&amp;lt;T&amp;gt;; s-&amp;gt;data = k; return s; } else if (k &amp;lt; ro-&amp;gt;data) { ro-&amp;gt;left = AVL_Insert(ro-&amp;gt;left, k); //高度可能变化,判断是否失衡 if (Get_h(ro-&amp;gt;left) - Get_h(ro-&amp;gt;right) &amp;gt; 1) { AVL_Node&amp;lt;T&amp;gt;* l = ro-&amp;gt;left;//用于判断失衡类型 //也可以通过子树高度判断 //if (Get_h(l-&amp;gt;left) &amp;gt; Get_h(l-&amp;gt;right)) if (k &amp;lt; l-&amp;gt;data) { //LL ro = LL_rotation(ro); } else { //LR ro = LR_rotation(ro); } } //返回变化后子树根节点并且改变高度(因为都要进行，所以可以一起挪到函数末尾)	} else { ro-&amp;gt;right = AVL_Insert(ro-&amp;gt;right, k); //高度可能变化,判断是否失衡 if (Get_h(ro-&amp;gt;right) - Get_h(ro-&amp;gt;left) &amp;gt; 1) { AVL_Node&amp;lt;T&amp;gt;* r = ro-&amp;gt;right;//用于判断失衡类型 //也可以通过子树高度判断 //if(Get_h(r-&amp;gt;right) &amp;gt; Get_h(r-&amp;gt;left)) if (k &amp;gt; r-&amp;gt;data) { //RR ro = RR_rotation(ro); } else { //RL ro = RL_rotation(ro); } } //返回变化后子树根节点并且改变高度(因为都要进行，所以可以一起挪到函数末尾) } ro-&amp;gt;h = max(Get_h(ro-&amp;gt;left), Get_h(ro-&amp;gt;right)) + 1; return ro; } int Get_h(AVL_Node&amp;lt;T&amp;gt;* x) { if (x == nullptr) { return 0; } else { return x-&amp;gt;h; } } AVL_Node&amp;lt;T&amp;gt;* LL_rotation(AVL_Node&amp;lt;T&amp;gt;* ro) { AVL_Node&amp;lt;T&amp;gt;* y = ro-&amp;gt;left; ro-&amp;gt;left = y-&amp;gt;right; y-&amp;gt;right = ro; //高度可能改变 ro-&amp;gt;h = max(Get_h(ro-&amp;gt;left), Get_h(ro-&amp;gt;right)) + 1; y-&amp;gt;h = max(Get_h(y-&amp;gt;left), Get_h(y-&amp;gt;right)) + 1; return y; } AVL_Node&amp;lt;T&amp;gt;* LR_rotation(AVL_Node&amp;lt;T&amp;gt;* ro) { ro-&amp;gt;left = RR_rotation(ro-&amp;gt;left); ro = LL_rotation(ro); return ro; } AVL_Node&amp;lt;T&amp;gt;* RR_rotation(AVL_Node&amp;lt;T&amp;gt;* ro) { AVL_Node&amp;lt;T&amp;gt;* y = ro-&amp;gt;right; ro-&amp;gt;right = y-&amp;gt;left; y-&amp;gt;left = ro; //高度可能改变 ro-&amp;gt;h = max(Get_h(ro-&amp;gt;left), Get_h(ro-&amp;gt;right)) + 1; y-&amp;gt;h = max(Get_h(y-&amp;gt;left), Get_h(y-&amp;gt;right)) + 1; return y; } AVL_Node&amp;lt;T&amp;gt;* RL_rotation(AVL_Node&amp;lt;T&amp;gt;* ro) { ro-&amp;gt;right =LL_rotation(ro-&amp;gt;right); ro = RR_rotation(ro); return ro; } void mid_order(AVL_Node&amp;lt;T&amp;gt;* ro) { if (ro == nullptr) { return; } if (ro-&amp;gt;left !</description>
    </item>
    
    <item>
      <title>数据结构 排序二叉树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 11 Dec 2023 11:36:02 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>又一次被树折磨，这一次是排序二叉树，似乎能够理解为什么set容器能够实现插入后自动排序了，也去查了一下资料，set底层确实是以二叉树实现的。
一点点注意事项： 如果序列本身为升序或者降序，会形成斜树（即链表，起不到优化作用） BST + 限制 = AVL树
接下来就是AVL树（二叉平衡树）了，准备坐大牢，已经在思考红黑树会有多坐牢了，不过学完树之后似乎只剩图和串了，之后就要开始算法坐大牢了&amp;hellip;&amp;hellip;
日常： 快放假了，但是一堆期末考试在等着我，估计了一下约莫有八九门的样子，希望别挂科（应该不会，感觉学的还是挺好的，就是历史闭卷有点难绷），距离四级还有六天，似乎注定要裸考了，乐
代码实现：
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class BST_Node { public: T data; BST_Node&amp;lt;T&amp;gt;* left; BST_Node&amp;lt;T&amp;gt;* right; public: BST_Node() { left = nullptr; right = nullptr; } }; template&amp;lt;class T&amp;gt; class BST { public: BST_Node&amp;lt;T&amp;gt;* root; public: BST(T k) { root = new BST_Node&amp;lt;T&amp;gt;; if (root == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;建树失败&amp;quot; &amp;lt;&amp;lt; endl; } else { root-&amp;gt;data = k; } } //非递归实现插入 BST_Node&amp;lt;T&amp;gt;* Insert_non_recursion(T k) { BST_Node&amp;lt;T&amp;gt;* s = new BST_Node&amp;lt;T&amp;gt;; if (s == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;插入失败&amp;quot; &amp;lt;&amp;lt; endl; } else { s-&amp;gt;data = k; s-&amp;gt;left = nullptr; s-&amp;gt;right = nullptr; //通过p进行遍历，pre指向p父亲节点 BST_Node&amp;lt;T&amp;gt;* p = root; BST_Node&amp;lt;T&amp;gt;* pre = nullptr; while (p !</description>
    </item>
    
    <item>
      <title>数据结构 树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</link>
      <pubDate>Wed, 22 Nov 2023 20:07:38 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</guid>
      <description>被文科折磨的百忙之中抽空学习(麻了，我还是个工科生吗)，学习完之后一堆文科小组作业等着我&amp;hellip;&amp;hellip;(主打一个裸考四级，乐)
树型结构：逻辑结构 概念：树是存储一对多关系的数据的逻辑结构，在树中，用节点存储数据
节点分类: 1.根节点(无前驱节点) 2.叶子节点(无子节点) 3.内部节点(有些教材把根节点归为内部节点)
父子关系和兄弟关系(一般理解为广义兄弟关系)
树：度/阶&amp;mdash;表示节点分了多少个叉
节点的度：该节点孩子节点的数目/分叉的数目 树的度：max(所有节点的度)，如果树的度为n，称为n叉树
树的高度和深度：在数值上一样(方向不一样，从上往下或从下往上) 结点的深度：注意方向即可
方便操作根节点，在之前增加一个空节点(与链表头节点类似) 方便操作叶子节点，在其之后增加一个空节点
存储结构:
存一棵树：1.节点数据 2.数据之间的关系&amp;ndash;父子
1.双亲(父亲)表示法：方便找父亲，不方便找孩子 1.顺序存储方式存数据：&amp;ndash;数组 2.在存数据的同时，把每个数据的父亲所在下标存一下
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class Node { public: T data;//存储数据 int fi;//father_i,fi == -1,认为是根节点 }; template&amp;lt;class T&amp;gt; class Tree { public: int size; Node&amp;lt;T&amp;gt;* pN;//指针开辟数组，存储节点 public: Tree(T k, int sz = 1) { //加入根节点 pN = new Node&amp;lt;T&amp;gt;[sz]; pN[0].data = k; pN[0].fi = -1; size = 1; } int Find(T fx) { for (int i = 0; i &amp;lt; size; i++) { if (pN[i].</description>
    </item>
    
    <item>
      <title>数据结构 队列</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 18 Nov 2023 11:14:33 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</guid>
      <description>学习完了线性结构的最后一个类型了，接下来似乎就是很难实现的分支结构了，一个红黑树似乎会有上千行代码的样子，不知道到时候要写多久。
实现了顺序队列，链式队列，循环队列，顺序双端队列，链式双端队列，同时对优先队列有了一定了解
代码实现如下：
顺序队列：
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class m_queue { public: m_queue(int n) { size = n; data = new T[size]; if (data == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } front = 0; rear = 0; //指向最后一个元素下一个位置 } void En_queue(T k) { //判满(牺牲一个位置) if (rear == size - 1) { cout &amp;lt;&amp;lt; &amp;quot;队满&amp;quot; &amp;lt;&amp;lt; endl; } else { data[rear] = k; cout &amp;lt;&amp;lt; k &amp;lt;&amp;lt; &amp;quot;入队&amp;quot; &amp;lt;&amp;lt; endl; rear++; } } void Del_queue() { int x(0);//记录出队元素 //判空 if (front == rear) { cout &amp;lt;&amp;lt; &amp;quot;队空&amp;quot; &amp;lt;&amp;lt; endl; } else { x = data[front]; cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;出队&amp;quot; &amp;lt;&amp;lt; endl; front++; } } void m_empty() { if (front == rear) { cout &amp;lt;&amp;lt; &amp;quot;队空&amp;quot; &amp;lt;&amp;lt; endl; } } void m_full() { if (rear == size) { cout &amp;lt;&amp;lt; &amp;quot;队满&amp;quot; &amp;lt;&amp;lt; endl; } } public: int size;//队列大小 T* data; int front; //队头指针 int rear; //队尾指针 }; int main() { m_queue&amp;lt;int&amp;gt; q(5); q.</description>
    </item>
    
    <item>
      <title>数据结构_栈</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</link>
      <pubDate>Tue, 14 Nov 2023 17:13:49 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</guid>
      <description>今天成功实现了栈，可能因为栈比较简单，没花太多时间，毕竟就是一种特殊的表，比上次链表好多了，这次写链栈快多了。
代码如下
顺序栈
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class m_stack { public: m_stack(int n) { size = n; data = new T[n]; if (data == nullptr) { cerr &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } top = -1;//初始化栈顶指针 } void m_push(T k) { if (this-&amp;gt;top == this-&amp;gt;size - 1) { cout &amp;lt;&amp;lt; &amp;quot;栈满&amp;quot; &amp;lt;&amp;lt; endl; } else { this-&amp;gt;top++; this-&amp;gt;data[top] = k; //若top初始值为0 /* *if(s.top == s.size) { } else { s.</description>
    </item>
    
    <item>
      <title>数据结构 双链表及循环链表</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 11 Nov 2023 18:15:45 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</guid>
      <description>学习过后成功实现了双链表与单向循环链表及双向循环链表，虽然改bug改了一天就是了。
本来以为双链表本身没什么问题，只要稍作修改就可以变为循环链表，但没考虑到nullptr在循环链表中不存在，导致改了好久，最后才意识到
代码如下
双链表
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;cassert&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class Node { public: T date; Node* next; Node* pre; }; template&amp;lt;class T&amp;gt; class LinkList { public: Node&amp;lt;T&amp;gt;* m_head; public: LinkList() { m_head = new Node&amp;lt;T&amp;gt;; if (m_head == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { m_head-&amp;gt;next = nullptr; m_head-&amp;gt;pre = nullptr; } } //查找函数 LinkList* Find(LinkList* head, T k) { Node&amp;lt;T&amp;gt;* pt = head-&amp;gt;m_head-&amp;gt;next; while (pt-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>数据结构 链表</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 08 Nov 2023 20:13:05 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</guid>
      <description>单链表：
1.节点（结点）：数据加指向下一个数据的地址（指向下一个数据的指针），组成了了一个节点 2.链表由若干节点组成 3.头指针：存储第一个节点的地址的指针，头指针可以标记一个链表
两个特殊节点： 1.首元节点：第一个存储真实数据的节点。（非空链表，一定有首元节点） 2.头节点：链表中第一个不存储真实数据的节点（头节点可有可无），如果头节点存在，那么头节点一定是链表的第一个节点
声明链表==声明节点
增强可读性，声明头指针 linklist l;
头节点作用： 1.当不带头节点时，对首元节点的操作需要涉及到头指针，非常特殊； 带头节点时，首元节点与其他节点无异 2.对空链表的操作：带头节点，空链表与非空链表均有节点，统一起来了
1.增： 不带头节点的链表：在首元节点前插入一个节点，需要改变头指针
初步代码实现如下： #define _CRT_SECURE_NO_WARNINGS
#include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class Node { public: T date; Node* next; }; template&amp;lt;class T&amp;gt; class LinkList { public: Node&amp;lt;T&amp;gt;* m_head; public: LinkList() { m_head = new Node&amp;lt;T&amp;gt;; if (m_head == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { m_head-&amp;gt;next = nullptr; } } //查找函数 LinkList* Find(LinkList* head, T k) { Node&amp;lt;T&amp;gt;* pt = head-&amp;gt;m_head-&amp;gt;next; while (pt-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>数据结构 顺序表</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</link>
      <pubDate>Tue, 07 Nov 2023 23:01:00 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</guid>
      <description>今天尝试实现顺序表，基本的增，删，查，插，改功能基本实现，但扩容时存在部分问题，只能部分扩容，原因尚未找出，等待后续优化（鬼晓得什么时候，也许明天）
2023.11.11 今天提交链表顺便修复一下之前的bug，扩容时忘了size++
代码如下（博客显示有点问题，不知道为什么，之后去修复一下）
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;stdexcept&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class ArrayList { public: ArrayList(int Num) :size(0) //初始化构造函数 { date = new T[Num]; if (date == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } length = Num; } void AddEle(T ele)//增添元素 { //判断是否超过最大容量 try { if (size &amp;lt;length) { date[size] = ele; size++; } else { throw runtime_error(&amp;quot;空间已满，是否扩容 Y/N&amp;quot;); } } catch (runtime_error err) { cout &amp;lt;&amp;lt; err.</description>
    </item>
    
  </channel>
</rss>
