<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机组成原理 on 清兵卫的博客</title>
    <link>https://qingbingwei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</link>
    <description>Recent content in 计算机组成原理 on 清兵卫的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 16 Sep 2024 00:11:57 +0800</lastBuildDate><atom:link href="https://qingbingwei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>逻辑设计基础</title>
      <link>https://qingbingwei.github.io/post/%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 16 Sep 2024 00:11:57 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>MIPS核心子集及实现方式</title>
      <link>https://qingbingwei.github.io/post/mips%E6%A0%B8%E5%BF%83%E5%AD%90%E9%9B%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 15 Sep 2024 23:18:58 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/mips%E6%A0%B8%E5%BF%83%E5%AD%90%E9%9B%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>冯·诺依曼架构的特点： 1.存储程序 2.二进制逻辑 3.五大基本部件 注：运算器也叫数据通路 4.指令和数据共享同一总线 5.指令顺序执行
数据通路(运算器)是计算机系统中负责执行指令并处理数据的部分。 它通常是由一系列硬件组件和逻辑电路组成，负责执行算术逻辑运算、数据传输以及存储等操作。 简单来说，数据通路是指令执行的“高速公路”，负责数据在计算机内部各个部件之间的传输和处理。主要组成部分包括：
1.寄存器：用于存储临时数据和指令的硬件存储单元。 寄存器通常与CPU紧密关联，用于暂存指令、操作数以及运算结果。 2.运算单元：执行算术逻辑运算的部件，包括加法器、减法器、乘法器、除法器等。 运算单元负责对数据进行各种数学运算和逻辑操作。 3.数据选择器/多路复用器：用于选择不同的数据源或目的地，并将数据传输到指定的位置。 它可以根据控制信号选择不同的输入，将选定的数据发送到指定的输出端口。 4.数据存储器：包括随机存储器（RAM）和只读存储器（ROM），用于存储程序指令、数据以及中间结果。 存储器在数据通路中扮演重要角色，负责存储和提取数据。 5.控制逻辑：负责根据指令序列产生控制信号，控制数据通路中各个部件的操作和数据流动。 控制逻辑根据指令的操作码和地址等信息，生成适当的控制信号来调度数据通路中的操作。 6.数据总线：用于在各个硬件组件之间传输数据和控制信号的物理通道。 数据总线可以分为地址总线、数据总线和控制总线，分别用于传输地址、数据和控制信号。 综合来看，数据通路是计算机系统中执行指令并处理数据的关键部分，它负责将指令和数据从存储器中提取出来，通过运算单元进行处理，并将结果存储回存储器中。数据通路的设计和优化直接影响了计算机系统的性能和效率。
MIPS的核心子集 1.加载/存储指令: (1)lw (Load Word):从内存中加载一个32位的字到寄存器中。 (2)sw (Store Word):将一个32位的字从寄存器存储到内存中。
1加载/存储指令是MIPS架构中访问内存的主要方式，它们允许CPU从内存读取数据或将数据写入内存。 2.算术逻辑指令: (1)add (Addition):执行两个操作数的加法操作，并将结果存储到目标寄存器中。 (2)sub (Subtraction):执行两个操作数的减法操作，并将结果存储到目标寄存器中。 (3)and(Bitwise AND):执行两个操作数的按位与操作，并将结果存储到目标寄存器中。 (4)or (Bitwise OR):执行两个操作数的按位或操作，并将结果存储到目标寄存器中。 (5)slt (Set on Less Than):如果第一个操作数小于第二个操作数，则设置目标寄存器为1，否则为0。 算术逻辑指令用于执行CPU内部的数据计算和操作。 3.分支指令: (1)beq (Branch if Equal):如果两个操作数相等，则跳转到指定的标签或地址处执行。 (2)j (Jump):无条件跳转到指定的地址处执行。 分支指令用于改变程序执行的流程，实现条件跳转或无条件跳转。 MIPS指令集的设计体现了简洁和规整的原则，这使得指令的执行过程相对统一，降低了实现的复杂性。 尽管每种类型的指令（存储访问、算术逻辑、分支）的具体操作细节不同，但它们的执行过程遵循类似的结构： 1.指令获取阶段:程序计数器(PC)指向内存中即将执行的指令地址，然后从内存中取出该指令。 2.寄存器读取阶段:根据指令格式，从寄存器文件中读取一个或两个操作数。 例如，加载/存储指令可能只需要一个寄存器(存放地址)，而算术逻辑指令通常需要两个操作数。 3.ALU处理阶段:所有非跳转指令通常都会利用算术逻辑单元(ALu)进行计算。 对于存储访问指令，ALU用来计算有效内存地址;对于算术逻辑指令，ALU执行加减乘除、逻辑运算等;对于分支指令，ALU基于比较结果生成新的PC值。 4.数据通路阶段: (1)存储访问指令︰根据ALU计算出的地址访问内存，进行数据读取或写入操作。 (2)算术逻辑指令∶将ALU计算结果写回寄存器文件，更新寄存器中的值, (3)分支指令∶根据ALU的比较结果决定是否跳转，若满足条件则修改PC值，使其指向新的目标地址;否则，按照顺序执行下一条指令，即PC增加4个字节(在MIPS中，指令通常是固定长度的，每个指令占4个字节)。 </description>
    </item>
    
    <item>
      <title>浮点数乘除法</title>
      <link>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B9%98%E9%99%A4%E6%B3%95/</link>
      <pubDate>Wed, 11 Sep 2024 21:10:44 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B9%98%E9%99%A4%E6%B3%95/</guid>
      <description>浮点数乘除运算步骤类似于浮点数加、减运算步骤,两者的主要区别是: 1.加、减运算需要对阶,而对乘、除运算来说,无须这一步。 2.两者对结果的后处理步骤也一样，都包括规格化、舍入和溢出判断处理。
浮点数乘除法运算总共就4步： 尾数运算、规格化、舍入、溢出判断。 1.尾数相乘，阶码相加
尾数的乘法运算定点原码小数乘法算法。 在运算时,需要将隐藏位1还原到尾数中,并注意乘积的小数点位置。 因为x和y是规格化浮点数,所以其尾数的真值形式都是正负1.b...b。 进行尾数相乘时,符号和数值部分分开运算,符号由x和y两数符号异或得到，数值部分将两个形为1.b..的定点无符号 数进行n位数乘法运算,其结果为2n位乘积:bb.b...b,小数点应该默认在第二位和第三位之间。 阶码执行移码相加：最终得到结果的移码表示的阶数。 [Ex]移 + [Ey]移 + 2^(n-1) + 1(mod 2^n) == [Ex + Ey]移 注:除法尾数相除，阶码相减 [Ex]移 + [-[Ey]移]补 + 2^(n-1) - 1(mod 2^n) == [Ex - Ey]移 2. 尾数规格化 在得到的2n位乘积数值部分bb.b...b中,小数点左边一定至少有一个1, 可能是01、10、11三种情况：若是01,则不需要规格化;若是10或11,则需要右规一次,此时，尾数右移一位,阶码加1。 规格化后得到的尾数数值部分的形式为01.b...b小数点左边的1就是隐藏位。 对于IEEE754浮点数的乘法运算不需要进行左规处理。 除法： 商的形式：b.b...b，小数点左边可能是0,可能是1。 对于IEEE754浮点数的除法运算不需要进行右规处理。 3.尾数舍入 同加减法的舍入 4.溢出判断 在进行指数相加、右规和舍入时,要对指数进行溢出判断。右规和舍入时的溢出判断与 浮点数加减运算中的溢出判断方法相同。 而在进行指数相加时的溢出判断则要根据参与运算的操作数及结果的阶码的最高位的取值情况进行。 1.[Eb]移 全1-----&amp;gt;上溢 [Ex]移 [Ey]移 最高位是0，但是[Eb]移最高位是1-------&amp;gt;上溢 2.[Eb]移 全0-----&amp;gt;下溢 [Ex]移 [Ey]移 最高位是1，但是[Eb]移最高位是0-------&amp;gt;下溢 注:相加 除法: 左规时的溢出判断与浮点数加减运算中的溢出判断方法相同。 而在进行指数相加时的溢出判断则要根据参与运算的操作数及结果的阶码的最高位的取值情况进行。 1.[Eb]移 全1-----&amp;gt;上溢 [Ex]移 最高位0 [Ey]移 [Eb]移最高位是1------&amp;gt;上溢 2.</description>
    </item>
    
    <item>
      <title>浮点数加减法</title>
      <link>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/</link>
      <pubDate>Wed, 11 Sep 2024 21:10:38 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/</guid>
      <description>阶数不一样，要把阶数调整为相同（往大的调整）之后再相加。 结果的尾数为两个尾数之和，阶数为调整之后的阶数。
浮点数加减法运算总共就5步： 对阶、尾数运算、规格化、舍入、溢出判断。
1.对阶：使x和y的阶码相等,以使尾数可以相加减。 原则:小阶向大阶看齐,阶小的那个数的尾数右移(算术右移),右移的位数等于两个阶(指数)的差的绝对值。 大多数机器采用IEEE754标准来表示浮点数，阶数为移码表示因此,对阶时需要进行移码减法运算，并且尾数右移时按原码小数方式右移,符号位不参加移位,数值位要将隐含的一位1右移到小数部分,空出位补0。 为了保证运算的精度,尾数右移时，低位移出的位不要丢掉,应保留并参加尾数部分的运算。 注:[Ex]移 - [Ey]移 = [Ex - Ey]补 tips:自己手算时直接用真值算即可 2.尾数加减： 对阶后两个浮点数的指数相等，可以进行对阶后的尾数相加减。 因为IEEE754采用定点原码小数表示尾数，所以,尾数加减实际上是定点原码小数的加减运算（与定点加减法一样）。 因为IEEE754浮点数尾数中有一个隐藏位，所以,在进行尾数加减时,必须把隐藏位还原到尾数部分。 运算过程中,在尾数右移时保留的附加位也要参加运算。 因此,在用定点原码小数进行尾数加减运算时,在操作数的高位部分和低位部分都需要进行相应的调整。 进行加减运算后的尾数不一定是规格化的,因此,浮点数的加、减运算需要进一步进行规格化处理。 3.尾数规格化：左规 右规 保证最高有效位为1 右规：尾数右移一位,阶码加1。尾数右移时,最高位1被移到小数点前一位作为隐藏位,最后一位移出时,要考虑舍入。 左规：数值位逐次左移,阶码逐次减1,直到将第一位1(隐藏位)移到小数点左边。 4.尾数的舍入处理：在对阶和尾数右规时,可能会对尾数进行右移,为保证运算精度,一般将低位移出的位保留下来,参加中间过程的运算,最后再将运算结果进行舍入,还原表示成IEEE 754格式。 （1）保留多少附加位才能保证运算的精度? IEEE754标准规定,所有浮点数运算的中间结果右边都必须至少额外保留两位附加位。 这两位附加位中,紧跟在浮点数尾数右边那一位为保护位或警戒位(guard) ,用以保护尾数右移的位;紧跟保护位右边的是舍入位(round) ,左规时可以根据其值进行舍入。 在IEEE 754标准中,为了更进一步提高计算精度,在保护位和舍入位后面还引入了额外的一个数位,称为粘位(sticky),只要舍入位的右边有任何非0数字,粘位就被置1;否则,粘位被置0。 （2）IEEE754标准的舍入方法： a.0舍1入。 b.朝+∞方向舍入。总是取右边最近可表示数,也称为正向舍入或朝上舍入。 c.朝-∞方向舍入。总是取左边最近可表示数,也称为负向舍入或朝下舍入。 d.朝0方向舍入。直接截取所需位数,丢弃后面所有位，也称为截取、截断或恒舍法。 这种舍入处理最简单。对正数或负数来说，都是取更靠近原点的那个可表示数,是趋向原点的舍入,因此,又称为趋向零舍入。 5.溢出判断 在进行尾数规格化和尾数舍入时,可能会对结果的阶码执行加、减运算。 因此,必须考虑结果的指数溢出问题： (1)若一个正指数超过了最大允许值(127或1023),则发生指数上溢，机器产生异常,也有的机器把结果置为+∞(数符为0时)或-∞(数符为1时)后,继续执行下去。 (2)若一个负指数超过了最小允许值(-149或-1074),则发生指数下溢,此时,一般把结果置为+0(数符为0时)或-0(数符为1时),也有的机器引起异常。 溢出判断实际上是在上述尾数规格化和尾数舍入过程中进行的，只要涉及阶码求和/差，就可以在阶码运算部件中直接用溢出判断电路来实现。涉及阶码求和/差的情况有以下情况： (1)右规和尾数舍入。一个数值很大的尾数舍入时,可能因为末尾加1而发生尾数溢出,此时,可以通过右规来调整尾数和阶。 右规时阶加1,导致阶增大，因此需要判断是否发生了指数上溢。只有当调整前的阶码为1111110,加1后,才会变成1111111而发生上溢;如果右规前阶码已经是1111111,则右规后变为0000000,因而会造成判断出错。 所以,右规前应先判断阶码是否为全1,若是,则不需右规,直接置结果为指数上溢;否则，阶码加1,然后判断阶码是否为全1来确定是否指数上溢。 (2)左规。左规时数值位逐次左移,阶码逐次减1,所以左规使阶码减小,故需判断是否发生指数下溢。 其判断规则与指数上溢类似,首先判断阶码是否为全0,若是,则直接置结果为指数下溢;否则,阶码减1,然后判断阶码是否为全0来确定是否指数下溢。 从浮点数加、减运算过程可以看出,浮点数的溢出并不以尾数溢出来判断，尾数溢出可以通过右规操作得到纠正。 运算结果是否溢出主要看结果的指数是否发生了上溢,因此是由指数上溢来判断的。 </description>
    </item>
    
    <item>
      <title>浮点数表示</title>
      <link>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Mon, 09 Sep 2024 20:21:39 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</guid>
      <description>在二进制系统中，科学计数法通常被称为浮点表示法，并且是计算机科学中用于存储和计算实数的标准方法。
这种表示方式同样由两部分构成：
1.尾数： 在二进制科学计数法中，尾数通常是小数形式的二进制数，并且在标准化的情况下，它总是从 1.xxxxxx开始，这里的每个 x是0或1。 2.指数： 指数是一个以某个基数（通常为2）为底的整数，表示基数的小数点相对于固定点的位置偏移了多少位。 在计算机中任意一个二进制实数表示： X = (-1)^S * M * R^E 其中： S : sign，取值0或1，确定符号。 R ：radix，基数/进制。二进制下为2。 M ：mantissa，尾数。是一个二进制定点小数（0.1b&amp;hellip;bbb），其位数反映了X的有效位数，决定了精度。 E ：exponent， 阶/指数。是一个二进制定点整数，其位数决定X的表示范围，其值确定小数点的位置。
存储时存储 S M E三个字段即可，其中阶码E常用补码或移码表示，尾数M常用原码或补码表示。 移码 注:常用来表示浮点数的阶码。 移码就是在真值X上加上一个常数(偏置值)，通常这个常数取2^n，相当于X在数轴上向正方向偏移了若干单位，这就是“移码”一词的由来。
n+1位移码的特点： 1.零的表示唯一：[+0]移=2n+0=100...00 [-0]移=2n-0=100...00 (n个0) 2.一个真值的移码和补码仅差一个符号位，所以[x]补的符号位取反得到[x]移 所以在 原 反 补码中“ 0正1负” ；移码中 “0负1正”。-----&amp;gt;注:前提是偏置值取2^n 3.移码全0时，对应真值的最小值-2^n;移码全1时，对应真值的最大值2^n-1。-----&amp;gt;注:前提是偏置值取2^n 4.移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。 IEEE 754标准 IEEE 754标准规定了四种表示浮点数值的方式： 单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。 其中，只有32位模式有强制要求，其他都是选择性的。
32位 单精度格式 单精度格式中包含1位符号s、8位阶码e和23位尾数f 尾数用原码表示。阶码用移码表示。 尾数： 对于规格化的二进制浮点数，尾数的最高位总是1,为了能使尾数多表示一位有效位，将这个1隐藏，称为隐藏位，因此23位尾数实际表示了24位有效数字。 IEEE 754规定隐藏位1的位置在小数点之前，即1.xxx...xxx的尾数形式。 例如，(12)10= (1100)2,将它规格化后结果为1.1x2^3,其中整数部分的“1”将不存储在23位尾数内。 阶码： 阶码用移码表示，偏置值为2^(n-1)-1。因此，单精度和双精度浮点数的偏置常数分别为127和1023。一些特殊的位序列(如阶码为全0或全1)有其特别的解释。 以IEEE 754标准中的单精度浮点数为例，其阶码部分有8位，能够表示的范围通常是-127到128，但是实际可用的范围是从-126到127，因为全0和全1的指数值有特殊的含义。 IEEE 754中对数进行了以下分类： 1.</description>
    </item>
    
    <item>
      <title>定点数除法</title>
      <link>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95/</link>
      <pubDate>Thu, 05 Sep 2024 17:49:27 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95/</guid>
      <description>m位数 / n位数 = (m - n + 1)位数&amp;mdash;-&amp;gt;最多位数 注:(m&amp;gt;=n)
二进制除法的运算，本质上相当于看最多几个除数累加能逼近于被除数。 （加上余数后就等于被除数）。
定点数除法(均使用试商法，即恢复余数法，但计算机实际使用不恢复余数法) 1.无符号数除法 无符号数除法运算用减法和移位运算来实现
(1)先对除数末尾补零到与被除数位数对齐（通过左移实现），左移一位代表乘2，右移一位代表除2； (2)判断大小，确定该位商1还是商0。 计算机不可能提前知道除数是否小于被除数。 先让被除数减去除数，若结果为&amp;gt;=0，说明被除数&amp;gt;=除数，直接商1。 若结果为负数，说明被除数&amp;lt;除数，说明不能减，则先恢复被除数的原值，再商0。 比如32（n）位的除法：被除数64(2n)位，除数32(n)位。 先把除数左移32位，然后开始同十进制类似计算。 因为二进制只有0和1所以退化为减法，先减去被除数，如果结果为负，则当前位商置为0，再加回来， 如果结果为正，则当前位商为1，除数右移一位，继续如上做减法。 循环n+1次，商的位数满足为止。 2.有符号数除法 (1)原码表示(符号位与数值位分开求) 1.符号位:被除数和除数的符号位“异或”运算得到 2.数值位:被除数和除数的数值位执行 “无符号除法” 注:余数符号位与被除数符号位相同 (2)补码表示(符号位参与运算) 1.符号位参与运算，除数和被除数，余数和商(异号相除较特殊)均用补码表示。 2.其他过程与无符号除法一致，区别在于判断是否可以减时，不能直接相减看结果的符号位，要按分情况来看。 注:如果同号相除得商；异号相除，将商的负数求补(带符号位) </description>
    </item>
    
    <item>
      <title>定点数乘法</title>
      <link>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95/</link>
      <pubDate>Wed, 04 Sep 2024 16:52:07 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95/</guid>
      <description>m位数 * n位数 = (m + n - 1)位数&amp;mdash;-&amp;gt;最少位数 m位数 * n位数 = (m + n)位数&amp;mdash;-&amp;gt;最多位数
定点数乘法 1.无符号数乘法 无符号数乘法运算用加法和移位运算来实现 2.有符号数乘法 (1)原码表示(符号位与数值位分开求) 1.乘积的符号位由两个乘数的符号位进行“异或”运算得到 2.乘积的数值位为两个乘数的绝对值之积，即执行无符号数乘法 注:在硬件实现中，乘法运算用加法和移位运算来实现
假设我们实现4位 X 4位 = 8位的乘法器，那么： （1）需要一个8位的移位寄存器保存被乘数，他有一个左移的信号输入。 （2）需要一个8位的乘积寄存器，用来保存运算的结果。 （3）移位寄存器和乘积寄存器需要进行加法运算，所以需要一个8位的加法器，相加之后存放到乘积寄存器中。 （4）需要一个4位的乘数寄存器，同时将乘数寄存器的最低位连接右移信号，右移信号除了控制移位寄存器移位，还要控制是否进行加法运算和是否允许乘积寄存器保存当前的结果。 最后还需要控制自身是否右移位。 (2)补码表示(符号位参与运算) 在有符号数的补码乘法运算中，我们需要将被乘数和乘数先转化为补码进行乘法运算。 注:运算过程中的所有数据均以补码形式呈现。 符号位也参加运算，在运算过程中要考虑符号位乘上被乘数之后的部分积是正数还是负数。 注:位数不足时用最高位(即符号位)补齐位数 注:乘数符号位为1时，计算时将符号位看作-1与被乘数进行计算，得到被乘数相反数的补码 以上是手动计算补码乘法的过程。 计算机一般采用Booth算法（补码一位乘法）进行补码乘法运算，采用相加和相减操作计算补码数据的乘积。 </description>
    </item>
    
    <item>
      <title>定点数加减法</title>
      <link>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/</link>
      <pubDate>Mon, 02 Sep 2024 18:35:49 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/</guid>
      <description>定点数：是一种表示固定小数位数的数值类型，通常表示为一个有符号的整数部分和一个小数部分。
定点小数：如果是有符号数，约定小数点在符号位的后面，如果是无符号数，约定小数点在最前边。 定点小数的是类似：0.XXXXXX这个形式 定点整数：约定小数点在最后边。 定点整数是类似：XXXXXX.0这种形式 浮点数：相当于生活中的科学计数法，小数点的位置是可以不断变化的；且小数点位置的变化，不会影响表达式整体数值的大小。 IEEE 754是由IEEE制定的有关浮点数的工业标准，被广泛采用。
在计算机中,通常是用定点数来表示整数和纯小数,分别称为定点整数和定点小数。 对于既有整数部分、又有小数部分的数，一般用浮点数表示。
定点数加减法 1.无符号数 逢二进一 2.有符号数 (1)原码表示 注:符号位不参与运算 加法运算:同号相加，符号位不变，数值位相加。 减法运算:先判断两个数大小确定结果的符号，绝对值大的减去绝对值小的。 (2)补码表示 注:符号位参与运算 加法运算:补码直接相加 减法运算:被减数的补码+减数相反数的补码
技巧:把X补码(带符号位)取反+1 ----&amp;gt; -X补码 技巧:将X原码最右侧一个1前面一直到符号位(不含符号位)直接取反----&amp;gt;X补码 注:在计算机中，有符号数一般采用补码表示。重点关注补码运算。 /*********************************************************** */
加法是一种基本且频繁使用的操作。现代计算机在硬件层面上实现加法操作，通常是通过加法器电路来完成的。 加法器会接收两个二进制数作为输入，然后按照二进制加法规则进行逐位相加，同时处理可能出现的进位。
减法，虽然其基本原理与手动计算中的减法相似，但在计算机内部实现时，通常会转换为加法来执行。 这是因为计算机内部的电路更擅长执行加法操作，而减法操作可以通过取反和加法的组合来实现。
虽然从原理上看，补码减法是通过取反和加法实现的，但在实际的计算机硬件中，这个过程通常是自动且高效地完成的，无需程序员显式地进行取反和加法的操作。 程序员在编写代码时，只需要使用减法运算符（如“-”），然后计算机硬件和操作系统会自动处理底层的细节。
/*********************************************************** */
一般情况下,用一个专门的算术逻辑部件(ALU)来完成基本逻辑运算和定点数加减运算, 各类定点乘除运算和浮点数运算则可利用加法器或 ALU 和移位器来实现。 ALU 的核心部件是加法器。 注:ALU在CPU中
算术逻辑单元（Arithmetic Logic Unit，简称ALU）是计算机处理器内部的一个核心组件，负责执行基本的算术和逻辑运算。 它是一个能够处理二进制数据并进行快速计算的硬件电路块。 在功能上，ALU主要包括以下几个方面： 1.算术运算 2.逻辑运算 3.比较运算 4.移位运算 5.其他复合运算
加法器是计算机中的一种数位(字)电路，用于执行数字的加法计算。 在电子学中，加法器常用于各种数值的表示和计算，特别是在二进制运算中。 在计算机和一些处理器中，加法器被运用于算术逻辑单元ALU中，或者处理器的其他部分，如计算地址、执行加减操作等类似功能。 因此，加法器是算术逻辑单元(ALU)中的一个重要部件。
/************************************************************* */
补码定点数加减溢出： 正数+正数=负数&amp;mdash;-&amp;gt;正溢出 负数+负数=正数&amp;mdash;-&amp;gt;负溢出
溢出检测方法：
1.和的符号位与两个加数的符号位不同
X+Y=Z
Xs Ys Zs(符号位) 0 0 1&amp;mdash;&amp;gt;溢出 1 1 0&amp;mdash;&amp;gt;溢出 V=1 溢出 V=0 不溢出</description>
    </item>
    
    <item>
      <title>32位立即数与寻址</title>
      <link>https://qingbingwei.github.io/post/32%E4%BD%8D%E7%AB%8B%E5%8D%B3%E6%95%B0%E4%B8%8E%E5%AF%BB%E5%9D%80/</link>
      <pubDate>Sat, 24 Aug 2024 20:52:50 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/32%E4%BD%8D%E7%AB%8B%E5%8D%B3%E6%95%B0%E4%B8%8E%E5%AF%BB%E5%9D%80/</guid>
      <description>在MIPS架构中，许多包含立即数字段的指令格式只预留了16位的空间来存放立即数。那如果使用32位的立即数该怎么办呢？
这时就需要采用特殊的编码方式来加载或存储32位的常数值以及使用完整的32位地址，需要采用两条指令来实现：
1.lui（Load Upper Immediate）：将最高16位的立即数载入到目标寄存器的高16位，同时低16位清零。 2.ori（OR Immediate）或addi（Add Immediate）：将剩余的低16位立即数与前一步得到的结果进行逻辑或（ ori ）操作，或者加法（ addi ，如果目标寄存器之前已包含有效数据且希望累加的话），从而合成出完整的32位立即数。 例如，假设我们要将32位立即数0x12345678加载到寄存器t0中，我们需要这样操作：
lui $t0, 0x1234 #将高16位Ox1234载入$t0，低16位清零 ori $t0, $t0, 0x5678 #将低16位0x5678与$t0进行逻辑或操作 寻址方式 地址: 1.形式地址(A):通过A加以转化得到EA 2.有效地址(EA):真实地址
地址种类: 1.寄存器编号 2.内存地址 3.I/O端口 寻址方式:是寻找指令或者操作数的有效地址的方式 1.指令寻址:去寻找下一条指令的地址 PC:程序计数器 存放当前欲执行指令的地址，并且具有自动+1功能 (1)顺序寻址:直接通过PC+1(一条指令的长度)，自动形成下一条指令的地址 (2)跳跃寻址:转移类指令实现 i.J 型指令格式的跳转指令 J型指令是一种专门用于无条件跳转（Jump）的指令格式。在MIPS指令集中，J型指令的具体格式如下： 6位操作码：用于指示这是一个J型跳转指令。 26位地址字段：用于存储相对于当前PC（程序计数器）的偏移量。 注:J型指令的寻址方式主要是变通的直接寻址（伪直接寻址）： 跳转地址由指 26 位字段和 PC 高4位相连而成,最低两位补0（指令地址必定为四的倍数） ii.I 型指令格式的条件分支指令 与无条件跳转指令不同，条件分支指令在跳转到目标地址之前会先比较两个操作数的值。 如果满足比较条件，则执行跳转；否则，继续顺序执行下一条指令。具体来说： 1.两个操作数：这些操作数通常是从寄存器中获取的值，例如 rs （源寄存器1）和 rt （源寄存器2），用于比较它们之间的关系。 2.条件判断：不同的条件分支指令对应着不同的条件判断，如beq检查两者是否相等，bne检查两者是否不相等，blt则检查第一个操作数是否小于第二个操作数。 3.分支地址：如果满足特定条件，则程序计数器PC会被更新为指令中指定的目标地址，从而实现有条件地转移到新的指令序列继续执行。 注:条件分支指令的寻址方式是------&amp;gt;PC相对寻址 PC相对寻址（PC-Relative Addressing）是一种指令寻址方式，它使用当前程序计数器（ProgramCounter, PC）的值加上一个相对于当前指令地址的偏移量来确定下一条要执行的指令或数据的位置。 具体来说，在PC相对寻址中，指令包含了一个表示偏移量的字段。当CPU执行到含有PC相对寻址的跳转指令时，它会将当前PC值与该偏移量相加，得到的目标地址就是跳转的目的地。 这种方式使得程序员可以编写出与加载地址无关的代码，增强了程序的可移植性，并且简化了硬件设计，因为不需要复杂的计算逻辑去生成绝对地址。 优点：简洁性和可预测性。 缺点：限制了分支目标的范围，因为偏移量的大小是有限的。不利于代码的重定位和共享。 注:寻址附近的指令也是加速大概率事件的另外一个例子 。 2.数据寻址:去寻找本条指令的操作数的有效地址 (1)立即(数)寻址 操作数直接包含在指令中，作为指令的一部分。这种情况下，操作数的值是一个立即数，即固定值。 立即寻址模式通常用于加载立即数到寄存器中，或者用于算术和逻辑运算。 MIPS 指令集并没有像某些其他指令集那样直接支持“MOV”指令，但可以通过其他方式实现寄存器到寄存器的数据移动。 优点:速度快，不需要访问内存 缺点:位数有限，立即数大小有限 (2)直接寻址(EA == A) 指令中包含一个实际的内存地址，这个地址直接指向内存中的一个位置，从中读取或写入操作数，CPU直接使用这个地址从内存中读取操作数。 在 MIPS 指令集中，直接寻址模式通常用于访问内存中的特定地址。在直接寻址中，指令中直接包含了要访问的内存地址。 直接寻址在 MIPS 指令集中是一种简单而直接的方式来访问内存中的特定位置。 然而，由于其限制和可能的性能影响，它通常只在需要直接访问特定内存地址时使用。所以其实并不常用。 优点:简单 缺点:限制了寻址范围 (3)寄存器寻址 操作数存储在某个寄存器中。指令中通常包含一个寄存器标识符，处理器从该寄存器中读取或写入操作数。 寄存器寻址通常比内存寻址更快，因为寄存器位于 CPU 内部，访问它们不需要像访问内存那样经过复杂的内存子系统。 MIPS 指令集中的寄存器寻址非常灵活，因为大多数指令都可以接受来自寄存器或立即数的操作数。 寄存器寻址不仅限于算术和逻辑运算，还可以用于数据移动、比较、跳转等操作。 寄存器寻址是 MIPS 指令集中非常基础和重要的寻址模式，它允许 CPU 快速、高效地处理数据，而不需要频繁地访问内存。 优点：快速，不需要访问内存；简单 缺点：寄存器个数有限，造价昂贵 (4)间接寻址( EA == (A) ) 指令中给出的地址码是存放操作数有效地址的主存单元地址。 优点:扩大了寻址范围 缺点:慢，多次访问内存 寄存器间接寻址：通过寄存器间接寻址实现。 这意味着指令的操作数地址不是直接给出的，而是存储在一个寄存器中，处理器会访问该寄存器内容所指向的内存地址来获取实际操作数 (5)变址寻址 以某个寄存器的内容为偏移量，加上指令中给出的基地址来计算操作数的实际地址。 这种寻址模式在处理数组或循环时特别有用，因为它允许程序在不需要修改基址寄存器的情况下，通过改变偏移量来访问内存中的不同位置。 变址寄存器:变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变(作为偏移(量)，形式地址A不变(作为基地址))。 优点:扩大了寻址范围 缺点:必须使用一个寄存器存储偏移量 (6)基址寻址 类似于变址寻址，但这里的基准是固定的基址寄存器，加上一个偏移量得到操作数地址。 有效地址是通过将基址寄存器的内容与指令中给出的偏移量相加而得到的。基址寄存器的内容在程序执行过程中通常保持不变，而偏移量可以变化。 这种寻址模式常用于未多道程序分配存储空间 例.</description>
    </item>
    
    <item>
      <title>指令格式</title>
      <link>https://qingbingwei.github.io/post/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Wed, 21 Aug 2024 14:18:01 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F/</guid>
      <description>指令：由一系列的二进制位（bits）组成的，这些位可以表示不同的操作、操作数地址、跳转目标等。
在 MIPS 架构中，指令的编码是精心设计的，以便 CPU 能够解码并执行相应的操作。 每个指令通常都包含操作码（opcode，用于标识指令的类型）、源操作数、目标操作数等部分。
指令有自己的布局格式，叫做指令格式。指令的格式或布局定义了指令在计算机内存中的表示方式。
对于MIPS架构，每条指令都是32位长，这与MIPS体系结构中数据字的位数相一致。 这种固定长度的指令格式简化了指令的解码和执行过程，因为CPU不需要在读取指令时确定指令的长度。
在计算机科学中，我们通常将这种直接表示为二进制形式的指令称为机器语言或机器码。
字:计算机一次能处理的一个数据，一个字由若干个字节组成 (机器）字长∶字的长度（位数)，等于CPU内部用于整数运算的运算器的位数或者是寄存器的位数
指令字长:一条指令中所包含的二进制位数,一条指令的长度 存储字长:一个存储单元的二进制的位数
指令字长=n*存储字长
/*****************************/
以加法为例：add $t0, $s1, $s2&amp;mdash;&amp;ndash;&amp;gt;机器码是？
该指令包含了一个操作码和三个寄存器。
关于寄存器，这些寄存器在汇编语言中有特定的名称，如 $s0 、 $s1 、 $t0 、 $t1 等。在底层，这些寄存器的名字会被映射成数字，以便硬件能够识别和操作。
例如： 寄存器 $s0 ~ $s7 在 MIPS 中映射到数字 16 ~ 23。 寄存器 $t0 ~ $t7 映射到数字 8 ~ 15。
这种映射关系使得汇编语言编写的程序能够在底层被正确地转换成机器码，并由硬件执行。当汇编 器或编译器处理源代码时，它会将这些寄存器名称转换为相应的数字，以生成正确的机器码。
这种映射关系的设计允许指令集保持简洁和一致，同时使得硬件实现更加高效。
由于MIPS指令是固定长度的32位格式，操作码和其他字段的位置是固定的。
1.opcode(ADD指令的操作码)高六位为0x0，低六位为0x20 2.rs(源寄存器1)对应于s1，在MIPS中s1的编号是17(s0-s7对应16-23)，所以这里的rs部分应为10001 3.rt(源寄存器2)对应于s2，在MIPS中s2的编号是18，所以这里的rt部分应为10010 4.rd(目标奇存器)对应于t0，在MIPS*中t0的编号是8( tO-t7对应8-15)，所以这里的rd部分应为1000由于限定为5位所以是01000
基于上述指令格式， add $t0, $s1, $s2 指令可以翻译成：
完整的32位机器码:000000 10001 10010 01000 00000 100000</description>
    </item>
    
    <item>
      <title>逻辑运算与字符表示</title>
      <link>https://qingbingwei.github.io/post/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Sat, 17 Aug 2024 16:47:13 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/</guid>
      <description>逻辑运算
位运算:位操作是对整数或其他二进制表示的数据的每个位进行单独操作。 虽然早期的计算机仅对整字进行操作，但人们很快就发现，对字中由若干位组成的字段甚至对单个位进行操作是很有用的，如: 1.位级操作:在计算机硬件和软件层面支持对一个字中的单个或一组位进行操作，这对于实现诸如错误检测(如奇偶校验、CRC校验)、数据压缩、编码解码(如ASCII到EBCDIC转换)、权限控制(如访问控制位)以及硬件接口信号处理等任务至关重要。 2.布尔逻辑:逻辑门电路的设计和数字逻辑的应用也要求能够对位进行AND、OR、NOT等逻辑操作，这在计算机内部的控制电路中是基础性的工作。 3.打包和拆包:在通信协议、数据格式化等领域，经常需要将多个小的数据元素（比如单个字符或标志位）组合成一个较大的字，或者从一个字中提取特定的位字段，这些操作都依赖于位级操作指令。 因此，现代计算机的指令集架构中通常包含了丰富的位操作指令，允许程序员直接对数据的各个位进行操作，极大地增强了程序设计的灵活性和效率。 按位与（AND）：同1为1 作用： x &amp;amp; 1 = x x &amp;amp; 0 = 0 1.保留某些位 2.清除某些位 3.检查标志位 4.网络地址和子网掩码计算 5.硬件接口控制 6.数据有效性校验 按位或（OR）：有1为1 作用： x | 0 = x x | 1 = 1 1.设置标志位 2.合并数据 3.条件赋值 4.硬件接口控制 按位异或（XOR）：不同为1 注: 1.满足交换律：a^b = b^a 2.满足结合律：(a^b)^c = a^(b^c) 3.自反性：a^a = 0 a^0 = a 作用： 1.不改变原始数据进行翻转特定位 2.交换两个变量的值（无需临时变量） x=x^y y=x^y x=x^y 3.计算奇偶校验位 非/取反（NOT）：单个操作数的每位取反，0变为1，1变为0。 作用： 1.反转二进制位 2.计算数值的补码形式 对一个正数执行按位非操作会得到一个负数，这个负数的补码是对其绝对值的原码按位取反后再加1； 反之，对一个负数执行按位非操作，则大致上可以得到该负数加1之后对应的正数（但不是绝对准确，因为溢出问题可能导致不一致）。 3.创建掩码 4.判断奇偶性 左移（Left Shift）：将一个数的所有位向左移动指定次数，空出的低位补零。 作用： 1.</description>
    </item>
    
    <item>
      <title>有符号数和无符号数</title>
      <link>https://qingbingwei.github.io/post/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</link>
      <pubDate>Sun, 21 Apr 2024 17:43:10 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</guid>
      <description>信息的最小单位是比特（bit），它只能表示两种状态：0 或 1。 1.简洁性 2.直接与硬件映射 3.易于扩展 4.内存效率
多个比特被组合在一起形成字节（byte），通常一个字节由8个比特组成。 1B=8b 多个字节组成一个字。
最低有效位 表示最右边的一位，最高有效位 表示最左边的一位。 MIPS 的字有 32 位 ，如果要存储1011。那就是： 0000 0000 0000 0000 0000 0000 0000 1011（高位补0）
计算机硬件设计使得其能够高效地执行基于二进制的加法、减法、乘法、除法以及其他逻辑操作，所有这些都直接对应于底层电路中的电子信号的变化。这些基础操作构成了现代计算机计算能力的核心。
整数进制转换 二进制：1111011 十进制：123
二进制转换为十进制：逐位乘以2的幂次方求和。 十进制转换为二进制：除2取余法 计算机硬件设计使得其能够高效地执行基于二进制的加法、减法、乘法、除法以及其他逻辑操作，所有这些都直接对应于底层电路中的电子信号的变化。这些基础操作构成了现代计算机计算能力的核心。 为了表示正数和负数，计算机程序使用了一种称为“符号和幅值”（sign and magnitude）的表示法，即原码： 高位（通常是第一位或最左边的位）用作符号位，0表示正数，1表示负数。其余位表示数值的幅值（即绝对值）。
例如：占8位的二进制数： 9D： 0000 1001B -9D：1000 1001B
固定位数（n+1位）的原码范围：
[-(2n-1), (2n-1)]
0的原码表示有两种：0000 0000 和 1000 0000
当运算的结果超出了该数据类型能够表示的范围时，就会发生溢出。（计算机内部一般用补码存储数据，稍后讨论）
原码加减法：与十进制一样，考虑进位和借位。
注：在原码加减运算中，对于两个不同符号数的加法(或同符号数的减法)，先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要为结果选择合适的符号。
原码表示法的优点： 原码表示的优点是，与真值的对应关系直观、方便,因此与真值的转换简单,并且用原码 实现乘除运算比较简便。
原码表示法的缺点： 0的表示不唯一,给使用带来不便；加减运算比较复杂，要考虑溢出、负借位等等问题
为了简化硬件设计并解决这些问题，现代计算机更倾向于使用二进制补码（two&amp;rsquo;s complement）的方式来表示有符号整数。 二进制补码不仅解决了正负数的区分问题，还使得加减运算能够通过相同的硬件电路实现，同时有效地处理了溢出情况，并消除了正负零的问题。
补码的定义:具有一位符号位和n-1数字位的二进制整数x来说 其补码是: [x]补 = 2^n + x(mod 2^n) -2^(n - 1)&amp;lt;= x &amp;lt; 2^(n - 1)</description>
    </item>
    
    <item>
      <title>计算机硬件操作及操作数</title>
      <link>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%93%8D%E4%BD%9C%E6%95%B0/</link>
      <pubDate>Sun, 21 Apr 2024 17:42:57 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%93%8D%E4%BD%9C%E6%95%B0/</guid>
      <description>机器指令(简称指令)：指示计算机执行某种操作的命令，计算机语言中的基本单词。
一台计算机的所有指令的集合构成该机的指令系统，也称指令集。 分类: 1.复杂指令集系统 2.精简指令集系统
指令集的两种形式： 一种是人们编程书写的形式（汇编语言-助记符），另一种是计算机所能识别的形式（机器语言-二进制元）。
指令集有很多种：MIPS(精简指令集系统)；Intel x86；ARM系统：ARMv7,ARMv8;RISC-V&amp;hellip;&amp;hellip;
存储程序：必须将事先编好的程序和原始数据送入主存后才能执行程序,一旦程序被启动执行,计算机能在不需操作人员干预下自动完成逐条取出指令并执行的任务。
注:存储程序是1945年 冯. 诺伊曼提出的，“存储程序(stored-program)通用电子计算机方案”,宣告了现代计算机结构思想的诞生。 硬件设计的三条基本原则：
1.简单源于规整：这意味着设计应该尽可能地简单，以便于理解和维护。这通常通过保持设计的规整性来实现，例如通过保持指令长度的统一，可以简化处理器的设计和编程。 2.越小越快：在硬件设计中，减小组件的尺寸可以提高其运行速度。这是因为当信号传输的距离变短时，传输时间也会减少，从而提高了整体性能。 3.优秀的设计需要折中的方案：在实际的硬件设计中，往往需要在不同的设计要求之间做出权衡。例如，为了提高性能，可能需要增加功耗或牺牲一部分能效。因此，设计师需要找到一个能够满足所有关键要求的最佳折中方案。 任何计算机必须能够执行算术运算
加法为例，MIPS 汇编语言的下述记法： add a . b. c 表示将两个变量 b和c相加，并将它们的和放入变量a中。 这种表达的方式是固定的，每一条指令只用来执行一个操作。 与加法类似的指令一般都有三个操作数：两个进行运算的数和一个保存结果的数。要求每条指令有且仅有三个操作数。体现了：简单源于规整。 操作数：与高级语言程序不同， MIPS 算术运算指令的操作数是很严格的，它们必须来自寄存器。 寄存器：由硬件直接构建且数量有限，是计算机硬件设计的基本元素。MIPS 体系结构中寄存器大小为 32 位，称其为字。 字：计算机中的基本访问单位，通常是 32 位为一组，在 MIPS 体系结构中与寄存器大小相同。MIPS按字节编址，一个字对应4个字节。 寄存器的数量是有限的。越小越快。大量的寄存器可能会使时钟周期变长，因为电信号传输更远的距离必然花费更长的时间。对于这32个寄存器，我们用0~~31来表示。尽管可以简单使用序号0~31 表示相应的寄存器，但MIPS 约定书写指令时用一个符“$”后面跟两个字符来代表一个寄存器：$S0。 只能将少量数据保存在寄存器中，但存储器可以存储数十亿的数据元素。 因此，数据结构是存放在存储器中的。
MIPS 的算术运算指令只对寄存器进行操作,因此，MIPS 必须包含在存储器和寄存器之间传送数据的指令。这些指令叫作数据传送指令。
为了访问存储器中的一个字，指令必须给出存储器地址。将数据从存储器复制到寄存器的数据传送指令通常叫取数 (load) 指令。MIPS取数指令助记符是lw。也就是load word的缩写： 基本语法：lw 目标寄存器, 偏移量(基址寄存器) lw $t0, 100($s1)
和取数相对应的就是存数(sw): 基本语法：sw 源寄存器，偏移量(目的寄存器) sw $s1, 4($s2)
注:上述100和4为立即数----&amp;gt;常数 注:地址其实也是一个数据，也可以做操作数参与指令操作 寄存器的数量相对于程序可能需要存储的变量数量而言通常是非常有限的。 将最常用的变量保存在寄存器中可以显著提高程序执行效率。&amp;mdash;&amp;mdash;&amp;gt;加速大概率事件
当一个变量不再频繁使用或者当前需要用到的变量太多，而寄存器资源不足时，编译器会选择将某个寄存器中的变量“溢出”到内存中存储，这个过程称为寄存器溢出。</description>
    </item>
    
    <item>
      <title>计算机组成原理</title>
      <link>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 08 Apr 2024 19:57:43 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</guid>
      <description>计算机发展史: 第一代:电子管计算机 第二代:晶体管计算机 第三代:集成电路 第四代:超大集成电路
冯诺依曼:&amp;ldquo;存储程序&amp;quot;思想
计算机构成: CPU： CU:控制单元 ALU:算术逻辑单元 寄存器组 cache:高速缓存(一般集成到CPU上)
存储器 输入设备:键盘，鼠标 输出设备:显示器，打印机 总线 计算机分类: 1.个人计算机(PC) 2.服务器 3.嵌入式计算机 4.个人移动设备(PMD) 5.云计算
计算机设计思想: 1.面向摩尔定律的设计 2.使用抽象简化设计 (1)计算机系统的设计中的抽象 1.应用层 2.操作系统层 3.硬件驱动层 4.硬件层 (2)软件设计中的抽象 1.产品/架构:概念层次 2.架构师:逻辑层次 3.软件工程师:编程 物理层
3.加速大概率事件(缓存，数据压缩，预处理) 优化瓶颈:若干个关键操作(占用较多资源的操作)构成系统的瓶颈 高速缓存(cache):加速数据的访问速度 数据压缩:通过压缩数据，使数据所占空间减小 预处理:脏数据&amp;mdash;&amp;gt;预处理&amp;mdash;&amp;gt;干净数据 预测/推测执行:即下述6 4.通过并行提高性能 并行:同一时刻，可以处理多个任务&amp;mdash;&amp;ndash;&amp;gt;多核CPU 并发:同一时间内采用交替执行的方式，宏观上并行，微观上串行&amp;mdash;&amp;ndash;&amp;gt;单核CPU 5.通过流水线(一种经典的并行处理技术)来提高性能 指令流水线:指令执行 取指 译码 执行 访存 写回 6.通过预测来提高性能 (1)指令预测 (2)分支预测 (3)缓存预取 7.存储器层次结构 存储器分层: (1)顶层,最接近CPU:速度快 成本高 容量小&amp;mdash;-&amp;gt;寄存器 高速缓存&amp;mdash;-&amp;gt;常用数据/指令 (2)下一层:主存储器(主存/内存) 速度慢一些 成本低一些 容量大一些&amp;mdash;-&amp;gt;易失性存储介质 (3)第三层:虚拟内存/磁盘缓存 (4)底层 硬盘(外存) 最慢 成本最低 容量最大&amp;mdash;-&amp;gt;永久性存储介质 8.</description>
    </item>
    
  </channel>
</rss>
