<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统 on 清兵卫的博客</title>
    <link>https://qingbingwei.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on 清兵卫的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 05 Sep 2024 09:15:33 +0800</lastBuildDate><atom:link href="https://qingbingwei.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>内存管理</title>
      <link>https://qingbingwei.github.io/post/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 05 Sep 2024 09:15:33 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>为什么需要内存管理？ 不管存储器有多大，程序大小的增长速度比内存容量的增长速度要快的多
无存储器抽象 1.最简单的存储器抽象是无存储器 2.早期的大型机、小型机、个人计算机都是直接操控内存 3.这种情况下的计算机不可能会有两个应用程序同时在内存中
在没有存储器抽象的系统中实现并行性一种方式是使用多线程来编程。 注:人们通常希望能够在同一时间内运行没有关联的程序，而这正是线程抽象所不能提供的。 把当前内存中所有内容保存到磁盘文件中，然后再把程序读入内存即可 物理内存暴露的缺点 1.如果用户程序可以寻址内存的每个字节，它们就可以很容易的破坏操作系统 2.想要运行多个程序是很困难的 3.如果要使多个应用程序同时运行在内存中，必须要解决两个问题：保护和重定位。 一种存储器抽象：地址空间 1.进程可以用来寻址内存的地址集 2.每个进程都有它自己的地址空间，独立于其他进程的地址空间。 3.最简单的办法是使用动态重定位(dynamic relocation)技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。 (1)基址寄存器和变址寄存器 (2)存储数据内存的起始位置和存储应用程序的长度 4.如果计算机的物理内存足够大来容纳所有的进程，那么之前提及的方案或多或少是可行的。
交换技术 把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。
逻辑层面操作系统把数据分成不同的段来存储 代码段（codesegment/textsegment） 数据段（datasegment） 存储初始化好的静态和全局变量 bss段（bsssegment） 存储未初始化的静态和全局变量 rodata段 栈（stack） 堆（heap） 内存增长处理方式 1.如果一个进程与空闲区相邻，那么可把该空闲区分配给进程以供其增大。 2.如果进程相邻的是另一个进程，就会有两种处理方式：要么把需要增长的进程移动到一个内存中空闲区足够大的区域，要么把一个或多个进程交换出去，以变成生成一个大的空闲区。 3.如果一个进程在内存中不能增长，而且磁盘上的交换区也满了，那么这个进程只有挂起一些空闲空间（或者可以结束该进程） 空闲内存的管理 1.位图 2.空闲列表 按照地址顺序在链表中存放进程和空闲区 1.首次适配 (1)内存管理器会沿着段列表进行扫描 (2)首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。 2.下次适配 (1)记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索 (2)性能略低于首次匹配 3.最佳适配 (1)试图找出最接近实际需要的空闲区 4.最差适配 (1)总是分配最大的内存区域 5.为进程和空闲区维护各自独立的链表以提高性能 6.快速匹配 (1)为那些常用大小的空闲区维护单独的链表 虚拟内存 基本思想 (1)每个程序都有自己的地址空间 (2)这个地址空间被划分为多个称为页面(page)的块。 (3)虚拟地址是对基址寄存器和变址寄存器的一种描述
分页技术 1.在任何一台计算机上，程序会引用使用一组内存地址 2.地址可以通过索引、基址寄存器、段寄存器或其他方式产生 3.这些程序生成的地址被称为虚拟地址(virtual addresses) 并形成虚拟地址空间(virtual address space) 存在映射的页如何映射 1.虚拟地址空间由固定大小的单元组成，这种固定大小的单元称为 页(pages)。 2.物理内存中也有固定大小的物理单元，称为 页框(page frames)。 3.</description>
    </item>
    
    <item>
      <title>线程与进程</title>
      <link>https://qingbingwei.github.io/post/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Wed, 08 May 2024 15:36:12 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</guid>
      <description>进程模型 进程是对正在运行中的程序的一个抽象
进程的创建 1.系统初始化 启动操作系统时，通常会创建若干个进程 1.前台进程 2.守护进程 2.正在运行的程序执行了创建进程的系统调用 3.用户请求创建一个新进程 4.初始化一个批处理工作 进程的终止 1.正常退出(自愿的) 2.错误退出(自愿的) 3.严重错误(非自愿的) 4.被其他进程杀死(非自愿的) 进程的层次结构 1.Unix进程体系:进程树,结构清晰 2.Windows进程体系:Windows中没有进程层次的概念，Windows中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。 进程的状态 1.阻塞(因为等待) 2.运行 3.就绪(因为调度程序的选择) 线程模型 为什么要有线程的概念？ 1.多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的 2.线程要比进程更轻量级 3.如果多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度。
线程的使用 1.多线程解决方案 有并行性，阻塞系统调用 2.单线程解决方案 无并行性，性能较差，阻塞系统调用 3.状态机解决方案(状态机中保存将要发生的或者会使得状态改变的一个集合) 并行性，非阻塞系统调用、中断 经典的线程模型 线程可称为轻量级进程 线程的系统调用 POSIX线程(IEEE在IEEE标准1003.1c中定义线程标准) 线程实现 1.在用户空间中实现线程 优势: 1.启动他们比进行内核调用效率更高。因为不需要切换到内核,也就不需要上下文 切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高 2.它允许每个进程有自己定制的调度算法 劣势: 1.如何阻塞系统调用 2.不可能使用轮转调度的方式调度线程 2.在内核空间中实现线程 注:系统调用开销大 3.在用户和内核空间中混合实现线程 进程间通信
竞态条件 即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition) 临界区 1.任何时候两个进程不能同时处于临界区 2.不应对CPU的速度和数量做任何假设 3.位于临界区外的进程不得阻塞其他进程 4.不能使任何进程无限等待进入临界区 忙等互斥 1.屏蔽中断 在单处理器系统上，最简单的解决方案是让每个进程在进入临界区后立即屏蔽所有中断（包括CPU时钟中断） 对内核来说，当它在执行更新变量或列表的几条指令期间将中断屏蔽是很方便的 2.锁变量 寻找一种软件层面解决方案 3.严格轮询法 while(TRUE){ while(turn == 0 ) { /*进入关键区域*/ critical_region (); turn = 1; /*离开关键区域*/ noncritical_region(); } } while(TRUE){ while(turn == 1 ) { /*进入关键区域*/ critical_region (); turn = 0; /*离开关键区域*/ noncritical_region(); } } 4.</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://qingbingwei.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 14 Apr 2024 23:26:18 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>硬件支持系统 系统管理硬件
操作系统就是一个建立在应用程序和硬件之间的一道桥梁 基本功能: 1.防止硬件被滥用，尤其是一些失控程序 2.通过一种比较简单的机制匹配对应的应用程序，进而控制复杂的硬件 对硬件的抽象: 1.进程 2.虚拟内存 3.文件
进程:进程的本质就是操作系统执行的一个程序
与进程相关 1.地址空间&amp;mdash;&amp;mdash;从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表 2.资源集&amp;mdash;&amp;mdash;-通常包括寄存器(寄存器一般包括程序计数器和堆栈指针)，打开文件的清单，突发的警报，有关的进程清单和其他需要执行程序的信息
进程挂起 1.进程的地址空间&amp;mdash;-磁盘映像 2.进程表项
进程间通信 合作完成某些作业的相关进程经常需要彼此通信来完成作业
进程是什么 1.从理论角度看，是对正在运行的程序过程的抽象 2.从实现角度看，是一种数据结构，目的在于清晰的刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序
并发技术 通过指令的交错执行，进程在来回切换，一个进程的指令和另一个进程的指令交错执行的过程就叫做并发运行
在每个任务运行前，CPU都需要知道任务从哪里加载和运行 1.CPU寄存器 2.程序计数器 线程 线程是操作系统能够进行运算调度的最小单位。其被包含在进程中，是进程中的实际运作单位
并发和并行 1.并行是指两个或者多个事件在同一时刻发生 2.并发是指两个或者多个事件在同一时间间隔内发生
系统调用 操作系统提供的两种功能 1.为用户提供应用程序抽象 2.管理计算机资源 注:只有系统调用能够进入内核态而过程调用则不能进入内核态 注:API(应用程序接口)，POSIX(系统程序接口)
分类 1.用于进程管理的系统调用 2.用于文件管理的系统调用 3.用于目录管理的系统调用 操作系统结构 1.单体结构 整个操作系统是以程序集合来编写的 优点: 调用任何一个所需要程序都非常高效 缺点: 1.但是上千个不受限制的彼此调用往往非常臃肿 2.只要系统故障，那么任何系统和应用程序将不可用，这是灾难性的 2.分层系统 分层系统使用层来分隔不同的功能单元。每一层只与该层上层与下层通信 3.微内核 传统上，所有的层都在内核中，但是这样没必要，尽可能减少内核态中功能可能是更好的做法
只有一个模块---微内核---运行在内核态，其余模块可以作为普通用户进程运行 4.客户-服务端系统 </description>
    </item>
    
  </channel>
</rss>
