<!doctype html>
<html lang="en">
  <head>
    <title>数据结构 树 // 清兵卫的博客</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="qingbingwei" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据结构 树"/>
<meta name="twitter:description" content="被文科折磨的百忙之中抽空学习(麻了，我还是个工科生吗)，学习完之后一堆文科小组作业等着我&hellip;&hellip;(主打一个裸考四级，乐)
树型结构：逻辑结构 概念：树是存储一对多关系的数据的逻辑结构，在树中，用节点存储数据
节点分类: 1.根节点(无前驱节点) 2.叶子节点(无子节点) 3.内部节点(有些教材把根节点归为内部节点)
父子关系和兄弟关系(一般理解为广义兄弟关系)
树：度/阶&mdash;表示节点分了多少个叉
节点的度：该节点孩子节点的数目/分叉的数目 树的度：max(所有节点的度)，如果树的度为n，称为n叉树
树的高度和深度：在数值上一样(方向不一样，从上往下或从下往上) 结点的深度：注意方向即可
方便操作根节点，在之前增加一个空节点(与链表头节点类似) 方便操作叶子节点，在其之后增加一个空节点
存储结构:
存一棵树：1.节点数据 2.数据之间的关系&ndash;父子
1.双亲(父亲)表示法：方便找父亲，不方便找孩子 1.顺序存储方式存数据：&ndash;数组 2.在存数据的同时，把每个数据的父亲所在下标存一下
#define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; using namespace std; template&lt;class T&gt; class Node { public: T data;//存储数据 int fi;//father_i,fi == -1,认为是根节点 }; template&lt;class T&gt; class Tree { public: int size; Node&lt;T&gt;* pN;//指针开辟数组，存储节点 public: Tree(T k, int sz = 1) { //加入根节点 pN = new Node&lt;T&gt;[sz]; pN[0].data = k; pN[0].fi = -1; size = 1; } int Find(T fx) { for (int i = 0; i &lt; size; i&#43;&#43;) { if (pN[i]."/>

    <meta property="og:title" content="数据结构 树" />
<meta property="og:description" content="被文科折磨的百忙之中抽空学习(麻了，我还是个工科生吗)，学习完之后一堆文科小组作业等着我&hellip;&hellip;(主打一个裸考四级，乐)
树型结构：逻辑结构 概念：树是存储一对多关系的数据的逻辑结构，在树中，用节点存储数据
节点分类: 1.根节点(无前驱节点) 2.叶子节点(无子节点) 3.内部节点(有些教材把根节点归为内部节点)
父子关系和兄弟关系(一般理解为广义兄弟关系)
树：度/阶&mdash;表示节点分了多少个叉
节点的度：该节点孩子节点的数目/分叉的数目 树的度：max(所有节点的度)，如果树的度为n，称为n叉树
树的高度和深度：在数值上一样(方向不一样，从上往下或从下往上) 结点的深度：注意方向即可
方便操作根节点，在之前增加一个空节点(与链表头节点类似) 方便操作叶子节点，在其之后增加一个空节点
存储结构:
存一棵树：1.节点数据 2.数据之间的关系&ndash;父子
1.双亲(父亲)表示法：方便找父亲，不方便找孩子 1.顺序存储方式存数据：&ndash;数组 2.在存数据的同时，把每个数据的父亲所在下标存一下
#define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; using namespace std; template&lt;class T&gt; class Node { public: T data;//存储数据 int fi;//father_i,fi == -1,认为是根节点 }; template&lt;class T&gt; class Tree { public: int size; Node&lt;T&gt;* pN;//指针开辟数组，存储节点 public: Tree(T k, int sz = 1) { //加入根节点 pN = new Node&lt;T&gt;[sz]; pN[0].data = k; pN[0].fi = -1; size = 1; } int Find(T fx) { for (int i = 0; i &lt; size; i&#43;&#43;) { if (pN[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-11-22T20:07:38+08:00" />
<meta property="article:modified_time" content="2023-11-22T20:07:38+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://qingbingwei.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="qingbingwei" /></a>
      <span class="app-header-title">清兵卫的博客</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">About</a>
      </nav>
      <p>这里是清兵卫的博客，用于记录生活日常，代码存储于GitHub上</p>
      <div class="app-header-social">
        
          <a href="https://github.com/qingbingwei" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/gohugoio" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>Twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">数据结构 树</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 22, 2023
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          10 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://qingbingwei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>被文科折磨的百忙之中抽空学习(麻了，我还是个工科生吗)，学习完之后一堆文科小组作业等着我&hellip;&hellip;(主打一个裸考四级，乐)</p>
<p>树型结构：逻辑结构
概念：树是存储一对多关系的数据的逻辑结构，在树中，用节点存储数据</p>
<p>节点分类:
1.根节点(无前驱节点)
2.叶子节点(无子节点)
3.内部节点(有些教材把根节点归为内部节点)</p>
<p>父子关系和兄弟关系(一般理解为广义兄弟关系)</p>
<p>树：度/阶&mdash;表示节点分了多少个叉</p>
<p>节点的度：该节点孩子节点的数目/分叉的数目
树的度：max(所有节点的度)，如果树的度为n，称为n叉树</p>
<p>树的高度和深度：在数值上一样(方向不一样，从上往下或从下往上)
结点的深度：注意方向即可</p>
<p>方便操作根节点，在之前增加一个空节点(与链表头节点类似)
方便操作叶子节点，在其之后增加一个空节点</p>
<p>存储结构:</p>
<p>存一棵树：1.节点数据 2.数据之间的关系&ndash;父子</p>
<p>1.双亲(父亲)表示法：方便找父亲，不方便找孩子
1.顺序存储方式存数据：&ndash;数组
2.在存数据的同时，把每个数据的父亲所在下标存一下</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;
template&lt;class T&gt;
class Node
{
public:
    T data;//存储数据
    int fi;//father_i,fi == -1,认为是根节点
};
template&lt;class T&gt;
class Tree
{
public:
    int size;
    Node&lt;T&gt;* pN;//指针开辟数组，存储节点
public:
    Tree(T k, int sz = 1)
    {
        //加入根节点
        pN = new Node&lt;T&gt;[sz];
        pN[0].data = k;
        pN[0].fi = -1;
        size = 1;
    }
    int Find(T fx)
    {
        for (int i = 0; i &lt; size; i++)
        {
            if (pN[i].data == fx)
            {
                return i;
            }
        }
        return -1;
    }
    void insert(T x, T fx)
    {
        pN[size].data = x;
        int fx_i = Find(fx);
        if (fx_i == -1)
        {
            cout &lt;&lt; x &lt;&lt; &quot;的父亲不存在&quot; &lt;&lt; endl;
            return;
        }
        pN[size].fi = fx_i;
        size++;
    }
    void Find_Ch(T x)
    {
        int x_i = Find(x);//查找该数据对应坐标，通过坐标找到该节点孩子节点
        int sum(0);
        for (int i = 0; i &lt; size; i++)
        {
            if (pN[i].fi == x_i)
            {
                sum++;
                cout &lt;&lt; pN[i].data &lt;&lt; ' ';
            }
        }
        if (sum == 0)
        {
            cout &lt;&lt; x &lt;&lt; &quot;没有孩子节点&quot; &lt;&lt; endl;
        }
    }
    void Find_Fa(T x)
    {
        int x_i = Find(x);
        int fa_i = pN[x_i].fi;
        if (fa_i == -1)
        {
            cout &lt;&lt; &quot;该节点是根节点，没有父亲节点&quot; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; pN[fa_i].data &lt;&lt; ' ' &lt;&lt; endl;
        }
    }
};
//一般的树不考虑删除
int main()
{
    int n(0);
    cin &gt;&gt; n;
    Tree&lt;int&gt; t(100, n);
    t.insert(12, 100);
    t.insert(13, 100);
    t.Find_Ch(100);
    t.Find_Fa(13);
    cout &lt;&lt; t.Find(100) &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>2.孩子表示法：
1.顺序存储方式存数据：&ndash;数组
2.链表来存每个节点孩子的数据</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;
template&lt;class T&gt;
class ch_Node
{
public:
    T data;
    ch_Node&lt;T&gt;* next;
};
template&lt;class T&gt;
class ch_Link //孩子链表
{
public:
    ch_Link()
    {
        head = new ch_Node&lt;T&gt;;
        if (head == nullptr)
        {
            cout &lt;&lt; &quot;开辟失败&quot; &lt;&lt; endl;
        }
        else
        {
            head-&gt;next = nullptr;
        }
    }
public:
    ch_Node&lt;T&gt;* head;
};
template&lt;class T&gt;
class Tree_Node //树的节点
{
public:
    T data;
    ch_Link&lt;T&gt; cl;
};
template&lt;class T&gt;
class Tree //树
{
public:
    Tree(T k, int sz = 1)
    {
        size = 0;
        nd = new Tree_Node&lt;T&gt;[sz];
        nd[0].data = k;
        size++;
    }
    int Find(T x)
    {
        for (int i = 0; i &lt; size; i++)
        {
            if (nd[i].data == x)
            {
                return i;
            }
        }
        return -1;
    }
    void insert(T x, T fx)
    {
        nd[size].data = x; //放入新节点数据
        nd[size].cl.head-&gt;next = nullptr;
        int fx_i = Find(fx);//建立fx与x父子关系
        if (fx_i == -1)
        {
            cout &lt;&lt; &quot;为根节点，无法建立&quot; &lt;&lt; endl;
        }
        else
        {
            ch_Node&lt;T&gt;* s = new ch_Node&lt;T&gt;;
            s-&gt;data = x;
            //头插法
            s-&gt;next = nd[fx_i].cl.head-&gt;next;
            nd[fx_i].cl.head-&gt;next = s;
            size++;
        }
    }
    void Find_Ch(T x)
    {
        int x_i = Find(x);
        ch_Node&lt;T&gt;* p = nd[x_i].cl.head-&gt;next;
        if (p == nullptr)
        {
            cout &lt;&lt; x &lt;&lt; &quot;没有孩子&quot; &lt;&lt; endl;
            return;
        }
        while (p != nullptr)
        {
            cout &lt;&lt; p-&gt;data &lt;&lt; ' ';
            p = p-&gt;next;
        }
        cout &lt;&lt; endl;
    }
    void Find_Fa(T x)
    {
        ch_Node&lt;T&gt;* p = nullptr;
        int flag(0); //用于标记根节点
        for (int i = 0; i &lt; size; i++)
        {
            p = nd[i].cl.head-&gt;next;
            while (p != nullptr &amp;&amp; p-&gt;data != x)
            {
                p = p-&gt;next;
            }
            if (p != nullptr &amp;&amp; p-&gt;data == x)
            {
                cout &lt;&lt; nd[i].data &lt;&lt; ' ' &lt;&lt; endl;
                flag = 1;
                break;
            }
        }
        if (flag == 0)
        {
            cout &lt;&lt; x &lt;&lt; &quot;是根节点&quot; &lt;&lt; endl;
        }
    }
public:
    Tree_Node&lt;T&gt;* nd;
    int size;
};
int main()
{
    Tree&lt;int&gt; t(100, 1000);
    t.insert(2, 100);
    t.insert(3, 100);
    t.insert(4, 100);
    t.insert(5, 100);
    t.Find_Ch(100);
    t.Find_Fa(100);
    return 0;
}
</code></pre>
<p>3.孩子兄弟表示法&mdash;二叉链表</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;
template&lt;class T&gt;
class Tree_Node
{
public:
    T data;
    Tree_Node&lt;T&gt;* first_child; //指向第一个孩子
    Tree_Node&lt;T&gt;* bro; //指向右边第一个亲兄弟
};
template&lt;class T&gt;
class Tree
{
public:
    Tree(T root)
    {
        Tree_Link = new Tree_Node&lt;T&gt;;
        if (Tree_Link == nullptr)
        {
            cout &lt;&lt; &quot;开辟失败&quot; &lt;&lt; endl;
        }
        else
        {
            Tree_Link-&gt;bro = nullptr;
            Tree_Link-&gt;data = root;
            Tree_Link-&gt;first_child = nullptr;
        }
    }
    //查找，通过递归实现
    Tree_Node&lt;T&gt;* Find(Tree_Node&lt;T&gt;* nd, T fx)
    {
        //递归出口
        if (nd == nullptr || nd-&gt;data == fx)
        {
            return nd;
        }
        if (nd-&gt;first_child != nullptr)
        {
            Tree_Node&lt;T&gt;* ans = Find(nd-&gt;first_child, fx);
            if (ans != nullptr &amp;&amp; ans-&gt;data == fx)
            {
                return ans;
            }
        }
        if (nd-&gt;bro != nullptr)
        {
            Tree_Node&lt;T&gt;* ans = Find(nd-&gt;bro, fx);
            if (ans != nullptr &amp;&amp; ans-&gt;data == fx)
            {
                return ans;
            }
        }
        return nullptr;//fx不存在
    }
    void Insert(T x, T fx)
    {
        Tree_Node&lt;T&gt;* t = Find(Tree_Link, fx);
        if (t == nullptr)
        {
            cout &lt;&lt; &quot;父亲节点不存在&quot; &lt;&lt; endl;
            return;
        }
        else
        {
            Tree_Node&lt;T&gt;* s = new Tree_Node&lt;T&gt;;
            if (s == nullptr)
            {
                cout &lt;&lt; &quot;开辟失败&quot; &lt;&lt; endl;
            }
            else
            {
                s-&gt;data = x;
                //进行头插（比尾插简单一些）
                //如果插入的为长子
                if (t-&gt;first_child == nullptr)
                {
                    t-&gt;first_child = s;
                    s-&gt;first_child = nullptr;
                    s-&gt;bro = nullptr;
                }
                else //插入的不是长子
                {
                    Tree_Node&lt;T&gt;* fir = t-&gt;first_child;
                    s-&gt;bro = fir-&gt;bro;
                    fir-&gt;bro = s;
                    s-&gt;first_child = nullptr;
                }
            }
        }
    }
public:
    Tree_Node&lt;T&gt;* Tree_Link; //根指针
};
int main()
{
    Tree&lt;int&gt; t(100);
    t.Insert(12, 100);
    t.Insert(16, 100);
    t.Insert(15, 100);
    t.Insert(14, 100);
    t.Insert(13, 100);
    t.Insert(200, 15);
    t.Insert(201, 15);
    t.Insert(202, 15);
    t.Insert(203, 15);
    t.Insert(204, 15);
    t.Insert(205, 15);
    Tree_Node&lt;int&gt;* p = t.Find(t.Tree_Link, 15);
    Tree_Node&lt;int&gt;* fir = p-&gt;first_child;
    if (fir != nullptr)
    {
        p = fir;
        while (p != nullptr)
        {
            cout &lt;&lt; p-&gt;data &lt;&lt; ' ' &lt;&lt; endl;
            p = p-&gt;bro;
        }
    }
    return 0;
}
</code></pre>
<p>二叉树</p>
<p>两种特殊二叉树
1.满二叉树：深度为k，并且节点个数为(2^k)-1的二叉树
2.完全二叉树；对满二叉树，从下向上，从右向左依次删掉若干个节点，剩下的树就是完全二叉树
性质：默认根节点是第一层
1.在二叉树的第i层，最多有2^(i - 1)个节点</p>
<p>2.深度为k的二叉树，最多有(2^k)-1个节点（等比求和）</p>
<p>3.在一棵二叉树中，叶子节点的数目比度为2的节点数目多一个</p>
<p>4.具有n个节点的完全二叉树的深/高度为(logn) + 1, 其中logn向下取整</p>
<p>5.对于一棵完全二叉树，进行编号，编号规则为：根节点为1，然后从上到下，从左到右。除根节点外，节点i的父亲节点编号为i/2(向下取整)。除叶子节点外，节点i的左孩子节点编号为2<em>i，右节点为2</em>i+1</p>
<p>补充性质：任何一棵二叉树都可以加NULL节点，从而补成一棵满(或完全)二叉树(结合性质5得到一个存二叉树的方式&ndash;顺序存储，基于数组)</p>
<pre><code>二叉树的操作

1.建树--插入数据

2.遍历（两类四种）：沿着某条路径，对树中的节点都遍历一次且仅遍历一次。
    1.层次遍历--广度优先遍历
        遍历顺序：从上往下，依次输出每一层节点（左-&gt;右）
    2.深度优先遍历：先序遍历(根，左，右)，中序遍历(左，根，右)，后序遍历(左，右，根)
3.线索化
    背景：
    1.n个节点二叉树，以二叉链表存储，一共2n个指针域，n-1个真正存储了指针，n+1为空，极大浪费空间
    2.某一节点的中序遍历序列的前驱与后继是谁
    3.如何快速得到某节点中序遍历序列中的前驱与后继

具体操作：
    1.如果一个节点其左孩子指针域为空，那么将该指针域指向其前驱节点
    2.如果一个节点其右孩子指针域为空，那么将该指针域指向其后继节点
</code></pre>
<p>历时两周，终于把二叉树学习完了，不过这只是开始，紧接着来到的是排序二叉树，二叉平衡树&hellip;&hellip;</p>
<p>二叉树具体实现如下（包括了广度遍历，深度遍历（递归与非递归实现），线索化，查找中序遍历前驱与后继等操作）</p>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;
//链栈，用于实现非递归深度优先遍历
template&lt;class T&gt;
class stack_Node
{
public:
    T data;
    stack_Node&lt;T&gt;* next;
};
template&lt;class T&gt;
class m_stack
{
public:
    stack_Node&lt;T&gt;* head;
public:
    m_stack()
    {
        head = new stack_Node&lt;T&gt;;
        if (head == nullptr)
        {
            cout &lt;&lt; &quot;开辟失败&quot; &lt;&lt; endl;
        }
        else
        {
            head-&gt;next = nullptr;
        }
    }
    void m_push(T k)
    {
        stack_Node&lt;T&gt;* s = new stack_Node&lt;T&gt;;
        s-&gt;next = head-&gt;next;
        s-&gt;data = k;
        head-&gt;next = s;
    }
    T m_pop()
    {
        if (m_empty())
        {
            cout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;
        }
        else
        {
            //p指向要删除的首元节点
            stack_Node&lt;T&gt;* p = head-&gt;next;
            T k = p-&gt;data;
            head-&gt;next = p-&gt;next;
            delete p;
            p = nullptr;
            return k;
        }
    }
    bool m_empty()
    {
        if (head-&gt;next == nullptr)
            return true;
        else
            return false;
    }
    void get_top()
    {
        if (m_empty())
        {
            cout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; head-&gt;next-&gt;data &lt;&lt; endl;
        }
    }
};
//链式队列，用于实现广度优先遍历
template&lt;class T&gt;
class q_Node
{
public:
    T data;
    q_Node&lt;T&gt;* next;
};
template&lt;class T&gt;
class Link_queue
{
public:
    q_Node&lt;T&gt;* head;//指向头节点的指针
    q_Node&lt;T&gt;* rear;//指向队尾元素所在节点的指针
public:
    Link_queue()
    {
        head = new q_Node&lt;T&gt;;
        rear = head;
        if (head == nullptr)
        {
            cout &lt;&lt; &quot;开辟失败&quot; &lt;&lt; endl;
        }
        else
        {
            head-&gt;next = nullptr;
            rear-&gt;next = nullptr;
        }
    }
    bool m_Empty()
    {
        if (head-&gt;next == nullptr)
        {
            return true;
        }
        return false;
    }
    void En_queue(T k)
    {
        q_Node&lt;T&gt;* s = new q_Node&lt;T&gt;;
        if (s == nullptr)
        {
            cout &lt;&lt; &quot;开辟失败&quot; &lt;&lt; endl;

        }
        else
        {
            //新节点插入队尾
            s-&gt;data = k;
            s-&gt;next = nullptr;
            rear-&gt;next = s;
            rear = s;
        }
    }
    T Del_queue()
    {
        //出队时需要注意是否是首元节点出队
        T x(0);//保存出队元素
        //判空
        //1.head-&gt;next == nullptr
        //2.head == rear
        if (m_Empty())
        {
            cout &lt;&lt; &quot;队空&quot; &lt;&lt; endl;
        }
        else
        {
            q_Node&lt;T&gt;* p = head-&gt;next;
            x = head-&gt;next-&gt;data;
            head-&gt;next = head-&gt;next-&gt;next;
            if (head-&gt;next == nullptr)//删除唯一节点时避免队尾指针成为野指针
            {
                rear = head;
            }
            delete p;
            p = nullptr;
            return x;
        }
    }
};
template&lt;class T&gt;
class Binary_Tree_Node
{
public:
    T data;
    Binary_Tree_Node&lt;T&gt;* left;
    Binary_Tree_Node&lt;T&gt;* right;
    int lflag;
    int rflag;//标记左右指针指向的是孩子节点（0），还是前驱后继 （1）
public:
    Binary_Tree_Node()
    {
        lflag = 0;
        rflag = 0;
    }
};
template&lt;class T&gt;
class Binary_Tree
{
public:
    Binary_Tree(T k)
    {
        root = new Binary_Tree_Node&lt;T&gt;;
        if (root == nullptr)
        {
            cout &lt;&lt; &quot;开辟失败&quot; &lt;&lt; endl;
        }
        else
        {
            root-&gt;data = k;
            root-&gt;left = nullptr;
            root-&gt;right = nullptr;
            pre_in_thread = nullptr;
        }
    }
    Binary_Tree_Node&lt;T&gt;* Find(Binary_Tree_Node&lt;T&gt;* ro, T fx)
    {
        //运用递归实现,与先前孩子兄弟表示法查找方法相同
        if (ro == nullptr || ro-&gt;data == fx)
        {
            return ro;
        }
        //在线索化之后进行额外判断，判断是真孩子还是前驱后继
        if (ro-&gt;left != nullptr &amp;&amp; ro-&gt;lflag == 0)
        {
            Binary_Tree_Node&lt;T&gt;* f = Find(ro-&gt;left, fx);
            if (f != nullptr &amp;&amp; f-&gt;data == fx)
            {
                return f;
            }
        }
        //在线索化之后进行额外判断，判断是真孩子还是前驱后继
        if (ro-&gt;right != nullptr &amp;&amp; ro-&gt;rflag == 0)
        {
            Binary_Tree_Node&lt;T&gt;* f = Find(ro-&gt;right, fx);
            if (f != nullptr &amp;&amp; f-&gt;data == fx)
            {
                return f;
            }
        }
        return nullptr;//fx不存在
    }
    void Right_Insert(T x, T fx)
    {
        Binary_Tree_Node&lt;T&gt;* f = Find(root, fx);
        if (f != nullptr)
        {
            Binary_Tree_Node&lt;T&gt;* s = new Binary_Tree_Node&lt;T&gt;;
            s-&gt;data = x;
            s-&gt;left = nullptr;
            s-&gt;right = nullptr;
            f-&gt;right = s;
        }
    }
    void Left_Insert(T x, T fx)
    {
        Binary_Tree_Node&lt;T&gt;* f = Find(root, fx);
        if (f != nullptr)
        {
            Binary_Tree_Node&lt;T&gt;* s = new Binary_Tree_Node&lt;T&gt;;
            s-&gt;data = x;
            s-&gt;left = nullptr;
            s-&gt;right = nullptr;
            f-&gt;left = s;
        }
    }
    //二叉树的遍历

    //层次遍历--广度优先遍历
    void Level_Order()
    {
        Binary_Tree_Node&lt;T&gt;* x = nullptr;
        Link_queue&lt;Binary_Tree_Node&lt;T&gt;*&gt; m_queue;
        //判断树非空
        if (root == nullptr)
        {
            cout &lt;&lt; &quot;树空&quot; &lt;&lt; endl;
            return;
        }
        //根节点入队
        m_queue.En_queue(root);//入队数据与入队节点不同
        while (!m_queue.m_Empty())
        {
            x = m_queue.Del_queue();
            cout &lt;&lt; x-&gt;data &lt;&lt; ' ';
            if (x-&gt;left != nullptr)
            {
                m_queue.En_queue(x-&gt;left);
            }
            if (x-&gt;right != nullptr)
            {
                m_queue.En_queue(x-&gt;right);
            }
        }
    }
    //深度优先遍历(均以递归实现)
    //先序遍历
    void pre_Order(Binary_Tree_Node&lt;T&gt;* ro)
    {
        //出口，ro == nullptr
        //1.输出根节点数据
        //2.判断根左非空，递归调用，传入ro-&gt;left
        //3.判断根右非空，递归调用，传入ro-&gt;right
        if (ro == nullptr)
        {
            return;
        }
        cout &lt;&lt; ro-&gt;data &lt;&lt; ' ';
        if (ro-&gt;left != nullptr)
        {
            pre_Order(ro-&gt;left);
        }
        if (ro-&gt;right != nullptr)
        {
            pre_Order(ro-&gt;right);
        }
    }
    //中序遍历（改变输出根节点数据顺序）
    void mid_Order(Binary_Tree_Node&lt;T&gt;* ro)
    {
        if (ro == nullptr)
        {
            return;
        }
        if (ro-&gt;left != nullptr)
        {
            mid_Order(ro-&gt;left);
        }
        cout &lt;&lt; ro-&gt;data &lt;&lt; ' ';
        if (ro-&gt;right != nullptr)
        {
            mid_Order(ro-&gt;right);
        }
    }
    //后序遍历（改变输出根节点数据顺序）
    void last_Order(Binary_Tree_Node&lt;T&gt;* ro)
    {
        if (ro == nullptr)
        {
            return;
        }
        if (ro-&gt;left != nullptr)
        {
            last_Order(ro-&gt;left);
        }
        if (ro-&gt;right != nullptr)
        {
            last_Order(ro-&gt;right);
        }
        cout &lt;&lt; ro-&gt;data &lt;&lt; ' ';
    }
    //深度优先遍历（非递归实现,基于链栈）
    //先序遍历
    void pre_Order_non_recursion()
    {
        m_stack&lt;Binary_Tree_Node&lt;T&gt;*&gt; s;
        if (root == nullptr)
        {
            cout &lt;&lt; &quot;树空&quot; &lt;&lt; endl;
            return;
        }
        s.m_push(root);
        while (!s.m_empty())
        {
            Binary_Tree_Node&lt;T&gt;* nd = s.m_pop();
            cout &lt;&lt; nd-&gt;data &lt;&lt; ' ';
            if (nd-&gt;right != nullptr)
            {
                s.m_push(nd-&gt;right);
            }
            if (nd-&gt;left != nullptr)
            {
                s.m_push(nd-&gt;left);
            }
        }
    }
    //中序遍历
    void mid_Order_non_recursion()
    {
        m_stack&lt;Binary_Tree_Node&lt;T&gt;*&gt; s;
        //用node从根节点开始遍历
        if (root == nullptr)
        {
            return;
        }
        Binary_Tree_Node&lt;T&gt;* node = root;
        Binary_Tree_Node&lt;T&gt;* nd = nullptr;//存储出栈元素
        while (!s.m_empty() || node != nullptr)
        {
            if (node != nullptr)
            {
                s.m_push(node);
                node = node-&gt;left;
            }
            else
            {
                nd = s.m_pop();
                cout &lt;&lt; nd-&gt;data &lt;&lt; ' ';
                node = nd-&gt;right;
            }
        }
    }
    //后序遍历
    void last_Order_non_recursion()
    {
        m_stack&lt;Binary_Tree_Node&lt;T&gt;*&gt; s;
        if (root == nullptr)
        {
            return;
        }
        Binary_Tree_Node&lt;T&gt;* node = root;
        Binary_Tree_Node&lt;T&gt;* nd = nullptr;//存储栈顶元素
        Binary_Tree_Node&lt;T&gt;* pre = nullptr;
        //需要知道右子树是否被遍历了，所以创建pre
        while (!s.m_empty() || node != nullptr)
        {
            if (node != nullptr)
            {
                s.m_push(node);
                node = node-&gt;left;
            }
            else
            {
                nd = s.head-&gt;next-&gt;data;
                if (nd-&gt;right != nullptr &amp;&amp; pre != nd-&gt;right)
                {
                    //如果栈顶元素右孩子存在并且没有被访问，遍历右孩子
                    node = nd-&gt;right;
                }
                else
                {
                    //访问栈顶
                    nd = s.m_pop();
                    cout &lt;&lt; nd-&gt;data &lt;&lt; ' ';
                    pre = nd;
                    node = nullptr;
                }
            }
        }
    }
    //线索化，使用递归遍历操作
    void visit_thread(Binary_Tree_Node&lt;T&gt;* ro)
    {
        if (ro-&gt;left == nullptr)
        {
            ro-&gt;left = pre_in_thread;
            ro-&gt;lflag = 1;//加上标记
        }
        //先判断前驱是否为空
        if (pre_in_thread != nullptr &amp;&amp; pre_in_thread-&gt;right == nullptr)
        {
            //前驱与后继两两对应，为其前驱加上后继
            pre_in_thread-&gt;right = ro;
            pre_in_thread-&gt;rflag = 1;
        }
        pre_in_thread = ro;
    }
    //1.如果一个节点其左孩子指针域为空，那么将该指针域指向其前驱节点
    //2.如果一个节点其右孩子指针域为空，那么将该指针域指向其后继节点
    void mid_threading(Binary_Tree_Node&lt;T&gt;* ro)
    {
        if (ro == nullptr)
        {
            return;
        }
        if (ro-&gt;left != nullptr &amp;&amp; ro-&gt;lflag == 0)
        {
            mid_threading(ro-&gt;left);
        }
        visit_thread(ro);
        if (ro-&gt;right != nullptr &amp;&amp; ro-&gt;rflag == 0)
        {
            mid_threading(ro-&gt;right);
        }
    }
    //避免前序线索化与后续线索化出现死循环，递归时通过lflag与rflag进行判断
    //中序遍历不会出现上述情况，但为了格式统一和严谨，也加上
    void pre_threading(Binary_Tree_Node&lt;T&gt;* ro)
    {
        //出口，ro == nullptr
        //1.进行线索化
        //2.判断根左非空，递归调用，传入ro-&gt;left
        //3.判断根右非空，递归调用，传入ro-&gt;right
        if (ro == nullptr)
        {
            return;
        }
        visit_thread(ro);
        if (ro-&gt;left != nullptr &amp;&amp; ro-&gt;lflag == 0)
        {
            pre_threading(ro-&gt;left);
        }
        if (ro-&gt;right != nullptr &amp;&amp; ro-&gt;rflag == 0)
        {
            pre_threading(ro-&gt;right);
        }
    }
    void last_threading(Binary_Tree_Node&lt;T&gt;* ro)
    {
        if (ro == nullptr)
        {
            return;
        }
        if (ro-&gt;left != nullptr &amp;&amp; ro-&gt;lflag == 0)
        {
            last_threading(ro-&gt;left);
        }
        if (ro-&gt;right != nullptr &amp;&amp; ro-&gt;rflag == 0)
        {
            last_threading(ro-&gt;right);
        }
        visit_thread(ro);
    }

    //只需要掌握找中序遍历的前驱与后继
    //因为先序与后序遍历通过线索化找前驱与后继时效率无明显提升且过于复杂

    //某一节点前驱为其左子树最靠右节点
    Binary_Tree_Node&lt;T&gt;* Find_mid_pre(T k)
    {
        Binary_Tree_Node&lt;T&gt;* x = Find(root, k);
        if (x != nullptr)
        {
            if (x-&gt;lflag == 1)
            {
                return x-&gt;left;
            }
            else
            {
                //找左子树最靠右节点
                Binary_Tree_Node&lt;T&gt;* p = x-&gt;left;
                while (p-&gt;right != nullptr &amp;&amp; p-&gt;rflag == 0)
                {
                    p = p-&gt;right;
                }
                return p;
            }
        }
    }
    //某一节点后继为其右子树最靠左节点
    Binary_Tree_Node&lt;T&gt;* Find_mid_last(T k)
    {
        Binary_Tree_Node&lt;T&gt;* x = Find(root, k);
        if (x != nullptr)
        {
            if (x-&gt;rflag == 1)
            {
                return x-&gt;right;
            }
            else
            {
                //找右子树最靠左节点
                Binary_Tree_Node&lt;T&gt;* p = x-&gt;right;
                while (p-&gt;left != nullptr &amp;&amp; p-&gt;lflag == 0)
                {
                    p = p-&gt;left;
                }
                return p;
            }
        }
    }
public:
    //根节点
    Binary_Tree_Node&lt;T&gt;* root;
    //用于记录线索化时遍历至某一节点的前驱节点
    Binary_Tree_Node&lt;T&gt;* pre_in_thread;
};
int main()
{
    Binary_Tree&lt;char&gt; tree('A');
    /*tree.Left_Insert(15, 100);
    tree.Left_Insert(19, 15);
    cout &lt;&lt; tree.root-&gt;data &lt;&lt; endl;
    cout &lt;&lt; tree.root-&gt;left-&gt;data &lt;&lt; endl;
    cout &lt;&lt; tree.root-&gt;left-&gt;left-&gt;data &lt;&lt; endl;*/
    tree.Left_Insert('B', 'A');
    tree.Right_Insert('C', 'B');
    tree.Left_Insert('D', 'C');
    tree.Right_Insert('E', 'A');
    tree.Right_Insert('F', 'E');
    tree.Left_Insert('G', 'F');
    tree.Right_Insert('K', 'G');
    tree.Left_Insert('H', 'G');
    tree.Level_Order();
    cout &lt;&lt; endl;
    tree.pre_Order(tree.root);
    cout &lt;&lt; endl;
    tree.mid_Order(tree.root);
    cout &lt;&lt; endl;
    tree.last_Order(tree.root);
    cout &lt;&lt; endl;
    tree.pre_Order_non_recursion();
    cout &lt;&lt; endl;
    tree.mid_Order_non_recursion();
    cout &lt;&lt; endl;
    tree.last_Order_non_recursion();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;
    tree.mid_threading(tree.root);
    Binary_Tree_Node&lt;char&gt;* ans1;
    Binary_Tree_Node&lt;char&gt;* ans2;
    ans1 = tree.Find_mid_pre('A');
    ans2 = tree.Find_mid_last('A');
    cout &lt;&lt; ans1-&gt;data &lt;&lt; ' ';
    cout &lt;&lt; ans2-&gt;data &lt;&lt; ' ';
    return 0;
}</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
