<!doctype html>
<html lang="en">
  <head>
    <title>指令格式 // 清兵卫的博客</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="qingbingwei" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="指令格式"/>
<meta name="twitter:description" content="指令：由一系列的二进制位（bits）组成的，这些位可以表示不同的操作、操作数地址、跳转目标等。
在 MIPS 架构中，指令的编码是精心设计的，以便 CPU 能够解码并执行相应的操作。 每个指令通常都包含操作码（opcode，用于标识指令的类型）、源操作数、目标操作数等部分。
指令有自己的布局格式，叫做指令格式。指令的格式或布局定义了指令在计算机内存中的表示方式。
对于MIPS架构，每条指令都是32位长，这与MIPS体系结构中数据字的位数相一致。 这种固定长度的指令格式简化了指令的解码和执行过程，因为CPU不需要在读取指令时确定指令的长度。
在计算机科学中，我们通常将这种直接表示为二进制形式的指令称为机器语言或机器码。
字:计算机一次能处理的一个数据，一个字由若干个字节组成 (机器）字长∶字的长度（位数)，等于CPU内部用于整数运算的运算器的位数或者是寄存器的位数
指令字长:一条指令中所包含的二进制位数,一条指令的长度 存储字长:一个存储单元的二进制的位数
指令字长=n*存储字长
/*****************************/
以加法为例：add $t0, $s1, $s2&mdash;&ndash;&gt;机器码是？
该指令包含了一个操作码和三个寄存器。
关于寄存器，这些寄存器在汇编语言中有特定的名称，如 $s0 、 $s1 、 $t0 、 $t1 等。在底层，这些寄存器的名字会被映射成数字，以便硬件能够识别和操作。
例如： 寄存器 $s0 ~ $s7 在 MIPS 中映射到数字 16 ~ 23。 寄存器 $t0 ~ $t7 映射到数字 8 ~ 15。
这种映射关系使得汇编语言编写的程序能够在底层被正确地转换成机器码，并由硬件执行。当汇编 器或编译器处理源代码时，它会将这些寄存器名称转换为相应的数字，以生成正确的机器码。
这种映射关系的设计允许指令集保持简洁和一致，同时使得硬件实现更加高效。
由于MIPS指令是固定长度的32位格式，操作码和其他字段的位置是固定的。
1.opcode(ADD指令的操作码)高六位为0x0，低六位为0x20 2.rs(源寄存器1)对应于s1，在MIPS中s1的编号是17(s0-s7对应16-23)，所以这里的rs部分应为10001 3.rt(源寄存器2)对应于s2，在MIPS中s2的编号是18，所以这里的rt部分应为10010 4.rd(目标奇存器)对应于t0，在MIPS*中t0的编号是8( tO-t7对应8-15)，所以这里的rd部分应为1000由于限定为5位所以是01000
基于上述指令格式， add $t0, $s1, $s2 指令可以翻译成：
完整的32位机器码:000000 10001 10010 01000 00000 100000"/>

    <meta property="og:title" content="指令格式" />
<meta property="og:description" content="指令：由一系列的二进制位（bits）组成的，这些位可以表示不同的操作、操作数地址、跳转目标等。
在 MIPS 架构中，指令的编码是精心设计的，以便 CPU 能够解码并执行相应的操作。 每个指令通常都包含操作码（opcode，用于标识指令的类型）、源操作数、目标操作数等部分。
指令有自己的布局格式，叫做指令格式。指令的格式或布局定义了指令在计算机内存中的表示方式。
对于MIPS架构，每条指令都是32位长，这与MIPS体系结构中数据字的位数相一致。 这种固定长度的指令格式简化了指令的解码和执行过程，因为CPU不需要在读取指令时确定指令的长度。
在计算机科学中，我们通常将这种直接表示为二进制形式的指令称为机器语言或机器码。
字:计算机一次能处理的一个数据，一个字由若干个字节组成 (机器）字长∶字的长度（位数)，等于CPU内部用于整数运算的运算器的位数或者是寄存器的位数
指令字长:一条指令中所包含的二进制位数,一条指令的长度 存储字长:一个存储单元的二进制的位数
指令字长=n*存储字长
/*****************************/
以加法为例：add $t0, $s1, $s2&mdash;&ndash;&gt;机器码是？
该指令包含了一个操作码和三个寄存器。
关于寄存器，这些寄存器在汇编语言中有特定的名称，如 $s0 、 $s1 、 $t0 、 $t1 等。在底层，这些寄存器的名字会被映射成数字，以便硬件能够识别和操作。
例如： 寄存器 $s0 ~ $s7 在 MIPS 中映射到数字 16 ~ 23。 寄存器 $t0 ~ $t7 映射到数字 8 ~ 15。
这种映射关系使得汇编语言编写的程序能够在底层被正确地转换成机器码，并由硬件执行。当汇编 器或编译器处理源代码时，它会将这些寄存器名称转换为相应的数字，以生成正确的机器码。
这种映射关系的设计允许指令集保持简洁和一致，同时使得硬件实现更加高效。
由于MIPS指令是固定长度的32位格式，操作码和其他字段的位置是固定的。
1.opcode(ADD指令的操作码)高六位为0x0，低六位为0x20 2.rs(源寄存器1)对应于s1，在MIPS中s1的编号是17(s0-s7对应16-23)，所以这里的rs部分应为10001 3.rt(源寄存器2)对应于s2，在MIPS中s2的编号是18，所以这里的rt部分应为10010 4.rd(目标奇存器)对应于t0，在MIPS*中t0的编号是8( tO-t7对应8-15)，所以这里的rd部分应为1000由于限定为5位所以是01000
基于上述指令格式， add $t0, $s1, $s2 指令可以翻译成：
完整的32位机器码:000000 10001 10010 01000 00000 100000" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qingbingwei.github.io/post/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-08-21T14:18:01+08:00" />
<meta property="article:modified_time" content="2024-08-21T14:18:01+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://qingbingwei.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="qingbingwei" /></a>
      <span class="app-header-title">清兵卫的博客</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">About</a>
      </nav>
      <p>这里是清兵卫的博客，用于记录生活日常，代码存储于GitHub上</p>
      <div class="app-header-social">
        
          <a href="https://github.com/qingbingwei" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/gohugoio" target="_blank" rel="noreferrer noopener me">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>Twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">指令格式</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Aug 21, 2024
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://qingbingwei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>指令：由一系列的二进制位（bits）组成的，这些位可以表示不同的操作、操作数地址、跳转目标等。</p>
<p>在 MIPS 架构中，指令的编码是精心设计的，以便 CPU 能够解码并执行相应的操作。
每个指令通常都包含操作码（opcode，用于标识指令的类型）、源操作数、目标操作数等部分。</p>
<p>指令有自己的布局格式，叫做指令格式。指令的格式或布局定义了指令在计算机内存中的表示方式。</p>
<p>对于MIPS架构，每条指令都是32位长，这与MIPS体系结构中数据字的位数相一致。
这种固定长度的指令格式简化了指令的解码和执行过程，因为CPU不需要在读取指令时确定指令的长度。</p>
<p>在计算机科学中，我们通常将这种直接表示为二进制形式的指令称为机器语言或机器码。</p>
<p>字:计算机一次能处理的一个数据，一个字由若干个字节组成
(机器）字长∶字的长度（位数)，等于CPU内部用于整数运算的运算器的位数或者是寄存器的位数</p>
<p>指令字长:一条指令中所包含的二进制位数,一条指令的长度
存储字长:一个存储单元的二进制的位数</p>
<p>指令字长=n*存储字长</p>
<p>/*****************************/</p>
<p>以加法为例：add $t0, $s1, $s2&mdash;&ndash;&gt;机器码是？</p>
<p>该指令包含了一个操作码和三个寄存器。</p>
<p>关于寄存器，这些寄存器在汇编语言中有特定的名称，如 $s0 、 $s1 、 $t0 、 $t1 等。在底层，这些寄存器的名字会被映射成数字，以便硬件能够识别和操作。</p>
<p>例如：
寄存器 $s0 ~ $s7 在 MIPS 中映射到数字 16 ~ 23。
寄存器 $t0 ~ $t7 映射到数字 8 ~ 15。</p>
<p>这种映射关系使得汇编语言编写的程序能够在底层被正确地转换成机器码，并由硬件执行。当汇编
器或编译器处理源代码时，它会将这些寄存器名称转换为相应的数字，以生成正确的机器码。</p>
<p>这种映射关系的设计允许指令集保持简洁和一致，同时使得硬件实现更加高效。</p>
<p>由于MIPS指令是固定长度的32位格式，操作码和其他字段的位置是固定的。</p>
<p>1.opcode(ADD指令的操作码)高六位为0x0，低六位为0x20
2.rs(源寄存器1)对应于s1，在MIPS中s1的编号是17(s0-s7对应16-23)，所以这里的rs部分应为10001
3.rt(源寄存器2)对应于s2，在MIPS中s2的编号是18，所以这里的rt部分应为10010
4.rd(目标奇存器)对应于t0，在MIPS*中t0的编号是8( tO-t7对应8-15)，所以这里的rd部分应为1000由于限定为5位所以是01000</p>
<p>基于上述指令格式， add $t0, $s1, $s2 指令可以翻译成：</p>
<p>完整的32位机器码:000000 10001 10010 01000 00000 100000</p>
<p>MIPS 完整指令格式：以R型指令为例</p>
<pre><code>Op:指令操作码，用于标识指令的类型和功能。6位
Rs:第一个源操作数寄存器号，用于存放第一个操作数。5位
Rt:第二个源操作数寄存器号，用于存放第二个操作数。5位
Rd:目标操作数寄存器号，用于存放指令执行的结果。5位
Shamt:位移量字段，用于指定移位指令的位移量。5位
Func:指令功能码，用于选择op操作中的具体函数。6位
</code></pre>
<p>/******************************************************* */</p>
<p>取数指令：lw 目标寄存器, 偏移量(基址寄存器)
操作数有三个，两个寄存器和一个立即数。通常，加载指令使用一种称为“基址+偏移”的方式，其中基址是一个寄存器，偏移是一个立即数。</p>
<p>但是R型述指令中，并没有一个字段能够直接容纳一个大点的立即数。他的立即数被限制在了5位，即2^5次方 = 32之内。想想我们定义的数组等这些东西，难道只能定义这么大么？肯定不是的。因此，我们还设定了其他不同的指令格式(R型、I型、J型)。</p>
<p>/****************************************************** */</p>
<p>MIPS指令的长度都固定为32位，即每条指令的长度相同，称为定长指令。</p>
<p>这种设计简化了处理器的设计和指令解码过程，使得硬件在执行指令时无需根据指令的不同长度调整操作，提高了处理效率。
尽管不同类型的指令可能在字段分配上有所不同，但每条指令的总长度始终保持一致。</p>
<p>/******************************************************* */</p>
<p>对于指令的设计，我们既希望所有指令长度相同，又希望具有统一的指令格式，两者之间产生了冲突。
这就引出了最后一条硬件设计原则：优秀的设计需要适宜的折中方案。</p>
<p>在设计计算机体系结构时，需要在寄存器数量和指令长度之间做出权衡：</p>
<pre><code>一方面，更多的寄存器能够减少对内存的访问频率，提高程序执行效率，因为寄存器比主存更快且访问延迟更短。
然而，每增加一个寄存器就需要在指令格式中为该寄存器编号分配额外的位数。

另一方面，保持指令长度不变有利于简化处理器设计和优化流水线处理，同时也有助于减小存储指
令所需的存储空间。
</code></pre>
<p>因此，在实际应用中，现代指令集架构往往会选择一个折衷方案，比如提供16个或32个通用寄存器，以平衡性能需求与指令编码复杂度之间的关系。
像RISC-V等一些现代ISA也通过灵活的扩展机制来解决这一问题，允许根据不同的应用场景和资源需求选择合适的寄存器组大小和其他特性。</p>
<p>/***************************************************** */</p>
<p>当今设计计算机，指令用数字的形式表示。计算机内部采用二进制形式来表示指令和数据。
数据既然可以存储在存储器中。那么是不是程序也可以，并且我们可以读写程序？</p>
<p>由此法引出存储程序 （stored- program） 的概念。</p>
<p>这是冯·诺依曼体系结构的核心特征之一，它指出程序和数据在计算机内存中是统一存储和处理的，并且都可以被CPU读取和写入。
因此，编辑器程序的源代码可以存放在存储器中，经过编译器编译成机器码后也保存在同一存储器内。
当计算机运行时，它可以依次取出指令执行，从而使计算机能够实现动态加载和执行不同程序的能力，极大地提升了计算机系统的灵活性和通用性。</p>
<p>这一革命性的设计使得计算机能够在无需硬件改动的情况下，仅通过改变存储在内存中的程序就可实现不同的计算任务，从而释放了计算机的巨大潜力，为现代信息技术的发展奠定了基础</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
