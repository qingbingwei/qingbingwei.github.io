<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 清兵卫的博客</title>
    <link>https://qingbingwei.github.io/post/</link>
    <description>Recent content in Posts on 清兵卫的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 16 Sep 2024 10:26:27 +0800</lastBuildDate><atom:link href="https://qingbingwei.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UDP客户服务器模型和UDP协议</title>
      <link>https://qingbingwei.github.io/post/udp%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B%E5%92%8Cudp%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 16 Sep 2024 10:26:27 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/udp%E5%AE%A2%E6%88%B7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B%E5%92%8Cudp%E5%8D%8F%E8%AE%AE/</guid>
      <description>socket 编程接口 对某种操作系统数据结构的抽象 （网络通信，发送信道 接收信道） 使用哪些系统调用接口来向这2个信道进行数据的 发送 接收
C/S模式 client（多 从） Server（单 主） 从设备 主动 向 主设备进行请求， 主设备接收到这个请求后，进行解析并响应
服务器先执行，在服务器机器上等待客户端的请求
一、UDP服务器编程模型 1. socket() 获取 操作系统抽象数据结构的对象 2. 主动的先执行，等待客户端的请求，客户端的请求包到达服务器，如何这个数据包正确的找到服务器的进程 pid 进程号 &amp;mdash;- 端口号 就是在服务器上，开后门 bind() 系统调用 把端口开放 3. 等待新的客户端发来请求 recvfrom
二、UDP客户端编程模型 1. socket() 获取 操作系统抽象数据结构的对象 2. bind() 不建议做 但是该填写自己的端口，发送UDP数据包，src ip:port dest ip:port bind(88991) 客户端代码会在不同的机器上运行，无法保证每个客户端都没有使用88991端口号 不调用bind，src ip:port 没有信息 为了能够将这个数据发送到网卡上，内核就会自动的选择一个当前系统没有被使用的端口号作为src 3. sendto() 向某一个IP和port上发送数据包
三、UDP协议抓包分析 UDP 从协议角度上， 只有目的端口、源端口的数据，不提供任何跟有序 无丢失的 传输提供帮助 UDP 面向数据报协议 TCP 面向连接的协议
UDP丢包 1.服务器根本就不存在（对应的端口号没有），UDP包到了网络层，网络传送给传输层，传输层没有缓存区来存这个数据，自然这个数据就丢失了 2.</description>
    </item>
    
    <item>
      <title>逻辑设计基础</title>
      <link>https://qingbingwei.github.io/post/%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 16 Sep 2024 00:11:57 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>MIPS核心子集及实现方式</title>
      <link>https://qingbingwei.github.io/post/mips%E6%A0%B8%E5%BF%83%E5%AD%90%E9%9B%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 15 Sep 2024 23:18:58 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/mips%E6%A0%B8%E5%BF%83%E5%AD%90%E9%9B%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>冯·诺依曼架构的特点： 1.存储程序 2.二进制逻辑 3.五大基本部件 注：运算器也叫数据通路 4.指令和数据共享同一总线 5.指令顺序执行
数据通路(运算器)是计算机系统中负责执行指令并处理数据的部分。 它通常是由一系列硬件组件和逻辑电路组成，负责执行算术逻辑运算、数据传输以及存储等操作。 简单来说，数据通路是指令执行的“高速公路”，负责数据在计算机内部各个部件之间的传输和处理。主要组成部分包括：
1.寄存器：用于存储临时数据和指令的硬件存储单元。 寄存器通常与CPU紧密关联，用于暂存指令、操作数以及运算结果。 2.运算单元：执行算术逻辑运算的部件，包括加法器、减法器、乘法器、除法器等。 运算单元负责对数据进行各种数学运算和逻辑操作。 3.数据选择器/多路复用器：用于选择不同的数据源或目的地，并将数据传输到指定的位置。 它可以根据控制信号选择不同的输入，将选定的数据发送到指定的输出端口。 4.数据存储器：包括随机存储器（RAM）和只读存储器（ROM），用于存储程序指令、数据以及中间结果。 存储器在数据通路中扮演重要角色，负责存储和提取数据。 5.控制逻辑：负责根据指令序列产生控制信号，控制数据通路中各个部件的操作和数据流动。 控制逻辑根据指令的操作码和地址等信息，生成适当的控制信号来调度数据通路中的操作。 6.数据总线：用于在各个硬件组件之间传输数据和控制信号的物理通道。 数据总线可以分为地址总线、数据总线和控制总线，分别用于传输地址、数据和控制信号。 综合来看，数据通路是计算机系统中执行指令并处理数据的关键部分，它负责将指令和数据从存储器中提取出来，通过运算单元进行处理，并将结果存储回存储器中。数据通路的设计和优化直接影响了计算机系统的性能和效率。
MIPS的核心子集 1.加载/存储指令: (1)lw (Load Word):从内存中加载一个32位的字到寄存器中。 (2)sw (Store Word):将一个32位的字从寄存器存储到内存中。
1加载/存储指令是MIPS架构中访问内存的主要方式，它们允许CPU从内存读取数据或将数据写入内存。 2.算术逻辑指令: (1)add (Addition):执行两个操作数的加法操作，并将结果存储到目标寄存器中。 (2)sub (Subtraction):执行两个操作数的减法操作，并将结果存储到目标寄存器中。 (3)and(Bitwise AND):执行两个操作数的按位与操作，并将结果存储到目标寄存器中。 (4)or (Bitwise OR):执行两个操作数的按位或操作，并将结果存储到目标寄存器中。 (5)slt (Set on Less Than):如果第一个操作数小于第二个操作数，则设置目标寄存器为1，否则为0。 算术逻辑指令用于执行CPU内部的数据计算和操作。 3.分支指令: (1)beq (Branch if Equal):如果两个操作数相等，则跳转到指定的标签或地址处执行。 (2)j (Jump):无条件跳转到指定的地址处执行。 分支指令用于改变程序执行的流程，实现条件跳转或无条件跳转。 MIPS指令集的设计体现了简洁和规整的原则，这使得指令的执行过程相对统一，降低了实现的复杂性。 尽管每种类型的指令（存储访问、算术逻辑、分支）的具体操作细节不同，但它们的执行过程遵循类似的结构： 1.指令获取阶段:程序计数器(PC)指向内存中即将执行的指令地址，然后从内存中取出该指令。 2.寄存器读取阶段:根据指令格式，从寄存器文件中读取一个或两个操作数。 例如，加载/存储指令可能只需要一个寄存器(存放地址)，而算术逻辑指令通常需要两个操作数。 3.ALU处理阶段:所有非跳转指令通常都会利用算术逻辑单元(ALu)进行计算。 对于存储访问指令，ALU用来计算有效内存地址;对于算术逻辑指令，ALU执行加减乘除、逻辑运算等;对于分支指令，ALU基于比较结果生成新的PC值。 4.数据通路阶段: (1)存储访问指令︰根据ALU计算出的地址访问内存，进行数据读取或写入操作。 (2)算术逻辑指令∶将ALU计算结果写回寄存器文件，更新寄存器中的值, (3)分支指令∶根据ALU的比较结果决定是否跳转，若满足条件则修改PC值，使其指向新的目标地址;否则，按照顺序执行下一条指令，即PC增加4个字节(在MIPS中，指令通常是固定长度的，每个指令占4个字节)。 </description>
    </item>
    
    <item>
      <title>虚拟机网络环境及socket概述</title>
      <link>https://qingbingwei.github.io/post/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E5%8F%8Asocket%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Fri, 13 Sep 2024 23:19:29 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E5%8F%8Asocket%E6%A6%82%E8%BF%B0/</guid>
      <description>一、Vmware虚拟机网络环境概述 虚拟机&amp;mdash;&amp;mdash;软件技术(宿主机里安装一个服务，利用这个服务来共享宿主机的资源，通过服务，虚拟化成多个独立的主机进行管理) 1．宿主机里找到这个服务 2．几种组网方式的区别 a.NAT方式 宿主机里含有一个NAT服务(网络地址转换器，模拟成路由器) a.1.宿主机里被安装了一个能够连接到NAT路由器的虚拟网卡(vmnet8)，宿主机就是通过这个网卡和虚拟机通信 a.2.虚拟机如果要访问外网，需要配置网关，网关的地址，必须是NAT路由器的LAN口IP(不能是windows的vmnet8) a.3.vmnet8这个网卡，是给宿主机专门用来访问虚拟机用的，一定不要配置网关和DNS，这个网卡不是为宿主机提供网络服务假的路由器(软件)，外网能不能上，就看宿主机能不能上网了 b.host-only 宿主机里安装了一个虚拟的交换机，为宿主机提供了vmnet1的网卡，来连接到交换机上。 一旦虚拟机网卡连接到host-only，就意味连接到了交换机，只能和vmnet1进行数据交互。因为没有路由能力，虚拟机就无法访问外网 c.桥接 虚拟机利用宿主机里实际的网卡，充当虚拟机的物理层，虚拟机利用自己的独立NAc地址，使用宿主机的物理层进行数据通信寝室里其他设备也可以直接访问到虚拟机 3.Vmware和windows的数据互通 a.vmtools就是vmware这个软件提供的一个插件，只适合同一台机器上宿主机和虚拟机的访问实验室的多台主机和服务器相连，这个插件无能为力 b.建议使用网络服务进行数据交换 c.C/S模型 client和server a.1.ssh的远程登陆协议 a.2.虚拟机里安装ssh的服务器进程 如何判断虚拟机里有没有这个服务 netstat -tuan 查看当前机器服务链接状态 只需要在本地地址中端口号为22的，只要有这一行就表示服务已安装 a.3.宿主机安装ssh的客户端进程 Mobaxterm/Xterminal
二、socket简介 应用层 用户态 利用文件描述符和系统调用，实现数据的交换 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-syscall 系统调用 名词(文件描述符) 传输层 网络层 内核态 很多条链接，每条链接如何抽象给用户态 物理接口层
文件描述符:就是一个非负整数 Linux的操作系统内，有一张表 0 内核的驱动1 1 内核的驱动2 2 内核的驱动3 3 NULL 4 NULL 必须获得这个内核抽象链接的对应的文件描述符 socket认为是一张信封，但是socket是一个大而全的一个通用接口 三、socket下的常用编程接口 socket 拿信封 bind 绑定local address</description>
    </item>
    
    <item>
      <title>浮点数乘除法</title>
      <link>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B9%98%E9%99%A4%E6%B3%95/</link>
      <pubDate>Wed, 11 Sep 2024 21:10:44 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B9%98%E9%99%A4%E6%B3%95/</guid>
      <description>浮点数乘除运算步骤类似于浮点数加、减运算步骤,两者的主要区别是: 1.加、减运算需要对阶,而对乘、除运算来说,无须这一步。 2.两者对结果的后处理步骤也一样，都包括规格化、舍入和溢出判断处理。
浮点数乘除法运算总共就4步： 尾数运算、规格化、舍入、溢出判断。 1.尾数相乘，阶码相加
尾数的乘法运算定点原码小数乘法算法。 在运算时,需要将隐藏位1还原到尾数中,并注意乘积的小数点位置。 因为x和y是规格化浮点数,所以其尾数的真值形式都是正负1.b...b。 进行尾数相乘时,符号和数值部分分开运算,符号由x和y两数符号异或得到，数值部分将两个形为1.b..的定点无符号 数进行n位数乘法运算,其结果为2n位乘积:bb.b...b,小数点应该默认在第二位和第三位之间。 阶码执行移码相加：最终得到结果的移码表示的阶数。 [Ex]移 + [Ey]移 + 2^(n-1) + 1(mod 2^n) == [Ex + Ey]移 注:除法尾数相除，阶码相减 [Ex]移 + [-[Ey]移]补 + 2^(n-1) - 1(mod 2^n) == [Ex - Ey]移 2. 尾数规格化 在得到的2n位乘积数值部分bb.b...b中,小数点左边一定至少有一个1, 可能是01、10、11三种情况：若是01,则不需要规格化;若是10或11,则需要右规一次,此时，尾数右移一位,阶码加1。 规格化后得到的尾数数值部分的形式为01.b...b小数点左边的1就是隐藏位。 对于IEEE754浮点数的乘法运算不需要进行左规处理。 除法： 商的形式：b.b...b，小数点左边可能是0,可能是1。 对于IEEE754浮点数的除法运算不需要进行右规处理。 3.尾数舍入 同加减法的舍入 4.溢出判断 在进行指数相加、右规和舍入时,要对指数进行溢出判断。右规和舍入时的溢出判断与 浮点数加减运算中的溢出判断方法相同。 而在进行指数相加时的溢出判断则要根据参与运算的操作数及结果的阶码的最高位的取值情况进行。 1.[Eb]移 全1-----&amp;gt;上溢 [Ex]移 [Ey]移 最高位是0，但是[Eb]移最高位是1-------&amp;gt;上溢 2.[Eb]移 全0-----&amp;gt;下溢 [Ex]移 [Ey]移 最高位是1，但是[Eb]移最高位是0-------&amp;gt;下溢 注:相加 除法: 左规时的溢出判断与浮点数加减运算中的溢出判断方法相同。 而在进行指数相加时的溢出判断则要根据参与运算的操作数及结果的阶码的最高位的取值情况进行。 1.[Eb]移 全1-----&amp;gt;上溢 [Ex]移 最高位0 [Ey]移 [Eb]移最高位是1------&amp;gt;上溢 2.</description>
    </item>
    
    <item>
      <title>浮点数加减法</title>
      <link>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/</link>
      <pubDate>Wed, 11 Sep 2024 21:10:38 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/</guid>
      <description>阶数不一样，要把阶数调整为相同（往大的调整）之后再相加。 结果的尾数为两个尾数之和，阶数为调整之后的阶数。
浮点数加减法运算总共就5步： 对阶、尾数运算、规格化、舍入、溢出判断。
1.对阶：使x和y的阶码相等,以使尾数可以相加减。 原则:小阶向大阶看齐,阶小的那个数的尾数右移(算术右移),右移的位数等于两个阶(指数)的差的绝对值。 大多数机器采用IEEE754标准来表示浮点数，阶数为移码表示因此,对阶时需要进行移码减法运算，并且尾数右移时按原码小数方式右移,符号位不参加移位,数值位要将隐含的一位1右移到小数部分,空出位补0。 为了保证运算的精度,尾数右移时，低位移出的位不要丢掉,应保留并参加尾数部分的运算。 注:[Ex]移 - [Ey]移 = [Ex - Ey]补 tips:自己手算时直接用真值算即可 2.尾数加减： 对阶后两个浮点数的指数相等，可以进行对阶后的尾数相加减。 因为IEEE754采用定点原码小数表示尾数，所以,尾数加减实际上是定点原码小数的加减运算（与定点加减法一样）。 因为IEEE754浮点数尾数中有一个隐藏位，所以,在进行尾数加减时,必须把隐藏位还原到尾数部分。 运算过程中,在尾数右移时保留的附加位也要参加运算。 因此,在用定点原码小数进行尾数加减运算时,在操作数的高位部分和低位部分都需要进行相应的调整。 进行加减运算后的尾数不一定是规格化的,因此,浮点数的加、减运算需要进一步进行规格化处理。 3.尾数规格化：左规 右规 保证最高有效位为1 右规：尾数右移一位,阶码加1。尾数右移时,最高位1被移到小数点前一位作为隐藏位,最后一位移出时,要考虑舍入。 左规：数值位逐次左移,阶码逐次减1,直到将第一位1(隐藏位)移到小数点左边。 4.尾数的舍入处理：在对阶和尾数右规时,可能会对尾数进行右移,为保证运算精度,一般将低位移出的位保留下来,参加中间过程的运算,最后再将运算结果进行舍入,还原表示成IEEE 754格式。 （1）保留多少附加位才能保证运算的精度? IEEE754标准规定,所有浮点数运算的中间结果右边都必须至少额外保留两位附加位。 这两位附加位中,紧跟在浮点数尾数右边那一位为保护位或警戒位(guard) ,用以保护尾数右移的位;紧跟保护位右边的是舍入位(round) ,左规时可以根据其值进行舍入。 在IEEE 754标准中,为了更进一步提高计算精度,在保护位和舍入位后面还引入了额外的一个数位,称为粘位(sticky),只要舍入位的右边有任何非0数字,粘位就被置1;否则,粘位被置0。 （2）IEEE754标准的舍入方法： a.0舍1入。 b.朝+∞方向舍入。总是取右边最近可表示数,也称为正向舍入或朝上舍入。 c.朝-∞方向舍入。总是取左边最近可表示数,也称为负向舍入或朝下舍入。 d.朝0方向舍入。直接截取所需位数,丢弃后面所有位，也称为截取、截断或恒舍法。 这种舍入处理最简单。对正数或负数来说，都是取更靠近原点的那个可表示数,是趋向原点的舍入,因此,又称为趋向零舍入。 5.溢出判断 在进行尾数规格化和尾数舍入时,可能会对结果的阶码执行加、减运算。 因此,必须考虑结果的指数溢出问题： (1)若一个正指数超过了最大允许值(127或1023),则发生指数上溢，机器产生异常,也有的机器把结果置为+∞(数符为0时)或-∞(数符为1时)后,继续执行下去。 (2)若一个负指数超过了最小允许值(-149或-1074),则发生指数下溢,此时,一般把结果置为+0(数符为0时)或-0(数符为1时),也有的机器引起异常。 溢出判断实际上是在上述尾数规格化和尾数舍入过程中进行的，只要涉及阶码求和/差，就可以在阶码运算部件中直接用溢出判断电路来实现。涉及阶码求和/差的情况有以下情况： (1)右规和尾数舍入。一个数值很大的尾数舍入时,可能因为末尾加1而发生尾数溢出,此时,可以通过右规来调整尾数和阶。 右规时阶加1,导致阶增大，因此需要判断是否发生了指数上溢。只有当调整前的阶码为1111110,加1后,才会变成1111111而发生上溢;如果右规前阶码已经是1111111,则右规后变为0000000,因而会造成判断出错。 所以,右规前应先判断阶码是否为全1,若是,则不需右规,直接置结果为指数上溢;否则，阶码加1,然后判断阶码是否为全1来确定是否指数上溢。 (2)左规。左规时数值位逐次左移,阶码逐次减1,所以左规使阶码减小,故需判断是否发生指数下溢。 其判断规则与指数上溢类似,首先判断阶码是否为全0,若是,则直接置结果为指数下溢;否则,阶码减1,然后判断阶码是否为全0来确定是否指数下溢。 从浮点数加、减运算过程可以看出,浮点数的溢出并不以尾数溢出来判断，尾数溢出可以通过右规操作得到纠正。 运算结果是否溢出主要看结果的指数是否发生了上溢,因此是由指数上溢来判断的。 </description>
    </item>
    
    <item>
      <title>网络层概述</title>
      <link>https://qingbingwei.github.io/post/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 10 Sep 2024 20:07:23 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/</guid>
      <description>⽹际层的设计选择 ⽹络层的主要任务 1.就是将分组从源主机经过多个⽹络和多段链路传输到⽬的主机 2.可以将该任务划分为分组转发和路由选择两种重要的功能。
⽹络层向上层提供两种服务 1.⾯向连接的虚电路服务 (1)核⼼思想是“可靠通信应由⽹络⾃身来保证”。 (2)通信双⽅沿着已建⽴的虚电路发送分组。 注:很多⼴域分组交换⽹都使⽤⾯向连接的虚电路服务。 例如，曾经的X.25和逐渐过时的帧中继（Frame Relay，FR）、异步传输模式（Asynchronnous Transfer Mode，ATM）。 2.⽆连接的数据报服务 (1)核⼼思想是“可靠通信应由⽤户主机来保证”。 (2)不需要建⽴⽹络层连接。 (3)每个分组可⾛不同的路径，因此，每个分组的⾸部都必须携带⽬的主机的完整地址。 (4)通信结束后，没有需要释放的连接。 注:这种通信⽅式所传送的分组可能误码、丢失、重复和失序。 由于⽹络⾃身不提供端到端的可靠传输服务，这就使得⽹络中的路由器可以做得⽐较简单，⼤⼤降低了⽹络造价。 ⽹络层协议 IPv4数据报格式 1.在TCP/IP标准中，各种数据格式常常以32⽐特（即4字节）为单位来描述。 2.⽹络层数据包（IP数据包，Packet）由⾸部、数据2部分组成 (1)数据：很多时候是由传输层传递下来的数据段（Segment）
IPv4数据报⾸部协议 1.版本(Version) ⻓度为4个⽐特，⽤来表示IP协议的版本。 (1)0b0100 : IPv4 (2)0b0110 : IPv6 2.⾸部⻓度(Header Length) 占4个⽐特，乘以4才是最终⻓度，⽤来表示IPv4数据报的⾸部⻓度。 (1)最⼩取值为⼆进制的0101，20字节 (2)最⼤取值为⼆进制的1111，60字节。 3.可选字段 (1)⻓度从1字节到40字节不等，⽤来⽀持排错、测量以及安全措施等功能。 (2)虽然可选字段增加了IPv4数据报的功能，但这同时也使得IPv4数据报的⾸部⻓度成为可变的，这就增加了因特⽹中每⼀个路由器处理IPv4数据报的开销。 4.填充 (1)当⾸部⻓度（20字节固定部分+可变部分）的⻓度不是4字节整数倍时，填充相应数量的全0字节，以确保IPv4数据报的⾸部⻓度是4字节的整数倍。 (2)使⽤全0进⾏填充。 5.区分服务(Differentiated Services Field) (1)占8个⽐特 (2)可以⽤于提⾼⽹络的服务质量 6.总长度(Total Length) (1)占16个⽐特 (2)⾸部 + 数据的⻓度之和，最⼤65535 7.标识、标志、⽚偏移 注:由于帧的数据不能超过1500字节，所以过⼤的IP数据包，需要分成⽚（fragments）传输给数据链路层。且每⼀⽚都有⾃⼰的⽹络层⾸部（IP⾸部）。 (1)标识（Identification）： a.占16⽐特 b.数据包的ID，当数据包过⼤进⾏分⽚时，同⼀个数据包的所有⽚的标识都是⼀样的 c.有⼀个计数器专⻔管理数据包的ID，每发出⼀个数据包，ID就加1 (2)标志（Flags）： a.占3⽐特 b.最低位（More Fragment，MF） i.MF=1表示本分⽚后⾯还有分⽚ ii.MF=0表示本分⽚后⾯没有分⽚ c.中间位（Don’t Fragment，DF） i.</description>
    </item>
    
    <item>
      <title>浮点数表示</title>
      <link>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Mon, 09 Sep 2024 20:21:39 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/</guid>
      <description>在二进制系统中，科学计数法通常被称为浮点表示法，并且是计算机科学中用于存储和计算实数的标准方法。
这种表示方式同样由两部分构成：
1.尾数： 在二进制科学计数法中，尾数通常是小数形式的二进制数，并且在标准化的情况下，它总是从 1.xxxxxx开始，这里的每个 x是0或1。 2.指数： 指数是一个以某个基数（通常为2）为底的整数，表示基数的小数点相对于固定点的位置偏移了多少位。 在计算机中任意一个二进制实数表示： X = (-1)^S * M * R^E 其中： S : sign，取值0或1，确定符号。 R ：radix，基数/进制。二进制下为2。 M ：mantissa，尾数。是一个二进制定点小数（0.1b&amp;hellip;bbb），其位数反映了X的有效位数，决定了精度。 E ：exponent， 阶/指数。是一个二进制定点整数，其位数决定X的表示范围，其值确定小数点的位置。
存储时存储 S M E三个字段即可，其中阶码E常用补码或移码表示，尾数M常用原码或补码表示。 移码 注:常用来表示浮点数的阶码。 移码就是在真值X上加上一个常数(偏置值)，通常这个常数取2^n，相当于X在数轴上向正方向偏移了若干单位，这就是“移码”一词的由来。
n+1位移码的特点： 1.零的表示唯一：[+0]移=2n+0=100...00 [-0]移=2n-0=100...00 (n个0) 2.一个真值的移码和补码仅差一个符号位，所以[x]补的符号位取反得到[x]移 所以在 原 反 补码中“ 0正1负” ；移码中 “0负1正”。-----&amp;gt;注:前提是偏置值取2^n 3.移码全0时，对应真值的最小值-2^n;移码全1时，对应真值的最大值2^n-1。-----&amp;gt;注:前提是偏置值取2^n 4.移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。 IEEE 754标准 IEEE 754标准规定了四种表示浮点数值的方式： 单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。 其中，只有32位模式有强制要求，其他都是选择性的。
32位 单精度格式 单精度格式中包含1位符号s、8位阶码e和23位尾数f 尾数用原码表示。阶码用移码表示。 尾数： 对于规格化的二进制浮点数，尾数的最高位总是1,为了能使尾数多表示一位有效位，将这个1隐藏，称为隐藏位，因此23位尾数实际表示了24位有效数字。 IEEE 754规定隐藏位1的位置在小数点之前，即1.xxx...xxx的尾数形式。 例如，(12)10= (1100)2,将它规格化后结果为1.1x2^3,其中整数部分的“1”将不存储在23位尾数内。 阶码： 阶码用移码表示，偏置值为2^(n-1)-1。因此，单精度和双精度浮点数的偏置常数分别为127和1023。一些特殊的位序列(如阶码为全0或全1)有其特别的解释。 以IEEE 754标准中的单精度浮点数为例，其阶码部分有8位，能够表示的范围通常是-127到128，但是实际可用的范围是从-126到127，因为全0和全1的指数值有特殊的含义。 IEEE 754中对数进行了以下分类： 1.</description>
    </item>
    
    <item>
      <title>数电</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E7%94%B5/</link>
      <pubDate>Fri, 06 Sep 2024 10:21:06 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E7%94%B5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>NAT技术和链路层概述</title>
      <link>https://qingbingwei.github.io/post/nat%E6%8A%80%E6%9C%AF%E5%92%8C%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Thu, 05 Sep 2024 22:24:06 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/nat%E6%8A%80%E6%9C%AF%E5%92%8C%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0/</guid>
      <description>注:对于因特网骨干网设备(路由器),不允许转发私网IP
因特⽹的接⼊⽅式 1.电话线⼊户 (1)平时说的ADSL电话拨号上⽹，⾮对称数字⽤户线路，提供上、下⾏不对称的传输带宽。 (2)需要提供猫（Modem）,调制解调器，进⾏数字信号和模拟信号的转换。 2.光纤⼊户 (1)光猫（optical modem），光调制解调器，进⾏数字信号和光信号的转换
公⽹和私⽹ 1.公⽹（public） (1)Internet上路由器中只有到达公⽹的路由表，没有到达私⽹的路由表 (2)公⽹IP由因特⽹信息中⼼（Internet Network Information Center，Inter NIC）统⼀分配和管理 (3)ISP需要向Inter NIC申请公⽹IP 2.私⽹（private） (1)主要⽤于局域⽹ (2)A类：10.0.0.0/8，1个A类⽹络 (3)B类：172.16.0.0/16 ~ 172.31.0.0/16，16个B类⽹络 (4)C类：192.168.0.0/24 ~ 192.168.255.0/24，256个C类⽹络
NAT技术 1.私⽹IP访问Internet需要进⾏NAT转换为公⽹IP (1)NAT（Network Address Translation） (2)这⼀步可以由路由器来完成 2.NAT特点 (1)可以节约公⽹IP资源 (2)会隐藏内部真实IP 3.NAT分类 (1)静态转换，⼿动配置NAT映射表 (2)动态转换，定义外部地址池，动态随机转换，⼀对⼀转换 (3)PAT（Port Address Translation），多对⼀转换 a.采⽤端⼝多路复⽤技术
/************************************************************ */
数据链路层概述 链路（Link）是指从⼀个节点到相邻节点的⼀段物理线路（有线或⽆线），⽽中间没有任何其他的交换节点。 1.数据链路（Data Link）是基于链路的。当在⼀条链路上传送数据时，除需要链路本身，还需要⼀些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 2.不同类型的数据链路，所⽤的通信协议可能是不同的 (1)⼴播信道：CSMA/CD协议（⽐如同轴电缆、集线器等组成的⽹络）&amp;mdash;-&amp;gt;几乎淘汰 (2)点对点信道：PPP协议（⽐如2个路由器之间的信道） 3.计算机中的⽹络适配器（俗称⽹卡）和其相应的软件驱动程序就实现了这些协议。⼀般的⽹络适配器都包含了物理层和数据链路层这两层的功能。
数据链路层的三个问题 1.封装成帧 (1)帧（Frame）的数据部分，就是⽹络层传递下来的数据包（IP数据包，Packet） (2)最⼤传输单元MTU（Maximum Transfer Unit） a.每⼀种数据链路层协议都规定了所能传送的帧数据⻓度上限 b.以太⽹的MTU为1500字节(最小传输单元为46字节)&amp;mdash;&amp;mdash;&amp;gt;针对数据部分 c.以太⽹V2的MAC帧最小为64字节 (3)以太⽹V2的MAC帧 (4)PPP帧 (5)封装成帧是指数据链路层给上层交付下来的协议数据单元PDU添加⼀个⾸部和⼀个尾部，使之成为帧。 a.帧的⾸部和尾部中包含有⼀些重要的控制信息。 b.帧⾸部和尾部的作⽤之⼀就是帧定界。 c.并不是每⼀种数据链路层协议的帧都包含有帧定界标志 2.透明传输 (1)透明传输是指数据链路层对上层交付下来的协议数据单元PDU没有任何限制，就好像数据链路层不存在⼀样。 a.</description>
    </item>
    
    <item>
      <title>定点数除法</title>
      <link>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95/</link>
      <pubDate>Thu, 05 Sep 2024 17:49:27 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95/</guid>
      <description>m位数 / n位数 = (m - n + 1)位数&amp;mdash;-&amp;gt;最多位数 注:(m&amp;gt;=n)
二进制除法的运算，本质上相当于看最多几个除数累加能逼近于被除数。 （加上余数后就等于被除数）。
定点数除法(均使用试商法，即恢复余数法，但计算机实际使用不恢复余数法) 1.无符号数除法 无符号数除法运算用减法和移位运算来实现
(1)先对除数末尾补零到与被除数位数对齐（通过左移实现），左移一位代表乘2，右移一位代表除2； (2)判断大小，确定该位商1还是商0。 计算机不可能提前知道除数是否小于被除数。 先让被除数减去除数，若结果为&amp;gt;=0，说明被除数&amp;gt;=除数，直接商1。 若结果为负数，说明被除数&amp;lt;除数，说明不能减，则先恢复被除数的原值，再商0。 比如32（n）位的除法：被除数64(2n)位，除数32(n)位。 先把除数左移32位，然后开始同十进制类似计算。 因为二进制只有0和1所以退化为减法，先减去被除数，如果结果为负，则当前位商置为0，再加回来， 如果结果为正，则当前位商为1，除数右移一位，继续如上做减法。 循环n+1次，商的位数满足为止。 2.有符号数除法 (1)原码表示(符号位与数值位分开求) 1.符号位:被除数和除数的符号位“异或”运算得到 2.数值位:被除数和除数的数值位执行 “无符号除法” 注:余数符号位与被除数符号位相同 (2)补码表示(符号位参与运算) 1.符号位参与运算，除数和被除数，余数和商(异号相除较特殊)均用补码表示。 2.其他过程与无符号除法一致，区别在于判断是否可以减时，不能直接相减看结果的符号位，要按分情况来看。 注:如果同号相除得商；异号相除，将商的负数求补(带符号位) </description>
    </item>
    
    <item>
      <title>内存管理</title>
      <link>https://qingbingwei.github.io/post/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 05 Sep 2024 09:15:33 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>为什么需要内存管理？ 不管存储器有多大，程序大小的增长速度比内存容量的增长速度要快的多
无存储器抽象 1.最简单的存储器抽象是无存储器 2.早期的大型机、小型机、个人计算机都是直接操控内存 3.这种情况下的计算机不可能会有两个应用程序同时在内存中
在没有存储器抽象的系统中实现并行性一种方式是使用多线程来编程。 注:人们通常希望能够在同一时间内运行没有关联的程序，而这正是线程抽象所不能提供的。 把当前内存中所有内容保存到磁盘文件中，然后再把程序读入内存即可 物理内存暴露的缺点 1.如果用户程序可以寻址内存的每个字节，它们就可以很容易的破坏操作系统 2.想要运行多个程序是很困难的 3.如果要使多个应用程序同时运行在内存中，必须要解决两个问题：保护和重定位。 一种存储器抽象：地址空间 1.进程可以用来寻址内存的地址集 2.每个进程都有它自己的地址空间，独立于其他进程的地址空间。 3.最简单的办法是使用动态重定位(dynamic relocation)技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。 (1)基址寄存器和变址寄存器 (2)存储数据内存的起始位置和存储应用程序的长度 4.如果计算机的物理内存足够大来容纳所有的进程，那么之前提及的方案或多或少是可行的。
交换技术 把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。
逻辑层面操作系统把数据分成不同的段来存储 代码段（codesegment/textsegment） 数据段（datasegment） 存储初始化好的静态和全局变量 bss段（bsssegment） 存储未初始化的静态和全局变量 rodata段 栈（stack） 堆（heap） 内存增长处理方式 1.如果一个进程与空闲区相邻，那么可把该空闲区分配给进程以供其增大。 2.如果进程相邻的是另一个进程，就会有两种处理方式：要么把需要增长的进程移动到一个内存中空闲区足够大的区域，要么把一个或多个进程交换出去，以变成生成一个大的空闲区。 3.如果一个进程在内存中不能增长，而且磁盘上的交换区也满了，那么这个进程只有挂起一些空闲空间（或者可以结束该进程） 空闲内存的管理 1.位图 2.空闲列表 按照地址顺序在链表中存放进程和空闲区 1.首次适配 (1)内存管理器会沿着段列表进行扫描 (2)首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。 2.下次适配 (1)记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索 (2)性能略低于首次匹配 3.最佳适配 (1)试图找出最接近实际需要的空闲区 4.最差适配 (1)总是分配最大的内存区域 5.为进程和空闲区维护各自独立的链表以提高性能 6.快速匹配 (1)为那些常用大小的空闲区维护单独的链表 虚拟内存 基本思想 (1)每个程序都有自己的地址空间 (2)这个地址空间被划分为多个称为页面(page)的块。 (3)虚拟地址是对基址寄存器和变址寄存器的一种描述
分页技术 1.在任何一台计算机上，程序会引用使用一组内存地址 2.地址可以通过索引、基址寄存器、段寄存器或其他方式产生 3.这些程序生成的地址被称为虚拟地址(virtual addresses) 并形成虚拟地址空间(virtual address space) 存在映射的页如何映射 1.虚拟地址空间由固定大小的单元组成，这种固定大小的单元称为 页(pages)。 2.物理内存中也有固定大小的物理单元，称为 页框(page frames)。 3.</description>
    </item>
    
    <item>
      <title>超网和路由</title>
      <link>https://qingbingwei.github.io/post/%E8%B6%85%E7%BD%91%E5%92%8C%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Wed, 04 Sep 2024 19:59:09 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%B6%85%E7%BD%91%E5%92%8C%E8%B7%AF%E7%94%B1/</guid>
      <description>判断是⼦⽹还是超⽹ 1.先判断该⽹段的类型，是A类、B类、C类⽹络 (1)默认A类⼦⽹掩码的位数是8，B类⼦⽹掩码的位数是16，C类⼦⽹掩码的位数是24 2.然后判断⼦⽹掩码的位数 (1)⽐默认⼦⽹掩码多，就是⼦⽹ (2)⽐默认⼦⽹掩码少，就是超⽹
路由 路由的作用 1.在不同⽹段之间转发数据，需要有路由器的⽀持 2.默认情况下，路由器只知道跟它直连的⽹段，⾮直连的⽹段需要通过静态路由、动态路由告诉它 (1)静态路由 a.管理员⼿动添加路由信息 b.适⽤于⼩规模⽹络 (2)动态路由 a.路由器通过路由选择协议（⽐如RIP、OSPF）⾃动获取路由信息 b.适⽤于⼤规模⽹络
数据包的传送过程 1.在数据包的传送过程中，数据包的源IP地址和⽬的IP地址保持不变； 2.在数据包的传送过程中，数据包的源MAC地址和⽬的MAC地址逐链路（或逐⽹络）改变。 </description>
    </item>
    
    <item>
      <title>定点数乘法</title>
      <link>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95/</link>
      <pubDate>Wed, 04 Sep 2024 16:52:07 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95/</guid>
      <description>m位数 * n位数 = (m + n - 1)位数&amp;mdash;-&amp;gt;最少位数 m位数 * n位数 = (m + n)位数&amp;mdash;-&amp;gt;最多位数
定点数乘法 1.无符号数乘法 无符号数乘法运算用加法和移位运算来实现 2.有符号数乘法 (1)原码表示(符号位与数值位分开求) 1.乘积的符号位由两个乘数的符号位进行“异或”运算得到 2.乘积的数值位为两个乘数的绝对值之积，即执行无符号数乘法 注:在硬件实现中，乘法运算用加法和移位运算来实现
假设我们实现4位 X 4位 = 8位的乘法器，那么： （1）需要一个8位的移位寄存器保存被乘数，他有一个左移的信号输入。 （2）需要一个8位的乘积寄存器，用来保存运算的结果。 （3）移位寄存器和乘积寄存器需要进行加法运算，所以需要一个8位的加法器，相加之后存放到乘积寄存器中。 （4）需要一个4位的乘数寄存器，同时将乘数寄存器的最低位连接右移信号，右移信号除了控制移位寄存器移位，还要控制是否进行加法运算和是否允许乘积寄存器保存当前的结果。 最后还需要控制自身是否右移位。 (2)补码表示(符号位参与运算) 在有符号数的补码乘法运算中，我们需要将被乘数和乘数先转化为补码进行乘法运算。 注:运算过程中的所有数据均以补码形式呈现。 符号位也参加运算，在运算过程中要考虑符号位乘上被乘数之后的部分积是正数还是负数。 注:位数不足时用最高位(即符号位)补齐位数 注:乘数符号位为1时，计算时将符号位看作-1与被乘数进行计算，得到被乘数相反数的补码 以上是手动计算补码乘法的过程。 计算机一般采用Booth算法（补码一位乘法）进行补码乘法运算，采用相加和相减操作计算补码数据的乘积。 </description>
    </item>
    
    <item>
      <title>IP地址分类管理</title>
      <link>https://qingbingwei.github.io/post/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 03 Sep 2024 11:04:25 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</guid>
      <description>实际上 IP 不会以主机的个数来配置的，⽽是根据设备上的 ⽹卡(NIC) 进⾏配置， 每⼀块⽹卡都会设置⼀个或者多个 IP 地址，⽽且通常⼀台路由器会有⾄少两块⽹卡， 所以可以设置两个以上的 IP 地址，所以主机的数量远远达不到 43 亿。
IPv4地址的表示⽅法
IPv4地址由因特⽹名字和数字分配机构（Internet Corporation for Assigned Names andNumbers，ICANN）进⾏分配。 1.我国⽤户可向亚太⽹络信息中⼼（Asia Pacific Network Information Center，APNIC）申请IP地址，需要缴纳相应的费⽤，⼀般不接受个⼈申请。 2.2011年2⽉3⽇，因特⽹号码分配管理局（Internet Assigned Numbers Authority，IANA）（由ICANN⾏使职能）宣布，IPv4地址已经分配完毕。 3.我国在2014⾄2015年也逐步停⽌了向新⽤户和应⽤分配IPv4地址，同时全⾯开展商⽤部署IPv6 1.IPv4地址的分类编址⽅法 早期为了分类管理，采⽤了下表的固定⽅式进⾏分类管理 8位 24位 A类地址: 0 网络号 + 主机号 16位 16位 B类地址:10网络号 + 主机号 24位 8位 C类地址:110网络号 + 主机号
D类地址:1110 + 多播地址 E类地址:1111 + 保留地址 单播 A &amp;mdash;&amp;mdash; B 广播 网络号内进行全部通知 组播/多播 c1 c2 c3 c4 c1 c4 add 组播IP地址</description>
    </item>
    
    <item>
      <title>定点数加减法</title>
      <link>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/</link>
      <pubDate>Mon, 02 Sep 2024 18:35:49 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%AE%9A%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/</guid>
      <description>定点数：是一种表示固定小数位数的数值类型，通常表示为一个有符号的整数部分和一个小数部分。
定点小数：如果是有符号数，约定小数点在符号位的后面，如果是无符号数，约定小数点在最前边。 定点小数的是类似：0.XXXXXX这个形式 定点整数：约定小数点在最后边。 定点整数是类似：XXXXXX.0这种形式 浮点数：相当于生活中的科学计数法，小数点的位置是可以不断变化的；且小数点位置的变化，不会影响表达式整体数值的大小。 IEEE 754是由IEEE制定的有关浮点数的工业标准，被广泛采用。
在计算机中,通常是用定点数来表示整数和纯小数,分别称为定点整数和定点小数。 对于既有整数部分、又有小数部分的数，一般用浮点数表示。
定点数加减法 1.无符号数 逢二进一 2.有符号数 (1)原码表示 注:符号位不参与运算 加法运算:同号相加，符号位不变，数值位相加。 减法运算:先判断两个数大小确定结果的符号，绝对值大的减去绝对值小的。 (2)补码表示 注:符号位参与运算 加法运算:补码直接相加 减法运算:被减数的补码+减数相反数的补码
技巧:把X补码(带符号位)取反+1 ----&amp;gt; -X补码 技巧:将X原码最右侧一个1前面一直到符号位(不含符号位)直接取反----&amp;gt;X补码 注:在计算机中，有符号数一般采用补码表示。重点关注补码运算。 /*********************************************************** */
加法是一种基本且频繁使用的操作。现代计算机在硬件层面上实现加法操作，通常是通过加法器电路来完成的。 加法器会接收两个二进制数作为输入，然后按照二进制加法规则进行逐位相加，同时处理可能出现的进位。
减法，虽然其基本原理与手动计算中的减法相似，但在计算机内部实现时，通常会转换为加法来执行。 这是因为计算机内部的电路更擅长执行加法操作，而减法操作可以通过取反和加法的组合来实现。
虽然从原理上看，补码减法是通过取反和加法实现的，但在实际的计算机硬件中，这个过程通常是自动且高效地完成的，无需程序员显式地进行取反和加法的操作。 程序员在编写代码时，只需要使用减法运算符（如“-”），然后计算机硬件和操作系统会自动处理底层的细节。
/*********************************************************** */
一般情况下,用一个专门的算术逻辑部件(ALU)来完成基本逻辑运算和定点数加减运算, 各类定点乘除运算和浮点数运算则可利用加法器或 ALU 和移位器来实现。 ALU 的核心部件是加法器。 注:ALU在CPU中
算术逻辑单元（Arithmetic Logic Unit，简称ALU）是计算机处理器内部的一个核心组件，负责执行基本的算术和逻辑运算。 它是一个能够处理二进制数据并进行快速计算的硬件电路块。 在功能上，ALU主要包括以下几个方面： 1.算术运算 2.逻辑运算 3.比较运算 4.移位运算 5.其他复合运算
加法器是计算机中的一种数位(字)电路，用于执行数字的加法计算。 在电子学中，加法器常用于各种数值的表示和计算，特别是在二进制运算中。 在计算机和一些处理器中，加法器被运用于算术逻辑单元ALU中，或者处理器的其他部分，如计算地址、执行加减操作等类似功能。 因此，加法器是算术逻辑单元(ALU)中的一个重要部件。
/************************************************************* */
补码定点数加减溢出： 正数+正数=负数&amp;mdash;-&amp;gt;正溢出 负数+负数=正数&amp;mdash;-&amp;gt;负溢出
溢出检测方法：
1.和的符号位与两个加数的符号位不同
X+Y=Z
Xs Ys Zs(符号位) 0 0 1&amp;mdash;&amp;gt;溢出 1 1 0&amp;mdash;&amp;gt;溢出 V=1 溢出 V=0 不溢出</description>
    </item>
    
    <item>
      <title>MAC地址和ARP</title>
      <link>https://qingbingwei.github.io/post/mac%E5%9C%B0%E5%9D%80%E5%92%8Carp/</link>
      <pubDate>Sun, 01 Sep 2024 11:21:32 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/mac%E5%9C%B0%E5%9D%80%E5%92%8Carp/</guid>
      <description>MAC地址（Media Access Control Address） 每⼀个⽹卡都有⼀个6字节（48bit）的MAC地址，MAC 地址的结构如下： 注:全球唯⼀，固化在⽹卡的ROM中，由IEEE802标准规定 前3字节：OUI组织唯⼀标识符，由IEEE的注册管理机构分配给⼚商 后3字节：⽹络接⼝标识符，由⼚商⾃⾏分配
MAC地址获取 当不知道对⽅主机的MAC地址时，可以通过发送ARP⼴播获取对⽅的MAC地址 1.获取成功后，会缓存IP地址、MAC地址的映射信息，俗称：ARP缓存 2.通过ARP⼴播获取的MAC地址，属于动态（dynamic）缓存，存储时间⽐较短（默认是2分钟），过期就⾃动删除 相关命令 arp -a [主机地址]： 查询ARP缓存 arp -d [主机地址]： 删除ARP缓存 arp -s 主机地址 MAC地址：增加⼀条缓存信息（这是静态缓存，存储时间较久） ARP是什么 ARP 协议的全称是 Address Resolution Protocol(地址解析协议)，它是⼀个通过⽤于实现从 IP 地址到 MAC 地址的映射，即询问⽬标 IP 对应的 MAC 地址 的⼀种协议。 注: ARP 协议在 IPv4 中极其重要。 ARP缓存 通过 ARP 缓存，降低了⽹络流量的使⽤，在⼀定程度上防⽌了 ARP 的⼤量⼴播。 ⼀般来说，发送过⼀次 ARP 请求后，再次发送相同请求的⼏率⽐较⼤，因此使⽤ ARP 缓存能够减少 ARP 包的发送， 除此之外，不仅仅 ARP 请求的发送⽅能够缓存 ARP 接收⽅的 MAC 地址，接收⽅也能够缓存 ARP 请求⽅的 IP 和 MAC 地址 RARP(基本淘汰) 与 ARP 相对的，RARP(Reverse Address Resolution Protocol) 是将 ARP 反过来， 从 MAC 地址定位 IP 地址的⼀种协议，将打印机服务器等⼩型嵌⼊式设备接⼊⽹络时会使⽤到。 注:⽬前被BOOTP、DHCP所取代。 </description>
    </item>
    
    <item>
      <title>计算机组网模型</title>
      <link>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BD%91%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 24 Aug 2024 23:48:55 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BD%91%E6%A8%A1%E5%9E%8B/</guid>
      <description>计算机之间的连接⽅式 1.两台计算机的互联 ⽹线直连 需要⽤交叉线（不是直通线） 2.多台计算机的互联（旧式） 同轴电缆 连接模型，左右扩散 连接特点： 1.半双⼯通信、容易冲突 2.不安全、⼀旦某段线路出现问题，整个通信⽹络都会瘫痪
注: 通信模型中: 1.单工:发送端、接收端设备只具备一种能力 2.全双工:发送端、接收端设备具备两种能力，信道有两根，同时可以满足收发 3.半双工:发送端、接收端设备具备两种能力，但是信道只有一根，同时只能满足一个通信过程(对讲机) 3.多台计算机的互联 --- 集线器（Hub） 集线器有多个接⼝，接⼝的类型是RJ-45。⼀个接⼝收到数据后会发给其它的全部接⼝。 集线器⼯作在物理层，类似于⼀个多接⼝的转发器，收到什么就转发什么，⼀个接⼝收到会转发给其它的全部接⼝。 连接特点： 1.半双⼯通信、容易发⽣冲突 2.不安全、跟同轴电缆⼀样，没有记录存储能⼒，但某两个节点出现问题，不影响其他节点 缺点： 1.如果有1000台设备⽤多集线器连接，那么1台主机发送的数据，虽然最后只有⼀个主机来处理这个数据包，但会被发送到999台主机，对整个⽹络链路的占⽤率会⾮常⾼。 4.多台计算机的互联 --- ⽹桥（Bridge） ⽹桥⼜叫做桥接器，⼯作在数据链路层，是⼀个⼆层设备。 ⽹桥能够互连两个采⽤不同传输介质与不同传输速率的⽹络，但是⽹桥需要互连的⽹络在数据链路层以上采⽤相同的协议。 ⽹桥可以分隔两个⽹络之间的通信量，对收到的帧根据其MAC帧的⽬的地址进⾏转发和过滤。 当⽹桥收到⼀个帧时，并不是向所有的接⼝转发此帧，⽽是根据此帧的⽬的MAC地址，查找⽹桥中的地址表，然后确定将该帧转发到哪⼀个接⼝，或者是把它丢弃(即过滤)。 特点： ⽹桥可以通过⾃学习得知每侧接⼝的MAC地址，从⽽起到隔绝冲突域的作⽤ 5.多台计算机的互联 --- 交换器（Switch） 相当于集线器+⽹桥，接⼝更多的⽹桥、全双⼯通信，⽐集线器安全。 6.多台计算机的互联 --- 路由器（Router） 之前的多台计算机互联，连接的设备必须在同⼀⽹段，处在同⼀⼴播域。 特点: 1.可以在不同⽹段之间转发数据 2.隔绝⼴播域 注: 主机发送数据之前，⾸先会判断⽬标主机的IP地址跟它是否在同⼀个⽹段： 1&amp;gt; 同⼀个⽹段：ARP⼴播，查找MAC，通过交换机、集线器传递数据 2&amp;gt; 不在同⼀个⽹段：通过路由器转发数据，主机向⽹关发送数据 </description>
    </item>
    
    <item>
      <title>32位立即数与寻址</title>
      <link>https://qingbingwei.github.io/post/32%E4%BD%8D%E7%AB%8B%E5%8D%B3%E6%95%B0%E4%B8%8E%E5%AF%BB%E5%9D%80/</link>
      <pubDate>Sat, 24 Aug 2024 20:52:50 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/32%E4%BD%8D%E7%AB%8B%E5%8D%B3%E6%95%B0%E4%B8%8E%E5%AF%BB%E5%9D%80/</guid>
      <description>在MIPS架构中，许多包含立即数字段的指令格式只预留了16位的空间来存放立即数。那如果使用32位的立即数该怎么办呢？
这时就需要采用特殊的编码方式来加载或存储32位的常数值以及使用完整的32位地址，需要采用两条指令来实现：
1.lui（Load Upper Immediate）：将最高16位的立即数载入到目标寄存器的高16位，同时低16位清零。 2.ori（OR Immediate）或addi（Add Immediate）：将剩余的低16位立即数与前一步得到的结果进行逻辑或（ ori ）操作，或者加法（ addi ，如果目标寄存器之前已包含有效数据且希望累加的话），从而合成出完整的32位立即数。 例如，假设我们要将32位立即数0x12345678加载到寄存器t0中，我们需要这样操作：
lui $t0, 0x1234 #将高16位Ox1234载入$t0，低16位清零 ori $t0, $t0, 0x5678 #将低16位0x5678与$t0进行逻辑或操作 寻址方式 地址: 1.形式地址(A):通过A加以转化得到EA 2.有效地址(EA):真实地址
地址种类: 1.寄存器编号 2.内存地址 3.I/O端口 寻址方式:是寻找指令或者操作数的有效地址的方式 1.指令寻址:去寻找下一条指令的地址 PC:程序计数器 存放当前欲执行指令的地址，并且具有自动+1功能 (1)顺序寻址:直接通过PC+1(一条指令的长度)，自动形成下一条指令的地址 (2)跳跃寻址:转移类指令实现 i.J 型指令格式的跳转指令 J型指令是一种专门用于无条件跳转（Jump）的指令格式。在MIPS指令集中，J型指令的具体格式如下： 6位操作码：用于指示这是一个J型跳转指令。 26位地址字段：用于存储相对于当前PC（程序计数器）的偏移量。 注:J型指令的寻址方式主要是变通的直接寻址（伪直接寻址）： 跳转地址由指 26 位字段和 PC 高4位相连而成,最低两位补0（指令地址必定为四的倍数） ii.I 型指令格式的条件分支指令 与无条件跳转指令不同，条件分支指令在跳转到目标地址之前会先比较两个操作数的值。 如果满足比较条件，则执行跳转；否则，继续顺序执行下一条指令。具体来说： 1.两个操作数：这些操作数通常是从寄存器中获取的值，例如 rs （源寄存器1）和 rt （源寄存器2），用于比较它们之间的关系。 2.条件判断：不同的条件分支指令对应着不同的条件判断，如beq检查两者是否相等，bne检查两者是否不相等，blt则检查第一个操作数是否小于第二个操作数。 3.分支地址：如果满足特定条件，则程序计数器PC会被更新为指令中指定的目标地址，从而实现有条件地转移到新的指令序列继续执行。 注:条件分支指令的寻址方式是------&amp;gt;PC相对寻址 PC相对寻址（PC-Relative Addressing）是一种指令寻址方式，它使用当前程序计数器（ProgramCounter, PC）的值加上一个相对于当前指令地址的偏移量来确定下一条要执行的指令或数据的位置。 具体来说，在PC相对寻址中，指令包含了一个表示偏移量的字段。当CPU执行到含有PC相对寻址的跳转指令时，它会将当前PC值与该偏移量相加，得到的目标地址就是跳转的目的地。 这种方式使得程序员可以编写出与加载地址无关的代码，增强了程序的可移植性，并且简化了硬件设计，因为不需要复杂的计算逻辑去生成绝对地址。 优点：简洁性和可预测性。 缺点：限制了分支目标的范围，因为偏移量的大小是有限的。不利于代码的重定位和共享。 注:寻址附近的指令也是加速大概率事件的另外一个例子 。 2.数据寻址:去寻找本条指令的操作数的有效地址 (1)立即(数)寻址 操作数直接包含在指令中，作为指令的一部分。这种情况下，操作数的值是一个立即数，即固定值。 立即寻址模式通常用于加载立即数到寄存器中，或者用于算术和逻辑运算。 MIPS 指令集并没有像某些其他指令集那样直接支持“MOV”指令，但可以通过其他方式实现寄存器到寄存器的数据移动。 优点:速度快，不需要访问内存 缺点:位数有限，立即数大小有限 (2)直接寻址(EA == A) 指令中包含一个实际的内存地址，这个地址直接指向内存中的一个位置，从中读取或写入操作数，CPU直接使用这个地址从内存中读取操作数。 在 MIPS 指令集中，直接寻址模式通常用于访问内存中的特定地址。在直接寻址中，指令中直接包含了要访问的内存地址。 直接寻址在 MIPS 指令集中是一种简单而直接的方式来访问内存中的特定位置。 然而，由于其限制和可能的性能影响，它通常只在需要直接访问特定内存地址时使用。所以其实并不常用。 优点:简单 缺点:限制了寻址范围 (3)寄存器寻址 操作数存储在某个寄存器中。指令中通常包含一个寄存器标识符，处理器从该寄存器中读取或写入操作数。 寄存器寻址通常比内存寻址更快，因为寄存器位于 CPU 内部，访问它们不需要像访问内存那样经过复杂的内存子系统。 MIPS 指令集中的寄存器寻址非常灵活，因为大多数指令都可以接受来自寄存器或立即数的操作数。 寄存器寻址不仅限于算术和逻辑运算，还可以用于数据移动、比较、跳转等操作。 寄存器寻址是 MIPS 指令集中非常基础和重要的寻址模式，它允许 CPU 快速、高效地处理数据，而不需要频繁地访问内存。 优点：快速，不需要访问内存；简单 缺点：寄存器个数有限，造价昂贵 (4)间接寻址( EA == (A) ) 指令中给出的地址码是存放操作数有效地址的主存单元地址。 优点:扩大了寻址范围 缺点:慢，多次访问内存 寄存器间接寻址：通过寄存器间接寻址实现。 这意味着指令的操作数地址不是直接给出的，而是存储在一个寄存器中，处理器会访问该寄存器内容所指向的内存地址来获取实际操作数 (5)变址寻址 以某个寄存器的内容为偏移量，加上指令中给出的基地址来计算操作数的实际地址。 这种寻址模式在处理数组或循环时特别有用，因为它允许程序在不需要修改基址寄存器的情况下，通过改变偏移量来访问内存中的不同位置。 变址寄存器:变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变(作为偏移(量)，形式地址A不变(作为基地址))。 优点:扩大了寻址范围 缺点:必须使用一个寄存器存储偏移量 (6)基址寻址 类似于变址寻址，但这里的基准是固定的基址寄存器，加上一个偏移量得到操作数地址。 有效地址是通过将基址寄存器的内容与指令中给出的偏移量相加而得到的。基址寄存器的内容在程序执行过程中通常保持不变，而偏移量可以变化。 这种寻址模式常用于未多道程序分配存储空间 例.</description>
    </item>
    
    <item>
      <title>计算机网络评价指标和封包解包</title>
      <link>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E5%92%8C%E5%B0%81%E5%8C%85%E8%A7%A3%E5%8C%85/</link>
      <pubDate>Wed, 21 Aug 2024 17:35:31 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E5%92%8C%E5%B0%81%E5%8C%85%E8%A7%A3%E5%8C%85/</guid>
      <description>计算机⽹络的性能指标 1.速率 数据量的常⽤单位有字节（byte，记为⼤写B） 速率是指数据的传送速率（即每秒传送多少个⽐特），也称为数据率（Data Rate）或⽐特率（BitRate） 速率的基本单位是⽐特/秒（bit/s，可简记为b/s，有时也记为bps，即bit per second 数据量单位中的K、M、G、T的数值分别为2^10 、2^20 、2^30 、2^40 。 速率单位中的k、M、G、T的数值分别为10^3 、10^6 、10^9 、10^12 。 2.带宽 带宽在模拟信号系统中的意义，某个信号所包含的各种不同频率成分所占据的频率范围。单位：Hz 带宽在计算机⽹络中的意义，⽤来表示⽹络的通信线路所能传送数据的能⼒，即在单位时间内从⽹络中的某⼀点到另⼀点所能通过的最⾼数据率。单位：b/s。 数据传送速率 = min [ 主机接⼝速率，线路带宽，交换机或路由器的接⼝速率 ] 3.吞吐量 吞吐量是指在单位时间内通过某个⽹络或接⼝的实际数据量。吞吐量常被⽤于对实际⽹络的测量，以便获知到底有多少数据量通过了⽹络。 吞吐量受⽹络带宽的限制。 4.时延 时延是指数据从⽹络的⼀端传送到另⼀端所耗费的时间，也称为延迟或迟延。 数据可由⼀个或多个分组、甚⾄是⼀个⽐特构成。 分为：发送时延、传播时延、排队时延、处理时延 5.时延带宽积 时延带宽积是传播时延和带宽的乘积。 链路的时延带宽积也称为以⽐特为单位的链路⻓度，这对我们以后理解以太⽹的最短帧⻓是⾮常有帮助的。 6.往返时间 往返时间（Round-Trip Time，RTT）是指从发送端发送数据分组开始，到发送端收到接收端发来的相应确认分组为⽌，总共耗费的时间。 7.利⽤率 链路利⽤率，链路利⽤率是指某条链路有百分之⼏的时间是被利⽤的（即有数据通过）。完全空闲的链路的利⽤率为零。 ⽹络利⽤率，⽹络利⽤率是指⽹络中所有链路的链路利⽤率的加权平均。
计算机⽹络数据封包和解包
⽹络体系的术语 1.实体 实体是指任何可发送或接收信息的硬件或软件进程。 对等实体是指通信双⽅相同层次中的实体。 2.协议 协议是控制两个对等实体在“⽔平⽅向” 进⾏“逻辑通信”的规则的集合。
协议的三要素 1.语法，定义所交换信息的格式 2.语义，定义通信双⽅所要完成的操作 3.同步，定义通信双⽅的时序关系 3.服务 协议是“⽔平”的，⽽服务是“垂直”的。 实体看得⻅下层提供的服务，但并不知道实现该服务的具体协议。下层的协议对上层的实体是“透明”的。 对等层次之间传送的数据包称为该层的协议数据单元（Protocol Data Unit，PDU）。 同⼀系统内层与层之间交换的数据包称为服务数据单元（Service Data Unit，SDU）。 </description>
    </item>
    
    <item>
      <title>指令格式</title>
      <link>https://qingbingwei.github.io/post/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Wed, 21 Aug 2024 14:18:01 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F/</guid>
      <description>指令：由一系列的二进制位（bits）组成的，这些位可以表示不同的操作、操作数地址、跳转目标等。
在 MIPS 架构中，指令的编码是精心设计的，以便 CPU 能够解码并执行相应的操作。 每个指令通常都包含操作码（opcode，用于标识指令的类型）、源操作数、目标操作数等部分。
指令有自己的布局格式，叫做指令格式。指令的格式或布局定义了指令在计算机内存中的表示方式。
对于MIPS架构，每条指令都是32位长，这与MIPS体系结构中数据字的位数相一致。 这种固定长度的指令格式简化了指令的解码和执行过程，因为CPU不需要在读取指令时确定指令的长度。
在计算机科学中，我们通常将这种直接表示为二进制形式的指令称为机器语言或机器码。
字:计算机一次能处理的一个数据，一个字由若干个字节组成 (机器）字长∶字的长度（位数)，等于CPU内部用于整数运算的运算器的位数或者是寄存器的位数
指令字长:一条指令中所包含的二进制位数,一条指令的长度 存储字长:一个存储单元的二进制的位数
指令字长=n*存储字长
/*****************************/
以加法为例：add $t0, $s1, $s2&amp;mdash;&amp;ndash;&amp;gt;机器码是？
该指令包含了一个操作码和三个寄存器。
关于寄存器，这些寄存器在汇编语言中有特定的名称，如 $s0 、 $s1 、 $t0 、 $t1 等。在底层，这些寄存器的名字会被映射成数字，以便硬件能够识别和操作。
例如： 寄存器 $s0 ~ $s7 在 MIPS 中映射到数字 16 ~ 23。 寄存器 $t0 ~ $t7 映射到数字 8 ~ 15。
这种映射关系使得汇编语言编写的程序能够在底层被正确地转换成机器码，并由硬件执行。当汇编 器或编译器处理源代码时，它会将这些寄存器名称转换为相应的数字，以生成正确的机器码。
这种映射关系的设计允许指令集保持简洁和一致，同时使得硬件实现更加高效。
由于MIPS指令是固定长度的32位格式，操作码和其他字段的位置是固定的。
1.opcode(ADD指令的操作码)高六位为0x0，低六位为0x20 2.rs(源寄存器1)对应于s1，在MIPS中s1的编号是17(s0-s7对应16-23)，所以这里的rs部分应为10001 3.rt(源寄存器2)对应于s2，在MIPS中s2的编号是18，所以这里的rt部分应为10010 4.rd(目标奇存器)对应于t0，在MIPS*中t0的编号是8( tO-t7对应8-15)，所以这里的rd部分应为1000由于限定为5位所以是01000
基于上述指令格式， add $t0, $s1, $s2 指令可以翻译成：
完整的32位机器码:000000 10001 10010 01000 00000 100000</description>
    </item>
    
    <item>
      <title>计算机网络分层结构和分组交换</title>
      <link>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/</link>
      <pubDate>Mon, 19 Aug 2024 21:07:18 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/</guid>
      <description>网络的组成 网络是由节点、链路互连形成的
节点 链路 软硬件可裁剪的计算机系统（路由器、机顶盒......） 有线 无线 互联网 各种网络互相之间进行数据通信，各个异构网络通过路由器相连 因特网 通过IP地址识别身份信息 物理层考虑问题 1.采用什么传输介质 2.采用什么物理接口 3.采用什么信号表示比特0和比特1
链路层考虑问题 1.标识网络中各主机的身份(例如MAC地址) 2.从比特流中区分出地址和数据(数据封装格式) 3.协调各主机争用总线(媒体接入控制) 4.以太网交换机的实现(自学习和转发帧) 5.检测数据是否误码(差错检测) 6.出现传输差错如何处理(可靠传输和不可靠传输) 7.接收方控制发送方注入网络的数据量(流量控制)
网络层考虑问题 1.标识网络和网络中的各主机(网络和主机共同编制，例如IP地址) 2.路由器转发分组(路由选择协议、路由表和转发表)
传输层考虑问题 1.进程之间基于网络的通信(进程的标识，例如端口号) 2.出现传输差错如何处理(可靠传输和不可靠传输)
应用层考虑问题 1.不同的数据格式、数据解析、数据处理
端系统问题 分层逻辑
应用层 应用数据的解析 表示层 数据加密解密 会话层 进程管理
传输层
网络层/网际层
数据链路层 网卡 物理层
数据传输
1.电路交换 1.建⽴连接，分配通信资源 2.通话，⼀直占⽤通信资源 3.释放连接，归还通信资源 2.分组交换 优点 1.没有建⽴连接和释放连接的过程 2.分组传输过程中逐段占⽤通信链路，有较⾼的通信线路利⽤率 3.交换节点可以为每⼀个分组独⽴选择转发路由，使得⽹络有很好的⽣存性 缺点 1.分组⾸部带来了额外的传输开销 2.交换节点存储转发分组会造成⼀定的时延 3.⽆法确保通信时端到端通信资源全部可⽤，在通信量较⼤时可能造成⽹络阻塞 4.分组可能会出现失序和丢失等问题 </description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Sat, 17 Aug 2024 16:47:45 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>计算机网络学习内容: 计算机网络原理（保证数据通信是一个完整的 协议设计 网络组织） 计算机网络编程（保证数据高并发的进入服务器 操作系统底层驱动 网络协议）
计算机网络互连模型
计算机网络由若干节点和链接这些节点的链路组成，网络中的节点可以是计算机、交换器、集线器或者路由器等能够进行网络通信的终端设备，链路是一个节点到另外一个节点所走过的物理路线。 这些节点和链路彼此连接可以形成各种不同范围的网络，通过网络覆盖范围的大小，可以分为局域网、城域网和广域网。 1.局域网:一般指的是范围在几百到几公里办公楼或者校园内计算机相互连接成的计算机网络，一般用在狭小区域内的网络，一个社区、一栋楼、办公室经常使用局域网。 2.城域网:一个城市中的计算机所相互连接形成的计算机网络。城域网是介于广域网与局域网之间的一种高速网络。 城域网设计的目标是要满足几千米范围内的大量企业、机关、公司的多个局域网互联的需求，以实现大量用户之间的数据、语音、图形与视频等多种信息的传输功能。 3.广域网︰广域网中的计算机所形成的连接范围就更大了，常常是一个国家或是一个洲。其目的是为了让分布较远的各局域网互联。 边缘结构 研究接入方式 骨干网 核心结构 传输行为 分组传递...... 计算机网络设计：保证主机到主机之间，能够保证数据无差错，数据身份正确，数据无丢失交给数据处理层
OSI标准7层模型
应用层（不关心组网方式） 表示层 数据加密解密 会话层 进程管理
传输层 数据到应用层的分离 端到端的通信 [数据无丢失]&amp;mdash;可选
网络层 把数据链路上不同身份转换为同一个身份结构，为上层提供了统一的接口
数据链路层 数据无差错 身份识别（跟组网方式有关） 物理层 约定电气协议</description>
    </item>
    
    <item>
      <title>逻辑运算与字符表示</title>
      <link>https://qingbingwei.github.io/post/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Sat, 17 Aug 2024 16:47:13 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA/</guid>
      <description>逻辑运算
位运算:位操作是对整数或其他二进制表示的数据的每个位进行单独操作。 虽然早期的计算机仅对整字进行操作，但人们很快就发现，对字中由若干位组成的字段甚至对单个位进行操作是很有用的，如: 1.位级操作:在计算机硬件和软件层面支持对一个字中的单个或一组位进行操作，这对于实现诸如错误检测(如奇偶校验、CRC校验)、数据压缩、编码解码(如ASCII到EBCDIC转换)、权限控制(如访问控制位)以及硬件接口信号处理等任务至关重要。 2.布尔逻辑:逻辑门电路的设计和数字逻辑的应用也要求能够对位进行AND、OR、NOT等逻辑操作，这在计算机内部的控制电路中是基础性的工作。 3.打包和拆包:在通信协议、数据格式化等领域，经常需要将多个小的数据元素（比如单个字符或标志位）组合成一个较大的字，或者从一个字中提取特定的位字段，这些操作都依赖于位级操作指令。 因此，现代计算机的指令集架构中通常包含了丰富的位操作指令，允许程序员直接对数据的各个位进行操作，极大地增强了程序设计的灵活性和效率。 按位与（AND）：同1为1 作用： x &amp;amp; 1 = x x &amp;amp; 0 = 0 1.保留某些位 2.清除某些位 3.检查标志位 4.网络地址和子网掩码计算 5.硬件接口控制 6.数据有效性校验 按位或（OR）：有1为1 作用： x | 0 = x x | 1 = 1 1.设置标志位 2.合并数据 3.条件赋值 4.硬件接口控制 按位异或（XOR）：不同为1 注: 1.满足交换律：a^b = b^a 2.满足结合律：(a^b)^c = a^(b^c) 3.自反性：a^a = 0 a^0 = a 作用： 1.不改变原始数据进行翻转特定位 2.交换两个变量的值（无需临时变量） x=x^y y=x^y x=x^y 3.计算奇偶校验位 非/取反（NOT）：单个操作数的每位取反，0变为1，1变为0。 作用： 1.反转二进制位 2.计算数值的补码形式 对一个正数执行按位非操作会得到一个负数，这个负数的补码是对其绝对值的原码按位取反后再加1； 反之，对一个负数执行按位非操作，则大致上可以得到该负数加1之后对应的正数（但不是绝对准确，因为溢出问题可能导致不一致）。 3.创建掩码 4.判断奇偶性 左移（Left Shift）：将一个数的所有位向左移动指定次数，空出的低位补零。 作用： 1.</description>
    </item>
    
    <item>
      <title>线程与进程</title>
      <link>https://qingbingwei.github.io/post/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Wed, 08 May 2024 15:36:12 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</guid>
      <description>进程模型 进程是对正在运行中的程序的一个抽象
进程的创建 1.系统初始化 启动操作系统时，通常会创建若干个进程 1.前台进程 2.守护进程 2.正在运行的程序执行了创建进程的系统调用 3.用户请求创建一个新进程 4.初始化一个批处理工作 进程的终止 1.正常退出(自愿的) 2.错误退出(自愿的) 3.严重错误(非自愿的) 4.被其他进程杀死(非自愿的) 进程的层次结构 1.Unix进程体系:进程树,结构清晰 2.Windows进程体系:Windows中没有进程层次的概念，Windows中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。 进程的状态 1.阻塞(因为等待) 2.运行 3.就绪(因为调度程序的选择) 线程模型 为什么要有线程的概念？ 1.多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的 2.线程要比进程更轻量级 3.如果多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度。
线程的使用 1.多线程解决方案 有并行性，阻塞系统调用 2.单线程解决方案 无并行性，性能较差，阻塞系统调用 3.状态机解决方案(状态机中保存将要发生的或者会使得状态改变的一个集合) 并行性，非阻塞系统调用、中断 经典的线程模型 线程可称为轻量级进程 线程的系统调用 POSIX线程(IEEE在IEEE标准1003.1c中定义线程标准) 线程实现 1.在用户空间中实现线程 优势: 1.启动他们比进行内核调用效率更高。因为不需要切换到内核,也就不需要上下文 切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高 2.它允许每个进程有自己定制的调度算法 劣势: 1.如何阻塞系统调用 2.不可能使用轮转调度的方式调度线程 2.在内核空间中实现线程 注:系统调用开销大 3.在用户和内核空间中混合实现线程 进程间通信
竞态条件 即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition) 临界区 1.任何时候两个进程不能同时处于临界区 2.不应对CPU的速度和数量做任何假设 3.位于临界区外的进程不得阻塞其他进程 4.不能使任何进程无限等待进入临界区 忙等互斥 1.屏蔽中断 在单处理器系统上，最简单的解决方案是让每个进程在进入临界区后立即屏蔽所有中断（包括CPU时钟中断） 对内核来说，当它在执行更新变量或列表的几条指令期间将中断屏蔽是很方便的 2.锁变量 寻找一种软件层面解决方案 3.严格轮询法 while(TRUE){ while(turn == 0 ) { /*进入关键区域*/ critical_region (); turn = 1; /*离开关键区域*/ noncritical_region(); } } while(TRUE){ while(turn == 1 ) { /*进入关键区域*/ critical_region (); turn = 0; /*离开关键区域*/ noncritical_region(); } } 4.</description>
    </item>
    
    <item>
      <title>有符号数和无符号数</title>
      <link>https://qingbingwei.github.io/post/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</link>
      <pubDate>Sun, 21 Apr 2024 17:43:10 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/</guid>
      <description>信息的最小单位是比特（bit），它只能表示两种状态：0 或 1。 1.简洁性 2.直接与硬件映射 3.易于扩展 4.内存效率
多个比特被组合在一起形成字节（byte），通常一个字节由8个比特组成。 1B=8b 多个字节组成一个字。
最低有效位 表示最右边的一位，最高有效位 表示最左边的一位。 MIPS 的字有 32 位 ，如果要存储1011。那就是： 0000 0000 0000 0000 0000 0000 0000 1011（高位补0）
计算机硬件设计使得其能够高效地执行基于二进制的加法、减法、乘法、除法以及其他逻辑操作，所有这些都直接对应于底层电路中的电子信号的变化。这些基础操作构成了现代计算机计算能力的核心。
整数进制转换 二进制：1111011 十进制：123
二进制转换为十进制：逐位乘以2的幂次方求和。 十进制转换为二进制：除2取余法 计算机硬件设计使得其能够高效地执行基于二进制的加法、减法、乘法、除法以及其他逻辑操作，所有这些都直接对应于底层电路中的电子信号的变化。这些基础操作构成了现代计算机计算能力的核心。 为了表示正数和负数，计算机程序使用了一种称为“符号和幅值”（sign and magnitude）的表示法，即原码： 高位（通常是第一位或最左边的位）用作符号位，0表示正数，1表示负数。其余位表示数值的幅值（即绝对值）。
例如：占8位的二进制数： 9D： 0000 1001B -9D：1000 1001B
固定位数（n+1位）的原码范围：
[-(2n-1), (2n-1)]
0的原码表示有两种：0000 0000 和 1000 0000
当运算的结果超出了该数据类型能够表示的范围时，就会发生溢出。（计算机内部一般用补码存储数据，稍后讨论）
原码加减法：与十进制一样，考虑进位和借位。
注：在原码加减运算中，对于两个不同符号数的加法(或同符号数的减法)，先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要为结果选择合适的符号。
原码表示法的优点： 原码表示的优点是，与真值的对应关系直观、方便,因此与真值的转换简单,并且用原码 实现乘除运算比较简便。
原码表示法的缺点： 0的表示不唯一,给使用带来不便；加减运算比较复杂，要考虑溢出、负借位等等问题
为了简化硬件设计并解决这些问题，现代计算机更倾向于使用二进制补码（two&amp;rsquo;s complement）的方式来表示有符号整数。 二进制补码不仅解决了正负数的区分问题，还使得加减运算能够通过相同的硬件电路实现，同时有效地处理了溢出情况，并消除了正负零的问题。
补码的定义:具有一位符号位和n-1数字位的二进制整数x来说 其补码是: [x]补 = 2^n + x(mod 2^n) -2^(n - 1)&amp;lt;= x &amp;lt; 2^(n - 1)</description>
    </item>
    
    <item>
      <title>计算机硬件操作及操作数</title>
      <link>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%93%8D%E4%BD%9C%E6%95%B0/</link>
      <pubDate>Sun, 21 Apr 2024 17:42:57 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%93%8D%E4%BD%9C%E6%95%B0/</guid>
      <description>机器指令(简称指令)：指示计算机执行某种操作的命令，计算机语言中的基本单词。
一台计算机的所有指令的集合构成该机的指令系统，也称指令集。 分类: 1.复杂指令集系统 2.精简指令集系统
指令集的两种形式： 一种是人们编程书写的形式（汇编语言-助记符），另一种是计算机所能识别的形式（机器语言-二进制元）。
指令集有很多种：MIPS(精简指令集系统)；Intel x86；ARM系统：ARMv7,ARMv8;RISC-V&amp;hellip;&amp;hellip;
存储程序：必须将事先编好的程序和原始数据送入主存后才能执行程序,一旦程序被启动执行,计算机能在不需操作人员干预下自动完成逐条取出指令并执行的任务。
注:存储程序是1945年 冯. 诺伊曼提出的，“存储程序(stored-program)通用电子计算机方案”,宣告了现代计算机结构思想的诞生。 硬件设计的三条基本原则：
1.简单源于规整：这意味着设计应该尽可能地简单，以便于理解和维护。这通常通过保持设计的规整性来实现，例如通过保持指令长度的统一，可以简化处理器的设计和编程。 2.越小越快：在硬件设计中，减小组件的尺寸可以提高其运行速度。这是因为当信号传输的距离变短时，传输时间也会减少，从而提高了整体性能。 3.优秀的设计需要折中的方案：在实际的硬件设计中，往往需要在不同的设计要求之间做出权衡。例如，为了提高性能，可能需要增加功耗或牺牲一部分能效。因此，设计师需要找到一个能够满足所有关键要求的最佳折中方案。 任何计算机必须能够执行算术运算
加法为例，MIPS 汇编语言的下述记法： add a . b. c 表示将两个变量 b和c相加，并将它们的和放入变量a中。 这种表达的方式是固定的，每一条指令只用来执行一个操作。 与加法类似的指令一般都有三个操作数：两个进行运算的数和一个保存结果的数。要求每条指令有且仅有三个操作数。体现了：简单源于规整。 操作数：与高级语言程序不同， MIPS 算术运算指令的操作数是很严格的，它们必须来自寄存器。 寄存器：由硬件直接构建且数量有限，是计算机硬件设计的基本元素。MIPS 体系结构中寄存器大小为 32 位，称其为字。 字：计算机中的基本访问单位，通常是 32 位为一组，在 MIPS 体系结构中与寄存器大小相同。MIPS按字节编址，一个字对应4个字节。 寄存器的数量是有限的。越小越快。大量的寄存器可能会使时钟周期变长，因为电信号传输更远的距离必然花费更长的时间。对于这32个寄存器，我们用0~~31来表示。尽管可以简单使用序号0~31 表示相应的寄存器，但MIPS 约定书写指令时用一个符“$”后面跟两个字符来代表一个寄存器：$S0。 只能将少量数据保存在寄存器中，但存储器可以存储数十亿的数据元素。 因此，数据结构是存放在存储器中的。
MIPS 的算术运算指令只对寄存器进行操作,因此，MIPS 必须包含在存储器和寄存器之间传送数据的指令。这些指令叫作数据传送指令。
为了访问存储器中的一个字，指令必须给出存储器地址。将数据从存储器复制到寄存器的数据传送指令通常叫取数 (load) 指令。MIPS取数指令助记符是lw。也就是load word的缩写： 基本语法：lw 目标寄存器, 偏移量(基址寄存器) lw $t0, 100($s1)
和取数相对应的就是存数(sw): 基本语法：sw 源寄存器，偏移量(目的寄存器) sw $s1, 4($s2)
注:上述100和4为立即数----&amp;gt;常数 注:地址其实也是一个数据，也可以做操作数参与指令操作 寄存器的数量相对于程序可能需要存储的变量数量而言通常是非常有限的。 将最常用的变量保存在寄存器中可以显著提高程序执行效率。&amp;mdash;&amp;mdash;&amp;gt;加速大概率事件
当一个变量不再频繁使用或者当前需要用到的变量太多，而寄存器资源不足时，编译器会选择将某个寄存器中的变量“溢出”到内存中存储，这个过程称为寄存器溢出。</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://qingbingwei.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 14 Apr 2024 23:26:18 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>硬件支持系统 系统管理硬件
操作系统就是一个建立在应用程序和硬件之间的一道桥梁 基本功能: 1.防止硬件被滥用，尤其是一些失控程序 2.通过一种比较简单的机制匹配对应的应用程序，进而控制复杂的硬件 对硬件的抽象: 1.进程 2.虚拟内存 3.文件
进程:进程的本质就是操作系统执行的一个程序
与进程相关 1.地址空间&amp;mdash;&amp;mdash;从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表 2.资源集&amp;mdash;&amp;mdash;-通常包括寄存器(寄存器一般包括程序计数器和堆栈指针)，打开文件的清单，突发的警报，有关的进程清单和其他需要执行程序的信息
进程挂起 1.进程的地址空间&amp;mdash;-磁盘映像 2.进程表项
进程间通信 合作完成某些作业的相关进程经常需要彼此通信来完成作业
进程是什么 1.从理论角度看，是对正在运行的程序过程的抽象 2.从实现角度看，是一种数据结构，目的在于清晰的刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序
并发技术 通过指令的交错执行，进程在来回切换，一个进程的指令和另一个进程的指令交错执行的过程就叫做并发运行
在每个任务运行前，CPU都需要知道任务从哪里加载和运行 1.CPU寄存器 2.程序计数器 线程 线程是操作系统能够进行运算调度的最小单位。其被包含在进程中，是进程中的实际运作单位
并发和并行 1.并行是指两个或者多个事件在同一时刻发生 2.并发是指两个或者多个事件在同一时间间隔内发生
系统调用 操作系统提供的两种功能 1.为用户提供应用程序抽象 2.管理计算机资源 注:只有系统调用能够进入内核态而过程调用则不能进入内核态 注:API(应用程序接口)，POSIX(系统程序接口)
分类 1.用于进程管理的系统调用 2.用于文件管理的系统调用 3.用于目录管理的系统调用 操作系统结构 1.单体结构 整个操作系统是以程序集合来编写的 优点: 调用任何一个所需要程序都非常高效 缺点: 1.但是上千个不受限制的彼此调用往往非常臃肿 2.只要系统故障，那么任何系统和应用程序将不可用，这是灾难性的 2.分层系统 分层系统使用层来分隔不同的功能单元。每一层只与该层上层与下层通信 3.微内核 传统上，所有的层都在内核中，但是这样没必要，尽可能减少内核态中功能可能是更好的做法
只有一个模块---微内核---运行在内核态，其余模块可以作为普通用户进程运行 4.客户-服务端系统 </description>
    </item>
    
    <item>
      <title>计算机组成原理</title>
      <link>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 08 Apr 2024 19:57:43 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</guid>
      <description>计算机发展史: 第一代:电子管计算机 第二代:晶体管计算机 第三代:集成电路 第四代:超大集成电路
冯诺依曼:&amp;ldquo;存储程序&amp;quot;思想
计算机构成: CPU： CU:控制单元 ALU:算术逻辑单元 寄存器组 cache:高速缓存(一般集成到CPU上)
存储器 输入设备:键盘，鼠标 输出设备:显示器，打印机 总线 计算机分类: 1.个人计算机(PC) 2.服务器 3.嵌入式计算机 4.个人移动设备(PMD) 5.云计算
计算机设计思想: 1.面向摩尔定律的设计 2.使用抽象简化设计 (1)计算机系统的设计中的抽象 1.应用层 2.操作系统层 3.硬件驱动层 4.硬件层 (2)软件设计中的抽象 1.产品/架构:概念层次 2.架构师:逻辑层次 3.软件工程师:编程 物理层
3.加速大概率事件(缓存，数据压缩，预处理) 优化瓶颈:若干个关键操作(占用较多资源的操作)构成系统的瓶颈 高速缓存(cache):加速数据的访问速度 数据压缩:通过压缩数据，使数据所占空间减小 预处理:脏数据&amp;mdash;&amp;gt;预处理&amp;mdash;&amp;gt;干净数据 预测/推测执行:即下述6 4.通过并行提高性能 并行:同一时刻，可以处理多个任务&amp;mdash;&amp;ndash;&amp;gt;多核CPU 并发:同一时间内采用交替执行的方式，宏观上并行，微观上串行&amp;mdash;&amp;ndash;&amp;gt;单核CPU 5.通过流水线(一种经典的并行处理技术)来提高性能 指令流水线:指令执行 取指 译码 执行 访存 写回 6.通过预测来提高性能 (1)指令预测 (2)分支预测 (3)缓存预取 7.存储器层次结构 存储器分层: (1)顶层,最接近CPU:速度快 成本高 容量小&amp;mdash;-&amp;gt;寄存器 高速缓存&amp;mdash;-&amp;gt;常用数据/指令 (2)下一层:主存储器(主存/内存) 速度慢一些 成本低一些 容量大一些&amp;mdash;-&amp;gt;易失性存储介质 (3)第三层:虚拟内存/磁盘缓存 (4)底层 硬盘(外存) 最慢 成本最低 容量最大&amp;mdash;-&amp;gt;永久性存储介质 8.</description>
    </item>
    
    <item>
      <title>Docker本地镜像推送</title>
      <link>https://qingbingwei.github.io/post/docker%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81/</link>
      <pubDate>Sun, 31 Mar 2024 13:44:38 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/docker%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81/</guid>
      <description>推送到远端仓库 docker login &amp;ndash;username=清兵卫 registry.cn-hangzhou.aliyuncs.com docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/qingbingwei_docker/linux_docker:[镜像版本号] docker push registry.cn-hangzhou.aliyuncs.com/qingbingwei_docker/linux_docker:[镜像版本号]
从远端仓库拉取 docker pull registry.cn-hangzhou.aliyuncs.com/qingbingwei_docker/linux_docker:[镜像版本号]
推送到私有库 1.搭建私有库 docker pull registry docker run -d -p 5000:5000 -v /qingbingwei/myregistry/:/tmp/registry &amp;ndash;privileged=true registry
2.将镜像推送到私服库 1.在ubuntu内添加ifconfig功能然后制作成新的镜像 apt-get update apt-get install net-tools 2.使用curl工具验证私服库上有什么镜像 curl -XGET http://192.168.146.135:5000/v2/_catalog 3.将新镜像ubuntu1:1.1修改符合私服规范的Tag docker tag 镜像:Tag Host:Port/Repository:Tag docker tag ubuntu1:1.1 192.168.146.135:5000/ubuntu:1.1 4.修改docker配置文件使之支持http vim命令新增如下内容：vim /etc/docker/daemon.json &amp;quot;insecure-registries&amp;quot;: [&amp;quot;192.168.146.135:5000&amp;quot;] 注:最好重启docker 5.push推送到私服库 docker push 192.168.146.135:5000/ubuntu1:1.1 6.验证私服库上是否存在镜像 curl -XGET http://192.168.146.135:5000/v2/_catalog 7.从私服上拉取镜像 docker pull 192.168.146.135:5000/ubuntu1:1.1 </description>
    </item>
    
    <item>
      <title>Docker底层原理</title>
      <link>https://qingbingwei.github.io/post/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 31 Mar 2024 13:12:34 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid>
      <description>docker镜像底层原理 1.docker镜像是分层的文件系统 每个分层的镜像都有单独的功能，然后汇聚成一起对外暴露成一个整体的镜像。 这种分层的镜像我们又称为联合文件系统(UnionFS)。
Union 文件系统是 Docker 镜像的基础。 镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。 2.docker镜像的加载原理 1.bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。 2.rootfs (root file system) ，在bootfs之上。 包含的就是典型 Linux 系统中的 /dev,/proc, /bin, /etc 等标准目录和文件。 3.为什么Docker镜像要设计成这种分层的镜像? 是为了提高复用率 注:Docker镜像层都是只读的，容器层是可写的。 当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层” 3.使用commit制作镜像 1.在ubuntu内添加vim功能然后制作成新的镜像 apt-get update apt-get -y install vim 2.提交容器副本使之成为一个新的镜像 docker commit -m=&amp;quot;提交的描述信息&amp;quot; -a=&amp;quot;作者&amp;quot; 容器ID 要创建的目标镜像名:[标签名] docker commit -m=&amp;quot;add vim&amp;quot; -a=&amp;quot;qingbingwei&amp;quot; f36b2a311fb6 ubuntu:1.1 </description>
    </item>
    
    <item>
      <title>KMP</title>
      <link>https://qingbingwei.github.io/post/kmp/</link>
      <pubDate>Sat, 30 Mar 2024 21:29:57 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/kmp/</guid>
      <description>字符串算法:KMP算法
字符串:由若干个字符组成的有序序列
字符串：末尾有一个隐含的结束符&amp;rsquo;\0&#39; 字符数组：末尾没有隐含结束符
字符串匹配问题:给出一个主串p 和一个模式串s，问s有没有在p中出现过，出现过几次，每次出现位置在哪里
p:dfghahjsgfhjas&amp;mdash;&amp;gt;m s:hjdj&amp;mdash;&amp;gt;n
1.BF算法(暴力匹配) O(n*m) for(int i = 0;i + LS &amp;lt; LP ;++i) { int j(0); int k(i); while(j &amp;lt; LS) { if(p[k] == s[j]) { ++j; ++k; } else { break; } } if(j == LS) { cout &amp;laquo; i &amp;laquo; endl; } }
2.KMP算法 O(n+m) next[0]=-1 next[1]=0 //以上均为默认 代码思路:模式串自己(错位)匹配自己</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://qingbingwei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Tue, 26 Mar 2024 19:57:35 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>动态规划&amp;mdash;&amp;ndash;&amp;gt;一类思想
动态规划: 线性动态规划 区间动态规划 背包问题 状态压缩动态规划 树型动态规划 插头动态规划 数位动态规划 ...... 运筹学 决策过程最优化 一般用来求解最优解问题 递归与DP区别: 递归:将求解的问题分解为若干个同类的子问题，子问题是否相互独立不影响 DP:将待求解问题分解成若干个子问题，先求解子问题，然后从子问题的解得到原问题的解，并且子问题之间往往不是互相独立的 DP问题两个性质: 1.最优子结构性质 2.重叠子问题性质 动态规划:将待求解问题分解成若干个子问题，先求解子问题， 然后从子问题的解得到原问题的解，并且子问题之间往往不是互相独立的 求解DP类型问题:递归 斐波那契数列: 1.递归实现----&amp;gt;记忆化搜索-----&amp;gt;自上而下求解 2.非递归实现(DP table)----&amp;gt;迭代-----&amp;gt;根据1中的记忆化数组，找到数组之中数据的关系-----&amp;gt;自下而上求解 DP解题思路: 1.辨别是不是DP问题 2.状态数组: 状态:子问题的状态/解 找状态数组: (1)用参数来描述状态，用一句话描述最终问题状态 (2)或者搜索-----&amp;gt;记忆化优化-----&amp;gt;记忆化数组就是状态数组 3.找状态转移方程:状态数组中状态之间的关系 (1)站在中间状态的角度考虑i，默认前i-1个状态的值已经知道 (2)搜索-----&amp;gt;记忆化优化-----&amp;gt;记忆化记录答案过程，隐含了转移公式 4.写代码:写法1或写法2 01背包问题: 有N种不同物品和一个容量为C的背包，每种物品有自己的重量w和价值v，，并且每种物品只有一件，可以装下物品的最大价值是多少?
1.辨题----&amp;gt;DP 2.状态数组: (1)从前n个物品中选择若干个，重量不超过C，价值最大 dp[n][c] = ans; dp[i][j] = x; 从前i个物品中选择若干个，重量不超过j，价值最大为x dp[0][j]=0 dp[i][0]=0 (2)暴力搜索 3.找状态转移方程:状态数组中状态之间的关系 (1)站在中间状态的角度考虑i，默认前i-1个状态的值已经知道 (2)搜索-----&amp;gt;记忆化优化-----&amp;gt;记忆化记录答案过程，隐含了转移公式 4.写代码:写法1或写法2 </description>
    </item>
    
    <item>
      <title>Docker常用命令</title>
      <link>https://qingbingwei.github.io/post/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 26 Mar 2024 19:40:30 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Docker常用命令 1.帮助启动类命令 systemctl start docker #启动docker systemctl status docker #查看docker的运行状态 systemctl restart docker #重启docker服务 systemctl stop docker #停止docker服务 docker &amp;ndash;help #查看docker帮助文档
查看指定某条docker命令的帮助信息 docker cp --help 2.docker的镜像命令 1.docker images 列出本地主机上的镜像 各属性含义 REPOSITORY：表示镜像的仓库源 TAG：镜像的标签版本号。在下载镜像的时候，如果默认不加版本号，就会下载默认最新版本的镜像。 如果加上指定版本号的镜像，下载的就是对应版本的镜像。 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 注:同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用REPOSITORY:TAG 来定义不同的镜像。 参数 -a :列出本地所有的镜像（含历史映像层） -q :只显示镜像ID。 2.docker search 某个XXX镜像名字 指定搜索某个镜像的名称。 docker search redis 参数 --limit :只列出N个镜像，默认25个 docker search --limit 5 redis 3.docker pull 某个XXX镜像名字 拉取指定的镜像到本地(下载镜像) docker pull 镜像名字[:TAG] 4.docker system df 查看镜像/容器/数据卷所占的空间 5.</description>
    </item>
    
    <item>
      <title>Docker组成与架构</title>
      <link>https://qingbingwei.github.io/post/docker%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Tue, 26 Mar 2024 18:54:13 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/docker%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/</guid>
      <description>Docker的基本组成 1.镜像(image) Docker 镜像（Image）就是一个只读的模板。 镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 2.容器(container) 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 3.仓库(repository) 仓库（Repository）是集中存放镜像文件的场所。 注:Docker公司提供的官方registry被称为Docker Hub
在Centos7上安装Docker 安装gcc环境 [root@shjava2202 ~]# yum -y install gcc [root@shjava2202 ~]# yum -y install gcc-c++
安装需要的软件包 [root@shjava2202 ~]# yum install -y yum-utils 设置镜像仓库 [root@shjava2202 ~]# yum-config-manager --add-repohttp://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新yum软件包索引 [root@shjava2202 ~]# yum makecache fast 安装Docker [root@shjava2202 ~]# yum -y install docker-ce docker-ce-clicontainerd.io 启动Docker [root@shjava2202 ~]# systemctl start docker 安装完成之后，我们可以查看Docker安装的版本信息 # docker version 为什么Docker会比VM虚拟机快 (1) docker有着比虚拟机更少的抽象层 由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。 因此在CPU、内存利用率上docker将会在效率上有明显优势。 (2) docker利用的是宿主机的内核,而不需要加载操作系统OS内核 当新建一个容器(docker run)时,docker不需要和虚拟机一样重新加载一个操作系统内核。 进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。 而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</description>
    </item>
    
    <item>
      <title>数据结构 B&#43;树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b&#43;%E6%A0%91/</link>
      <pubDate>Sun, 24 Mar 2024 15:02:02 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-b&#43;%E6%A0%91/</guid>
      <description>B树的缺点: 1.B树节点既存储了索引(主键),又存储了对应的地址
优化:在内部非终端节点中只存储索引(主键), 在终端节点中既存储索引(主键),又存储对应的地址 2.B树不支持区间查询 优化:让终端节点形成链表,支持区间查询 3.B树查找效率不稳定 优化:B+树查找效率稳定 B+树在B树基础上进行改进。
m阶B+树的性质: 1.有序性 2.其节点中最多有m个关键字和m个孩子&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;父亲节点是孩子节点的索引 3.节点中最少要有ceil(m/2)个关键字和孩子 4.终端节点保存所有的关键字和真实数据，并且终端节点之间要有指针相连 4.非终端节点只保存关键字，终端节点保存真实数据
B+树的操作 1.查找 (1)单点查找 注意要找到终端节点上(相等时判断孩子是否为空，为空则为终端节点) (2)区间查找 [l,r],先对左边界数据进行单点查找，再沿着终端节点之间的指针进行顺序遍历 2.插入 和B树类似，先查找到插入位置&amp;mdash;-&amp;gt;插入&amp;mdash;-&amp;gt;判断是否超过上限,超过则分裂 (1)单点查询插入位置 (2)把数据插入到终端节点上 (3)判断插入节点的关键字个数是否&amp;gt;m,如果大于，分裂上传 特殊情况:如果插入的是节点中的最大值，其父亲的关键字(索引数据)要发生改变
注:为了更加实用，忽略掉特殊情况，一棵m阶B+树，其非终端节点关键字个数最多可以是m-1个 3.删除 和B树类似，先查找删除位置---&amp;gt;删除----&amp;gt;判断是否低于下限，低于则调整 (1)查找删除数据(在终端节点上) (2)删除，如果删除的是节点中的最大值，记得向上修改父亲节点 (3)判断删除节点中的关键字个数是否&amp;lt;ceil(m/2),如果小于: 1.兄弟够借，则借 2.兄弟不够借，则合并 应用场景:数据库 外存管理</description>
    </item>
    
    <item>
      <title>Docker容器</title>
      <link>https://qingbingwei.github.io/post/docker%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 19 Mar 2024 17:26:43 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/docker%E5%AE%B9%E5%99%A8/</guid>
      <description>docker的理念:1次镜像，处处运行
docker概念:Docker是基于Go语言实现的云开源项目 主要目标:“Build，Ship and Run Any App,Anywhere”
容器与虚拟机比较： 1.传统的虚拟机有一些缺点：资源占用多、冗余步骤多、启动慢
由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术： Linux容器(LinuxContainers，缩写为 LXC)。 1.容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性 2.Linux容器不是模拟一个完整的操作系统而是对进程进行隔离 3.容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置 。 2.传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 3.容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 4.每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。 docker的优势:一次构建 处处运行 1.更快速的应用交付和部署 2.更便捷的升级和扩缩容 3.更简单的系统运维 4.更高效的计算资源利用
docker和podman比较 注:Podman是一个无守护进程的容器引擎
1、守护进程 Docker使用守护进程，一个正在后台运行的程序，来创建镜像和运行容器。 Podman是无守护进程的架构，这意味着它可以在启动容器的用户下运行容器。 2、安全性 Podman允许容器使用Rootless特权。Rootless容器被认为比Root特权的容器更安全。 在Docker中，守护进程拥有Root权限，这使得它们易成为攻击者的首选入侵点。 Podman中的容器默认情况下不具有Root访问权限，这在Root级别和Rootless级别之间添加了一个自然屏障，提高了安全性。 不过，Podman可以同时运行Root容器和Rootless容器。 3、镜像构建 作为一款自给自足的工具，Docker可以自己构建容器镜像。 Podman则需要另一种名为Buildah的工具的辅助。 4、多合一和模块化 Docker是一个独立的、强大的工具，在整个循环中处理所有的容器化任务，有优点也有缺点。 Podman采用模块化的方法，依靠专门的工具来完成特定的任务。 </description>
    </item>
    
    <item>
      <title>BOM和DOM</title>
      <link>https://qingbingwei.github.io/post/bom%E5%92%8Cdom/</link>
      <pubDate>Sun, 10 Mar 2024 23:33:25 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/bom%E5%92%8Cdom/</guid>
      <description>BOM：BOM（Browser Object Model），即浏览器对象模型，BOM 提供了独立于内容的对象结构，可以与浏览器窗口进行互动
1.window对象 ![](/img/window.png) 1.history对象 ![](/img/history.png) 2.location对象 ![](/img/location.png) 3.document对象 ![](/img/document.png) 2.Date类 ![](/img/date.png) 3.周期函数和延迟函数 ![](/img/periodic_function.png) DOM:DOM（Document Object Model），即文档对象模型，DOM主要提供了对于页面内容的一些操作。 在DOM中，所有的内容（标签和文本）都是DOM节点，所有的标签都是DOM元素。
1.DOM节点关系 ![](/img/DOM_Node.png) 2.节点属性 ![](/img/Node.png) 3.元素属性 ![](/img/element.png) 4.节点操作 ![](/img/Node_operation.png) 5.节点样式 6.节点属性 ![](/img/Node_attribute.png) promise对象 Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息，其状态不受外界影响。Promise对象代表一个异步操作，有三种状态： 1.pending: 初始状态，不是成功或失败状态。 2.fulfilled: 意味着操作成功完成。 3.rejected: 意味着操作失败。
只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 这也是Promise 这个名字的由来，它的英语意思就是承诺，表示其他手段无法改变。 一旦 Promise 对象从初始状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能： 从 Pending 变为 Resolved 和从 Pending 变为 Rejected。 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。 promise应用 function cal(a,b) { let promise = new Promise(function (resolve,reject) { if(b == 0) { reject(new Error(&amp;ldquo;除数不能为零&amp;rdquo;)); //异常情况处理使用reject函数进行拒绝 } else { //成功处理的情况使用resolve函数进行处理 resolve(a/b); } }); promise.</description>
    </item>
    
    <item>
      <title>JavaScript</title>
      <link>https://qingbingwei.github.io/post/javascript/</link>
      <pubDate>Sun, 10 Mar 2024 14:15:09 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/javascript/</guid>
      <description>JavaScript 是一种解释性脚本语言（不用编译），主要用于向 HTML 添加交互行为，语法与 Java 语言类似。
JavaScript 由 ECMAScript（简称 ES）、DOM（Document Object Model） 和 BOM（Broswer ObjectModel） 三大部分组成。
注:该结构可以在HTML中的任意位置书写，但必须保证 JavaScript 脚本中使用到的元素必须在 JavaScript脚本执行前完成加载。 例. //可以访问id为a元素，不可以访问id为b元素 JavaScript 引入方式 1.行内脚本 2.内部脚本 document.getElementById(&amp;ldquo;btn&amp;rdquo;).onclick=function() { alert(&amp;lsquo;你点击了按钮&amp;rsquo;); } 3.外部脚本 // demo.js document.getElementById(&amp;quot;btn&amp;quot;).onclick=function() { alert(&#39;你点击了按钮&#39;); } &amp;lt;!-- demo.html --&amp;gt; &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;点击&amp;quot; id=&amp;quot;btn&amp;quot;&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;demo.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; JavaScript 语法 1.数据类型 2.变量 var 与 let 的区别 注:let 声明的变量只在它所在的代码块有效。 var 声明的变量属于全局变量 3.字符串 常用函数 ![](/img/string.png) 4.数组 1.创建数组 let 数组名 = new Array(数组长度); let 数组名 = new Array(数组元素1, 数组元素2, .</description>
    </item>
    
    <item>
      <title>CSS3及页面布局</title>
      <link>https://qingbingwei.github.io/post/css3%E5%8F%8A%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sat, 09 Mar 2024 16:26:02 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/css3%E5%8F%8A%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</guid>
      <description>CSS3新特性 1.边框 border-radius:用于创建圆角 #border { width: 100px; height: 100px; background-color: red; border-radius: 5px; }
2.盒子阴影 box-shadow:用来添加阴影 box-shadow:阴影类型 水平阴影位置 垂直阴影位置 阴影模糊距离 阴影大小 阴影颜色; box-shadow: inset 2px 2px 2px 2px red; 3.渐变 1.线性渐变—Linear Gradients: 颜色沿着一条直线过渡：从左到右、从右到左、从上到下等 linear-gradient(渐变方向, 颜色1, yanse2, ..., 颜色n) 2.径向渐变—Radial Gradients: 圆形或椭圆形渐变，颜色不再沿着一条直线变化，而是从一个起点朝所有方向混合 radial-gradient(center, shape size, start-color, ..., last-color) 4.文本效果 1.text-shadow:向文本添加阴影 ![](/img/text_shadow.png) 2.text-overflow:当文本溢出包含元素时发生的事情 white-space:nowrap 文本不会换行，在同一行继续 overflow:hidden 元素溢出部分隐藏 text-overflow:ellipsis 用省略号来代表被修剪的文本 5.字体 @font-face { font-family: 必需。规定字体的名称 src: 必需。定义字体文件的 URL font-weight: 可选。定义字体的粗细。默认是 &amp;quot;normal&amp;quot; font-style: 可选。定义字体的样式。默认是 &amp;quot;normal&amp;quot; } 6.</description>
    </item>
    
    <item>
      <title>CSS</title>
      <link>https://qingbingwei.github.io/post/css/</link>
      <pubDate>Sat, 09 Mar 2024 00:16:48 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/css/</guid>
      <description>有一说一，前端确实比后端见效快，只能说正反馈相当及时了。现在学一下CSS，之后学一下JavaScript，也算是初步了解前端了。
CSS 是 Cascading Style Sheet 的简写，表示层叠样式表，主要用于渲染HTML元素在网页中的展示效果。 主要包括对元素高度、宽度、字体、颜色、背景图片、边距、定位、呈现方式等设定
CSS选择器 CSS 选择分为基本选择器和层次选择器。 CSS 基本选择器分为ID选择器、类选择器和标签选择器三大类。 CSS 选择器有优先级之分： ID选择器 &amp;gt; 类选择器 &amp;gt; 标签选择器
基本语法 /*标签选择器*/ 标签名{ 声明1; 声明2; ... 声明n; } /*类选择器*/ .类名{ 声明1; 声明2; ... 声明n; } /*ID选择器*/ #ID值{ 声明1; 声明2; ... 声明n; } CSS样式引入 1.行类样式 &amp;lt;div style=&amp;quot;color:red;font-size:20px;&amp;quot;&amp;gt; 这是行内样式 &amp;lt;/div&amp;gt; 2.内部样式 &amp;lt;style&amp;gt; #demo{ color:red; font-size:20px; } &amp;lt;/style&amp;gt; &amp;lt;div id=&amp;quot;demo&amp;quot;&amp;gt; 这是内部样式 &amp;lt;/div&amp;gt; 3.外部样式 /*demo.css*/ #demo { color:red; font-size:20px; } &amp;lt;!-- demo.html --&amp;gt; &amp;lt;head&amp;gt; &amp;lt;link type=&amp;quot;text/css&amp;quot; href=&amp;quot;demo.</description>
    </item>
    
    <item>
      <title>HTML</title>
      <link>https://qingbingwei.github.io/post/html/</link>
      <pubDate>Wed, 06 Mar 2024 22:48:44 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/html/</guid>
      <description>HTML是Hyper Text Markup Language的简称，即超文本标记语言，是一种用于创建网页的标准标记语言。
HTML基本结构
&amp;lt;/body&amp;gt; 基本结构说明 表示定义的文档类型为 HTML5 文档。 &amp;lt;/html 表示整个 HTML 文档内容的定义只能在该标签对之间 表示整个 HTML 文档的头部信息，比如文档的标题、文档使用的字符集编码、文档是否可以缩放等。 表示定义文档的字符集编码为 &amp;ldquo;utf-8&amp;rdquo;，支持中文 表示定义文档显示的标题 表示 HTML 文档的主体内容部分应该定义在该标签内
注意:标签一般都是成对出现，分别叫开放标签和闭合标签
HTML标签 1.HTML 标签分类 块级标签（block elements） 块级标签特征 a. 总是在新行上开始 b. 高度，行高以及外边距和内边距都可控制 c. 宽度缺省是它的容器的100% d. 可以容纳内联元素和其他块元素
标签标题 &amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;二级标题&amp;lt;/h2&amp;gt; &amp;lt;h3&amp;gt;三级标题&amp;lt;/h3&amp;gt; &amp;lt;h4&amp;gt;四级标题&amp;lt;/h4&amp;gt; &amp;lt;h5&amp;gt;五级标题&amp;lt;/h5&amp;gt; &amp;lt;h6&amp;gt;六级标题&amp;lt;/h6&amp;gt; 水平线标签 &amp;lt;hr&amp;gt; 段落标签 &amp;lt;p&amp;gt; &amp;lt;!-- 段落内容 --&amp;gt; &amp;lt;/p&amp;gt; 无序列表标签 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;列表项1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;列表项2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;列表项3&amp;lt;/li&amp;gt; ...... &amp;lt;li&amp;gt;列表项n&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 有序列表标签 &amp;lt;!--可以通过type=&amp;quot;&amp;quot;指定序号--&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;列表项1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;列表项2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;列表项3&amp;lt;/li&amp;gt; ...... &amp;lt;li&amp;gt;列表项n&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; 表格标签 &amp;lt;table border=&amp;quot;12&amp;quot;&amp;gt;&amp;lt;!</description>
    </item>
    
    <item>
      <title>数据结构 红黑树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
      <pubDate>Tue, 05 Mar 2024 19:34:13 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
      <description>AVL树缺点: 1.不适合动态查找，为了保持平衡，不停的进行旋转调整，浪费时间 2.不直观
多路平衡树:多路平衡二叉树 B树 B+树 红黑树
索引存储
1.外存和内存进行数据交互比较慢 2.数据管理方案:通常会使用索引表进行数据查找和交互，由于外存中数据比较多，建立的索引表中的索引数据也会比较多，所以索引表也往往存储在外存中
多路平衡树:2-3-4-&amp;hellip;-n树:树的度(阶):n &amp;mdash;-&amp;gt; n阶B树 (不允许有高度差) 以2-3树为例(3阶B树) 由以下节点组成: (1)二叉节点:含有一个数据和两个孩子的节点，其中左子树的值均小于父亲节点，右子树的值均大于父亲节点 (2)三叉节点:含有两个数据和三个孩子的节点，并且数据之间保持顺序性
红黑树:用二叉树表示的4(或3)阶B树 把4阶B树中的3-，4-节点拆分为2-节点 注:红黑树一定是BST树 性质: 1.节点为红色或者黑色 2.根节点是黑色 3.所有外部叶子节点(NULL节点)是黑色 4.每个红色节点的两个子节点都是黑色(从根节点到每个叶子节点的路径不能有两个连续的红色节点) 5.从根节点到每个叶子节点的所有路径都包含相同数目黑色节点 注：从根节点到到叶子节点的黑色节点个数(黑高) 黑高相同&amp;mdash;&amp;ndash;&amp;gt;黑路同
结论: 1.从根节点到叶子节点的最长路径不大于最短路径的两倍 最短路径(bh):只有黑色节点 最长路径(2*bh):在最短路径基础上，每个黑色节点分下去一个红色节点 2.有n个内部节点的红黑树，其高度h&amp;lt;=2log(n+1) ----&amp;gt;红黑树操作时间复杂度O(logn) 证明:b&amp;lt;=2*bh-----&amp;gt;bh&amp;gt;=h/2 黑高bh 内部节点的数目最少:只有黑色节点的满二叉树 2^bh-1 n &amp;gt;= 2^bh-1 log(n+1)&amp;gt;=bh&amp;gt;=h/2 h&amp;lt;=2log(n+1) 红黑树的优点: BST----&amp;gt;AVL----&amp;gt;平衡因子的约束太严格了，需要频繁调整 -----&amp;gt;红黑树:一棵子树的高度最多可以是另一棵子树的2倍 1.⼤多数⾃平衡BST(self-balancing BST) 库函数都是⽤红⿊树实现的，⽐如C++中的map 和 set （或者 Java 中的 TreeSet 和 TreeMap）。 2.红⿊树也⽤于实现 Linux 操作系统的 CPU 调度。 完全公平调度（Completely Fair Scheduler）使⽤的就是红⿊树。 3.红⿊树也⽤于Linux提供的epoll多路复⽤的底层结构，便于快速增加、删除和查找⽹络连接的节点。 操作: 查找:特殊的BST,同BST RBT的插入:在一棵RBT中插入一个节点z 1.</description>
    </item>
    
    <item>
      <title>Qt学习</title>
      <link>https://qingbingwei.github.io/post/qt%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 02 Mar 2024 17:26:34 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/qt%E5%AD%A6%E4%B9%A0/</guid>
      <description>近期把Linux基本命令学习了一遍，考虑到准备开始学习数据结构中较难的红黑树等内容，暂且不学习其他需要投入较多时间的知识，最后决定同时了解学习一下qt，也算是初步接触一下图形化界面了。
Qt窗口坐标系: 左上角为远点，X向右增加，Y向下增加
Qt信号和槽 信号槽的优点,松散耦合m信号发送端和接收端本身没有关联， 通过connect连接将两端耦合在一起</description>
    </item>
    
    <item>
      <title>数据结构 基础查找</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Fri, 01 Mar 2024 15:28:19 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE/</guid>
      <description>基本概念 静态查找 数据集合稳定，不需要添加，删除元素的查找操作 动态查找 在数据集合进行查找的过程中，需要同时添加或删除元素的查找操作 关键字 数据元素中某个项的值，用它可以唯一标识一个数据元素 内查找和外查找 若整个查找过程都在内存中进⾏，则称之为内查找(internalsearch)； 反之，若查找过程的需要访问外存，则称之为外查找(external search)。 平均查找⻓度(Average Search Length，ASL) 注:ASL是衡量查找算法性能好坏的重要指标。 ⼀个査找算法的ASL越⼤，其时间性能越差； 反之，⼀个查找算法的ASL越⼩，其时间性能越好。 线性查找:顺序查找 二分查找 分块查找&amp;mdash;&amp;mdash;&amp;gt;静态查找 注:以上均基于比较查找 1.顺序查找 从表中的第⼀个（或者最后⼀个）记录开始，逐个进⾏记录的关键字和给定值的⽐较， 若某个记录的关键字和给定值⽐较相等，则查找成功。 如果查找了所有的记录仍然找不到与给定值相等的关键字，则查找不成功。
时间复杂度:O(n) 2.二分查找----前提，数据有序存放，存放在数组中(链表不适合) 确定待查记录所在的范围（区间），然后逐步缩⼩范围直到找到或者找不到该记录为⽌。 注意⼆分查找是在有序表上进⾏的，且⼆分查找也是分治思想的很好例证。 时间复杂度:O(logn) 判定树: 折半查找过程可⽤⼆叉树来描述，把当前查找区间的中间位置上的元素作为根， 由左⼦表和右⼦表构造的⼆叉树分别作为根的左⼦树和右⼦树，由此得到的⼆叉树称为描述折半查找过程的判定树 (deecision tree)或⽐较树(comparison tree)。 注:显然，判定树是⼀棵平衡⼆叉树,反之不成立 3.分块查找 索引存储结构 索引存储结构是在存储数据的同时还建⽴附加的索引表。索引表中的每⼀项称为索引项，索引项的⼀般形式为(关键字，地址)。 其中，关键字唯⼀标识⼀个结点，地址作为指向该关键字对应结点的指针，也可以是相对地址(如数组的下标)。 将査找表分为若⼲⼦块。块内的元素可以⽆序，但块之间是有序的，即第⼀个块中的最⼤关键字 ⼩于第⼆个块中的所有记录的关键字，第⼆个块中的最⼤关键字⼩于第三个块中的所有记录的关键字,以此类推。 再建⽴⼀个索引表，索引表中的每个元素含有各块的最⼤关键字和各块中的第⼀个元素的地址，索引表按关键字有序排列。 分块查找步骤 分块查找的过程分为两步： 第⼀步是在索引表中确定待查记录所在的块，可以顺序查找或折半査找索引表； 第⼆步是在块内顺序查找。
基于散列表的查找:哈希&amp;mdash;&amp;mdash;&amp;gt;动态查找 注:散列存储也叫hash存储 哈希查找&amp;mdash;散列查找&amp;mdash;&amp;ndash;&amp;gt;散列存储
哈希: key &amp;mdash;&amp;ndash;&amp;gt; 哈希函数 &amp;mdash;&amp;mdash;&amp;gt; Add(地址) 冲突:两个不同数据，计算出同一个地址 哈希函数如何设计 1.直接定址法:哈希函数设计为一次函数 h(key)=a*key+b 优点:不产生冲突 缺点:空间浪费大 2.除留余数法:哈希函数设计为对一个质数取余 h(key)=key%p p&amp;lt;=m的质数,m是散列表大小 缺点:冲突几乎必然存在，只能尽可能降低 3.平方取中法 4.数字分析法 5.折叠法</description>
    </item>
    
    <item>
      <title>Linux实例应用</title>
      <link>https://qingbingwei.github.io/post/linux%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 01 Mar 2024 07:34:29 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8/</guid>
      <description>1.每天凌晨2:30备份数据库day01到/data/backup/db; 2.备份开始和备份结束的时候，要给出相应的提示信息； 3.备份后的文件要以备份时间为文件名，并打包成tar.gz的格式，比如：2021-09-15_230201.tar.gz; 4.在备份的同时，要检查是否有10天前备份的数据库文件，如果有就将其删除。
注:cd /usr/sbin # 为什么要放在sbin目录，因为这个目录是root用户具备执行的权限
数据库用户名 DB_USER=root
数据库密码 DB_PW=Xml0607!
备份的数据库 DATABASE=day01
创建备份目录,如果目录不存在，则创建 只有[]里面的表达式为true 才会执行 &amp;amp;&amp;amp; 右边的内容 ${} 用来取文件名或文件路径 [ ! -d &amp;ldquo;${BACKUP}/${DATETIME}&amp;rdquo; ] &amp;amp;&amp;amp; mkdir -p &amp;ldquo;${BACKUP}/${DATETIME}&amp;rdquo;
备份数据库 mysqldump -u${DB_USER} -p${DB_PW} &amp;ndash;host=${HOST} -q -R &amp;ndash;databases ${DATABASE} | gzip &amp;gt; ${BACKUP}/${DATETIME}/$DATETIME.sql.gz
将文件打包成tar.gz格式 cd ${BACKUP} tar -zcvf $DATETIME.tar.gz ${DATETIME}
删除对应目录 rm -rf ${BACKUP}/${DATETIME}
删除十天之前备份文件 find ${BACKUP} -atime +10 -name &amp;ldquo;*.tar.gz&amp;rdquo; -exec rm -rf {} ; echo &amp;ldquo;数据库${DATABASE}备份成功&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Linux日志管理</title>
      <link>https://qingbingwei.github.io/post/linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 29 Feb 2024 20:14:56 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</guid>
      <description>日志的基本介绍：
日志文件是重要的系统信息文件，其中记录了很多重要的系统事件， 包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。 日志对于安全来说也很重要，它记录了系统每天发生的各种事情， 通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。 一句话理解日志：日志是用来记录重大事件的工具。
注:绝大多数的日志文件保存在/var/log目录中。
使用lastlog来查看/var/log/lastlog
使用root用户通过xshell7登录，第一次使用错误的密码，第二次使用正确的密码登录成功，查看日志文件/var/log/secure里面有没有记录相关信息。
cat secure 注:可以通过 echo &#39;&#39; &amp;gt; secure 清空secure文件中的内容 Linux日志管理服务
centos7日志服务是rsyslogd,centos6日志服务是syslogd。 rsyslogd日志服务功能更加强大。 注:rsyslogd的使用、日志文件的格式和syslogd是兼容的。 注:Linux日志服务帮助我们进行日志管理，是借助了/etc/rsyslog.conf配置文件来实现的。 ps aux | grep rsyslog 查看rsyslogd服务是否启动 systemctl list-unit-files | grep rsyslog 查询rsyslogd服务的启动状态 日志管理服务配置文件
管理日志的配置文件/etc/rsyslog.conf 日志文件的格式是 *.* 第一个*：代表日志类型 auth pam产生的日志 authpriv ssh ftp等登陆信息的验证信息 corn 时间任务相关的信息 kern 内核相关 lpr 打印相关的信息 mail 邮件相关的信息 mark(syslog)-rsyslog 服务内部信息 news 新闻组 user 用户程序产生的相关信息 local 1-7 自定义日志设备 第二个*：代表日志级别 debug 有调试信息的，记录的日志信息最多 info 一般日志信息，最常用 notice 提醒信息，需要检查一下程序了，不理会可能会出现错误。 warning 警告信息,当出现警告时，你的程序可能已经出现了问题,但不影响程序正常运行,尽快 进行处理，以免导致服务宕掉。 err 错误信息，出现这一项时，已经挑明服务出现了问题,服务都无法确认是否能正常运 行。 crit 严重级别，阻止整个系统或程序不能正常工作的信息 alert 需要立即修改的信息 emerg 记录内核崩溃等信息 none 什么都不记录 注：从上到下，日志级别从低到高，记录的信息也越来越少。 由日志服务rsyslogd记录的日志文件，日志文件的格式包含以下4列： 1.</description>
    </item>
    
    <item>
      <title>Linux_shell编程</title>
      <link>https://qingbingwei.github.io/post/linux_shell%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 29 Feb 2024 13:58:49 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux_shell%E7%BC%96%E7%A8%8B/</guid>
      <description>什么是shell:
Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序， 用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。 学习shell的原因:
1.Linux 运维工程师在进行服务器集群管理时，需要编写 Shell 程序来进行服务器管理。 2.对于 JavaEE 和 Python 程序员来说，工作的需要，会要求你编写一些 Shell 脚本进行程序或者是服务器的维护， 比如编写一个定时备份数据库的脚本。 3.对于大数据程序员来说，需要编写 Shell 程序来管理集群。 shell脚本的编写执行方式:
1.格式要求 脚本以#!/bin/bash 开头 脚本需要有可执行权限 2.脚本的常用执行方式 给要执行的脚本文件，添加可执行权限，使用./运行 直接用 sh 脚本文件名 命令执行，不用赋予脚本可执行权限 shell的变量
Linux 中 Shell 的变量分为系统变量和用户自定义变量。 系统变量:HOME,SHELL,PWD,USER 查询指定系统变量: echo $HOME 注:我们可以使用set命令显示当前 Shell 中所有变量。 用户自定义变量 1.普通变量 A=100 2.静态变量 readonly B=2 注:变量定义规则 1.变量名称可以由字母、数字和下划线组成，但是不能以数字开头。 2.等号两侧不能有空格。 3.变量名称一般习惯为大写，这是一个规范，大家遵守即可。 设置环境变量(修改/etc/profile) 1.export 变量名=变量值：将 Shell 变量输出为环境变量/全局变量。 2.source 配置文件：让修改后的配置文件立即生效 3.echo $变量名：查询环境变量的值 注:多行注释 :&amp;lt;&amp;lt;! 需要注释的第一行内容 需要注释的第二行内容 !</description>
    </item>
    
    <item>
      <title>Linux_rpm和yum</title>
      <link>https://qingbingwei.github.io/post/linux_rpm%E5%92%8Cyum/</link>
      <pubDate>Wed, 28 Feb 2024 22:32:01 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux_rpm%E5%92%8Cyum/</guid>
      <description>rpm
注:RPM是redhat package manage（软件包管理工具的缩写），类似于setup.exe 查询所有安装的rpm列表 rpm -qa rpm -qa | more 分页展示所有的rpm列表 查询当前系统中是否安装了指定的软件 rpm -qa | grep firefox 查询linux系统中是否已经安装了火狐浏览器 firefox-60.8.0-1.el7.centos.x86_64 一个rpm包的名称命名规则： firefox：rpm包名 60.8.0-1.el7：rpm包的版本号 centos：rpm包适用于的操作系统 x86_64：适用于64位的操作系统。(如果是i686或者i386说明适用于32位操作系统，noarch表示通用。) 查看软件包是否安装 rpm -q firefox 查看火狐浏览器是否存在rpm包(安装) 查询软件安装的详细信息 rpm -qi firefox 查询火狐浏览器的详细安装信息 查看rpm包安装之后的文件 rpm -ql firefox 查看firefox安装之后的文件 查看指定的文件所属的rpm包 rpm -qf /etc/firefox/pref 查询/etc/firefox目录下面的pref文件所属的rpm包 删除rpm包文件 rpm -e firefox 删除firefox 注:如果其它的软件包依赖于要删除的软件包，卸载时则会产生错误。 此时如果我们想强制删除，可以添加另外的参数--nodeps。 强制删除rpm包文件 rpm -e --nodeps firefox #删除firefox 安装rpm包 rpm -ivh RPM包全路径名称 i=install 安装 v=verbose 提示 h=hash 进度条 yum
注:Yum是一个Shell前端软件包管理器，基于RPM包管理，能够从指定的服务器自动下载RPM包并安装， 并且可以自动处理依赖性关系，并且一次安装所有的依赖软件包。 查询yum服务器上是否有需要安装的软件： yum list | grep xxx软件列表 下载并安转指定的yum包： yum install xxx 的rpm包名 </description>
    </item>
    
    <item>
      <title>Linux动态监控</title>
      <link>https://qingbingwei.github.io/post/linux%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7/</link>
      <pubDate>Mon, 26 Feb 2024 22:18:56 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7/</guid>
      <description>Linux动态监控
top 用来显示正在执行的进程的信息 -d秒数 指定top命令每隔几秒刷新，默认3秒 -i 使用top不显示任何闲置或者僵死的进程 -p 通过指定监控ID来仅仅监控某个进程的状态 top指标信息 top -时间: top命令刷新进程的时间 up:系统运行的时长 user:当前linux系统上面的用户数 load average: 负载值（三个数字相加(0.04+0.07+0.18)除以3 的值&amp;gt;0.7说明负载值很大） Tasks:总进程数 ruuning: 正在运行的进程数 sleeping:休眠的进程数 stopped:停止的进程数 zombie:僵死的进程数 %(CPU): CPU负载百分比 us:用户占用cpu百分比 sy:系统占用cpu百分比 id:空闲cpu百分比 Mem:描述内存占用情况 total:总共内存 free 空余内存 used：使用了的内存 buff/cache：缓存 Swap:描述交换区内存占用情况 top指令的交互操作 P 以CPU使用率来排序，默认就是此项 M 以内存使用来排序 N 以PID排序 q 退出top 监控特定用户 输入u 再输入用户名 终止指定进程 输入k 然后输入要结束的进程ID号 回车之后输入9 强制删除。 netstat 监控网络状态 -an 按照一定的属性排列输出 -p 显示哪个进程在调用 netstat指标信息 Local Address:本机linux的ip地址 Foreign Address:外部的网络地址 Proto:网络协议 127.0.0.1 / 0.0.0.0: 当前linux机器的本地地址 631/25/6060.</description>
    </item>
    
    <item>
      <title>Linux服务管理</title>
      <link>https://qingbingwei.github.io/post/linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 26 Feb 2024 20:58:48 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
      <description>service(本质)就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求 比如说(mysql3306，sshd222)，因为又称为守护进程，在Linux中是重要的知识点。
Linux服务管理
service
注:在CentOs7.0后，很多服务不再使用Service，而是systemctl service 指令管理的服务在/etc/init.d查看 service network status 查看network服务的状态 service network stop 关闭network 此时Xshell连接linux会连接不上 service network start 重启network 此时Xshell会连接上linux setup 查看更多的系统服务 chkconfig chkconfig --list 查看服务 chkconfig --level 级别 network on/off 设置服务在指定级别启动/关闭 systemctl
注:systemctl 指令管理的服务在/usr/lib/systemd/system中查看。 systemctl [start | stop | restart | status] 服务名 服务启动/停止/重启/重载/查看状态： systemctl list-unit-files 查看所有服务的自启动状态 服务的状态如下： masked 此服务禁止自启动 static 该服务无法自启动，只能作为其他文件的依赖 enabled 已配置为自启动 disabled 未配置为自启动 systemctl is-enabled 服务名 查看某一服务是否自启动 systemctl enable 服务名 设置服务自启动 (服务运行级别 3、5) systemctl disable 服务名 设置服务禁用自启动 (服务运行级别 3、5) 防火墙指令</description>
    </item>
    
    <item>
      <title>Linux进程管理</title>
      <link>https://qingbingwei.github.io/post/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 25 Feb 2024 23:59:27 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
      <description>每个进程都可能以两种形式存在，前台和后台
前台进程就是及用户在目录上可以进行操作的（占用屏幕 比如我们的top指令） 后台是无法在屏幕上操作的进程。 注:一般系统的服务进程都是以后台进程的方式存在，而且会常驻在系统中直到关机才结束。 查看系统运行进程
ps 用来查看系统中哪些进程正在运行，以及他们的运行的状况 PID 进程识别号 TTV 终端机号 TIME 此进程所消耗cpu时间 CMD 进程名或执行对应进程的命令 -a 显示进程终端的详细信息 -e 显示所有进程 -f 全格式显示 -u 以用户格式显示进程信息 -x 显示后台进程运行的参数 ps -aux | more 分页展示进程信息 USER: 进程所属的用户名称。 PID:进程号。 %CPU:进程占用CPU的百分比。 %MEM:进程占用物理内存的百分比。 VSZ:进程占用虚拟内存的大小(KB)。 RSS:进程占用物理内存的大小(KB)。 STAT:进程状态，S-代表睡眠 R-正在运行 D-短期等待 Z-僵死进程 T-被停止的线程。 START:进程启动的时间。 TIME:进程使用CPU的时间。 COMMAND:进程启动所需要的命令和参数。 ps -ef | grep 进程名称 查看指定进程信息 kill 终止进程 kill 进程号 kill -9 进程号 强制杀死某个进程 注:关闭远程登陆服务后，我们可以使用/bin/systemctl start sshd.service重启sshd服务 killall 杀死当前进程及其子进程 killall 进程名 查看进程树
pstree 查看进程树 -p 显示进程id -u 显示进程用户 </description>
    </item>
    
    <item>
      <title>Linux_NAT网络配置</title>
      <link>https://qingbingwei.github.io/post/linux_nat%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 25 Feb 2024 17:42:47 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux_nat%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</guid>
      <description>Linux网络配置的指令
ipaddr 在linux查看ip地址 ifconfig 在linux查看ip地址 ping 是否ping通指定的ip地址 ipconfig 在windows操作系统里面查看网络的ip地址 Linux网络环境配置（固定ip的方式）
1.编辑我们linux的网卡文件 这个网卡文件在/etc/sysconfig/network-scripts/ifcfg-ens33 2.编辑网卡文件ifcfg-enss33 3.重启网络服务(systemctl restart network)或者重启系统(reboot) Linux主机名和host映射
注:可以修改/etc/hostname指定主机名名称。注意，修改完成之后，需要重启linux系统才能生效。 将主机名称和ip地址进行映射 在windows里面通过本机的主机名来ping通Linux，我们需要修改windows的hosts文件。 找到C:\Windows\System32\drivers\etc下面的hosts文件，进行相关的编辑 192.168.146.135 xq100 ip地址是linux的ip地址 在linux里面通过本机的主机名来ping通主机,我们需要编辑/etc/hosts文件。 192.168.0.178 主机名称 ip是windows所连网络的ip地址 后面的是windows的主机名称 </description>
    </item>
    
    <item>
      <title>Linux磁盘分区</title>
      <link>https://qingbingwei.github.io/post/linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</link>
      <pubDate>Sun, 25 Feb 2024 13:43:58 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</guid>
      <description>Linux磁盘分区机制
1.Linux 系统中的文件系统的总体结构是一定的：只有一个根目录，根目录下的目录结构独立且唯一 （如 /boot、/dev、/bin、/etc 目录等都是唯一的），Linux 中的磁盘分区都是文件系统中的一部 分。 2.计算机的硬盘可以有多个、磁盘上的分区也可以有多个。 但每个磁盘要想连接到 Linux 系统中，需要将分区“映射”到文件系统的某一个目录下， 这样访问目录即可访问对应硬盘分区，这种映射称为“挂载”。 3.任何目录或其父目录都要挂载到硬盘的某个分区下。 如需要将某一分区挂载到根目录下，Linux 系统才能正常工作。 4.某个分区所挂载的目录，称为此分区的挂载点。 5.磁盘的不同分区可以挂载到 Linux 文件系统的不同分区下，但不能同时挂载到一个相同的目录。 注:我们可以使用lsblk命令来查看详细的磁盘分区信息
Linux硬盘类型
IDE硬盘 hdx~ hd:标识硬盘类型 IDE硬盘类型 x:不同的硬盘(a基本盘 b基本从属盘 c辅助盘 d辅助从属盘) ~:磁盘分区 1 2 3 4 5 SCSI硬盘 sdx~ sd:标识硬盘类型 SCSI硬盘类型 x:描述是第几块硬盘(a第一块硬盘 b第二块硬盘 c第三块硬盘 d第四块硬盘) ~:磁盘分区 1 2 3... 我们也可以查看分区的详细信息： [root@xq100 ~]# lsblk -f NAME FSTYPE LABEL UUID MOUNTPOINT sda ├─sda1 xfs 72921afb-f2fa-4b12-9338-28b31d19d15a /boot ├─sda2 swap 6b47cbdc-9db2-4e27-9309-3898c51b3d5f [SWAP] └─sda3 xfs 569b448b-1d35-47d6-929d-ad256d81d19d / sr0 iso9660 CentOS 7 x86_64 2019-09-11-18-50-31-00 注: NAME ：驱动器标识 FSTYPE ：文件系统类型 LABLE ：文件系统 LABLE UUID ：分区唯一标识符，格式化磁盘后，会给分区分配一个32位的唯一的字符串 MOUNTPOINT ：挂载点 给新增的硬盘分区</description>
    </item>
    
    <item>
      <title>Linux定时任务调度</title>
      <link>https://qingbingwei.github.io/post/linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Sun, 25 Feb 2024 11:23:30 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</guid>
      <description>定时任务调度:指每隔指定的时间，执行特定的命令或程序(脚本)
任务调度命令:
crontab
-e 编辑定时任务 -l 查询定时任务 -r 删除定时任务 例.创建一个定时任务，将etc目录下面的文件列表查询出来，追加到/tmp/etc.txt文件中，并每分钟执行1次。 */1 * * * * ls -l /etc/ &amp;gt; /tmp/etc.txt 占位符含义 第一个 “*” 一个小时当中的第几分钟 0-59 第二个 “*” 一天当中的第几个小时 0-23 第三个 “*” 一个月当中的第几天 1-31 第四个 “*” 一年当中的第几个月 1-12 第五个 “*” 一周当中的星期几 0-7(0和7都代表星期日) 特殊符号 * 代表任何时间，比如第一个“*”就代表1小时中每分钟都执行1次的意思。 ， 代表不连续的时间，比如“0 8,12,16 * * *”就代表1天中的8点过0分，12点过0分，16点过0分都会执行1次。 - 代表连续的世间范围，比如“0 5 * * 1-6”就代表星期1到星期6的凌晨5点过0分都会执行。 */n 代表每隔多久执行1次。比如“*/10 * * * *” 就代表每隔10分钟就执行1次命令。 注:service crond restart [重启任务调度] at
机制介绍: 1. at命令是一次性定时执行任务计划，at的守护线程atd以后台的模式运行，检查作业队列来运行。 2.</description>
    </item>
    
    <item>
      <title>Linux组管理和权限管理</title>
      <link>https://qingbingwei.github.io/post/linux%E7%BB%84%E7%AE%A1%E7%90%86%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 24 Feb 2024 23:54:50 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E7%BB%84%E7%AE%A1%E7%90%86%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid>
      <description>Linux组的介绍
Linux里面的文件，属于对应的用户，也属于用户对应的组 修改文件所属的用户 chown 用户名 文件名 chown xq apple.txt 将当前文件的所属用户变成xq 修改文件所在的组 chgrp 组名 文件名 chgrp monster apple.txt 修改用户所属的组 usermod -g 组名 用户名 Linux的权限介绍
总共10位，我们使用0-9来描述。 第0位确定文件类型(d,-,l,c,b) 1.l是软连接，相当于windows的快捷方式 2.d是目录，相当于windows的文件夹 3.c是字符设备，鼠标，键盘(/dev 目录里面查看) 4.b是块设备，比如说硬盘(/dev 目录里面查看) 5.-是文件 第1-3位确定所有者（该文件的所有者）拥有该文件的权限 --User rwx作用到文件 r 代表可读 read 可以读取，查看 w 代表可写 write 可以修改，但是不代表可以删除改文件，删除一个文件的前提条件是对该 文件所在的目录有写权限，才能删除文件 x 代表可执行 execute 可被执行 rwx作用到目录 r 代表可读 可以读取 ls查看目录的内容 w 代表可写 对目录内进行创建+删除+重命名该目录 x 代表可执行 可以进入该目录 第4-6位确定所属组，（同用户组的）又有该文件的权限 --Group 同上 第7-9位确定其他用户拥有改文件的权限 --Other 同上 chmod 修改文件权限 chmod u=rwx,g=rx,o=rx hello.c++ chmod u-r,g+w,o+w hello.</description>
    </item>
    
    <item>
      <title>Linux其他指令</title>
      <link>https://qingbingwei.github.io/post/linux%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Sat, 24 Feb 2024 16:06:37 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4/</guid>
      <description>Linux时间指令
date 显示当前时间 1. +%Y 显示当前年份 2. +%m 显示当前月份 3. +%d 显示当前是哪一天 4. +%H 显示当前时间小时部分 5. +%M 显示当前时间分钟部分 6. +%S 显示当前时间秒部分 7. &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot; 显示年月日时分秒 8. date -s 字符串时间 设置系统时间 例.date -s &amp;quot;2022-8-28 15:48:50&amp;quot; cal 日历指令 1.cal 显示本月日历 2.cal 2022 显示整年的日历 Linux搜索，查找指令
find 搜索原理是遍历(遍历)指定文件目录,找到匹配文件 -name 按照文件名称进行搜索 -user 按照指定用户所属文件搜索 -size 按照文件大小搜索 注:find /home/xq -name &#39;*.txt&#39; 查询所有txt文件 例.查找整个linux系统下，大于200M的文件 （+n大于,-n小于，n等于）单位还有K，M，G find / -size +200M 查询大于200M的文件 locate 快速搜索指定文件 它不是递归遍历，使用了locate数据库 注:由于locate指令基于数据库进行查询。 所以第一次查询运行前，必须使用updatedb指令创建locate数据库。 updatedb 一定要先执行这个指令 which 查看指令在哪个目录下 grep(一般配合管道符号 | 一起使用) 过滤查找 -n 显示行号 -i 忽略自动大小写 例.</description>
    </item>
    
    <item>
      <title>Linux基础操作</title>
      <link>https://qingbingwei.github.io/post/linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 21 Feb 2024 15:08:23 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid>
      <description>Linux的关机与重启
1.shutdown shutdown -h now 立即关机 shutdown -h 1 一分钟后关机 shutdown -r now 立即重启 2.halt 关机 3.sync 同步内存中的数据到硬盘 4.reboot 重启系统 注:
1.不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写入到磁盘中。 2.目前的shutdown、reboot、halt命令在关机前都进行了sync。 用户的登录和注销:
1.切换用户命令 su 用户名称 2.注销当前用户 exit 注:在切换用户的时候，如果从低级别的用户切换到高级别的用户，需要输入密码的(xq &amp;ndash;&amp;gt; root)。 如果从高级别的用户切换到低级别的用户(root &amp;ndash;&amp;gt; xq)，那么是不需要输入密码的。
Linux用户管理
注:创建用户权限只有管理员才有，我们一般在root用户下面创建用户
创建用户 useradd 用户名 创建用户，并且自定义用户目录名称 useradd -d 目录名称 用户名称 useradd -d /home/test king 设置用户密码 passwd 用户名 删除用户 userdel 用户名 (只是删除用户数据，对应目录不删除) 删除用户数据的同时也会删除用户目录 userdel -r 用户名 查询用户信息 id 用户名 获取当前用户名称 whoami 获取当前登录用户的详细信息 who am i Linux用户组管理</description>
    </item>
    
    <item>
      <title>Linux学习</title>
      <link>https://qingbingwei.github.io/post/linux%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 16 Feb 2024 11:30:51 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/linux%E5%AD%A6%E4%B9%A0/</guid>
      <description>在开始练习算法的同时，学习了解一下Linux操作系统。
Linux磁盘分区:(20G)
1./boot:引导分区，保存Linux启动需要用到的引导程序和文件 1G 2.swap:交换区，如果Linux内存不够用，swap分区会临时充当内存 2G 3./:根分区 17G Linux系统中三种网络连接方式
1.桥接模式:在虚拟机里面的网络地址必须和外部的网络地址保持在同一网段(IPv4为例，前三位相同)。 这样Linux操作系统才可以和外部的机器进行通信。但是如果用户数量太多容易造成IP冲突 2.NAT模式(网络地址转换):在NAT模式下，虚拟机里面的网络可以不再和主机里面的网络保持在同一网段。但是主机里面会存在虚拟网卡。 这个虚拟网卡的IP地址必须和Linux里面的IP地址在同一网段。 这样Linux就可以通过虚拟网卡和主机之间进行通信。 同时我们的Linux操作系统也可以和外部的网络进行通信 3.仅主机模式:Linux系统的地址必须和主机IP地址保持一致 虚拟机的克隆:
在选择克隆类型的时候，有两种
1.创建链接克隆。这种克隆的方式占用的磁盘空间较小，克隆时间更快。本质上还是使用原来的 linux操作系统，只是克隆了原linux操作系统的引用。 2.创建完整克隆。这种克隆的方式占用是磁盘空间较大，克隆时间比较慢，相当于把原来的linux 操作系统复制了一份。一般我们选择完整克隆。 虚拟机的快照:
VMware的菜单栏中有虚拟机快照这个选项，形象来说快照就相当于一个备份文件， 记录的是虚拟机运行到某一节点时的状态，在虚拟机的使用过程中如果发生了意外， 比如系统崩溃或系统异常，此时如果事先保存了快照，就可以选择恢复到快照， 即将虚拟机的磁盘文件系统和存储系统恢复到留下快照的那个节点，以恢复虚拟机的正常使用。 Linux目录结构:
linux文件系统采用的是层级式的树状目录结构，其中最上层的根目录是&amp;quot;/&amp;quot;，然后在此目录下面再创建其他的目录。 Linux目录结构详解:
/bin目录: 是Binary的缩写, 这个目录存放着最经常使用的命令。 比如我们常用的cd命令 cp命令都是存放在bin目录里面。 /sbin目录: s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /home目录: 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root目录: 该目录为系统管理员（root），也称作超级权限者的用户主目录。 如果我们使用root账户登录，默认所处的目录位置就是在/root下面。 /lib目录: 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 几乎所有的应用程序都需要用到这些共享库。 如果这个目录里面的文件被删除了，linux操作系统也就不能正常运行了。 /etc目录: 所有的系统管理所需要的配置文件和子目录。 linux系统本身所需要用到的配置文件也是存放在etc目录。 如果我们自己安装一些系统服务，比如mysql数据库服务，那么和数据库相关的配置文件(my.cnf)也是存放在/etc目录里面。 /boot目录: 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 如果这个目录里面的文件被删除了，linux操作系统也就不能正常运行了。 /dev目录: 类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /proc目录: 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统的信息。 这个目录我们不要动，否则可能造成系统的崩溃。 /tmp目录: 这个目录是用来存放一下临时文件的。 /sys目录: 这个目录存放了linux内核相关的文件信息。 这个目录我们不要动，否则可能造成系统的崩溃。 /media目录: linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 比如我们插入的U盘 光驱都会被映射成对应的文件存放在media目录。 /mnt目录: 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 比如共享目录Linux-common。 /opt目录: 这是主机给安装软件所存放的目录 /usr/local目录: 简单的说就是应用程序安装之后，安装程序所存放的目录。 一般是通过编译源码方式安装的程序。(类似于Windows系统的program file) /var目录: 这个目录中存放着在不断变化，扩充着的东西，最常用的就是包括各种日志文件。 Linux远程登陆:</description>
    </item>
    
    <item>
      <title>数据库设计</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 08 Feb 2024 10:59:30 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</guid>
      <description>-- 1.创建存储过程的语法 CREATE PROCEDURE 存储过程的名称(IN|OUT 参数名1 参数类型1,...,IN|OUT 参数名n 参数类型n) BEGIN END -- 2.创建函数的语法 CREATE FUNCTION 存储过程的名称(参数名1 参数类型1,..., 参数名n 参数类型n) RETURNS 数据类型 -- 函数类型 DETERMINISTIC | NO SQL | READ SQL DATA | CONTAINS SQL BEGIN RETURN 结果; END -- 3.创建触发器的语法 CREATE TRIGGER 触发器名称 BEFORE|AFTER INSERT|UPDATE|DELETE ON 表名 FOR EACH ROW BEGIN END -- 4.创建视图的语法 CREATE OR REPLACE VIEW 视图名称 AS SELECT 语句; 设计数据库 1.什么是实体: 实体就是软件开发过程中所涉及到的事物，通常都是一类数据对象的个体。 2.什么是数据库设计: 数据库设计就是将实体与实体之间的关系进行规划和结构化的过程 3.为什么要进行数据库设计: 当存储的数据比较少的时候，当然不需要对数据库进行设计。 但是，当对数据的需求量越来越大时，对数据库的设计就很有必要性了！ 如果数据库的设计不当，会造成数据冗余、修改复杂、操作数据异常等问题。 而好的数据库设计，则可以减少不必要的数据冗余，通过合理的数据规划提高系统的性能 4.</description>
    </item>
    
    <item>
      <title>存储过程、函数和触发器</title>
      <link>https://qingbingwei.github.io/post/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Thu, 08 Feb 2024 10:58:45 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description>1.查询有哪些分类 1.内连接： 衔接的多表必须保证数据一一对应才可能展示结果 2.左外连接：衔接的主表（LEFT JOIN 左边的表为主表）为准，从表中没有的数据以NULL形式展示 3.右外连接：衔接的主表（RIGHT JOIN 右边的表为主表）为准，从表中没有的数据以NULL形式展示 2.子查询有哪些分类 1.在 SELECT . FROM 之间：执行时机就是查询出结果后执行 2.在 FROM . WHERE 之间：执行时机是一开始就先执行 3.在 WHERE 之后：执行时机是筛选数据时执行 变量: 在MySQL中，变量分为四种类型，即局部变量、用户变量、会话变量和全局变量。 其中局部变量和用户变量在实际应用中使用较多，会话变量和全局变量使用较少，因此作为了解即可。 1.全局变量: MySQL全局变量会影响服务器整体操作，当服务启动时，它将所有全局变量初始化为默认值。 要想更改全局变量，必须具有管理员权限。 其作用域为服务器的整个生命周期。 -- 显示所有的全局变量 SHOW GLOBAL VARIABLES; -- 设置全局变量的值的两种方式 SET GLOBAL sql_warnings = ON; -- GLOBAL不能省略 SET @@GLOBAL.sql_warnings = OFF; -- 查询全局变量的值的两种方式 SELECT @@GLOBAL.sql_warnings; SHOW GLOBAL VARIABLES LIKE &#39;%sql_warnings%&#39;; 2.会话变量: MySQL会话变量是服务器为每个连接的客户端维护的一系列变量。 其作用域仅限于当前连接，因此，会话变量是独立的。 -- 显示所有的会话变量 SHOW SESSION VARIABLES; -- 设置会话变量的值的三种方式 SET SESSION auto_increment_increment = 1; SET @@SESSION.</description>
    </item>
    
    <item>
      <title>MySQL联表查询</title>
      <link>https://qingbingwei.github.io/post/mysql%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Thu, 08 Feb 2024 10:58:15 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/mysql%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/</guid>
      <description>-- 求字符串的字符数 SELECT CHAR_LENGTH(&#39;abc&#39;); -- 将字符串&amp;quot;超用心&amp;quot;和&amp;quot;在线教育&amp;quot;拼接成新的字符串 SELECT CONCAT(&#39;超用心&#39;,&#39;在线教育&#39;); -- 求&amp;quot;&amp;quot;到现在一共有多少天 SELECT TIMESTAMPDIFF(DAY,&#39;2019-05-04&#39;,NOW()); -- 如果字段score的值大于90，则展示为优秀，否则展示为良好 SELECT IF(score&amp;gt;90,&#39;优秀&#39;,&#39;良好&#39;) FROM stu; 1.表与表之间的关系: 数据库通过主外键关联关系来体现表与表之间的关联关系。 2.主外键关联关系 学生表和班级表并没有任何关系，然而实际上学生和班级是存在归属关系。 可以在学生表中添加一个字段，表名该学生所属班级，该字段值使用的是班级表中的主键，在学生表中称之为外键。 这样学生表中的所属班级（外键）与班级表中的编号（主键）就产生关联关系，这种关联关系称为主外键关联关系。 3.主外键关联关系的定义 DROP TABLE IF EXISTS class; CREATE TABLE class( id INT(11) AUTO_INCREMENT PRIMARY KEY NOT NULL COMMENT &#39;班级编号&#39;, name VARCHAR(30) NOT NULL COMMENT &#39;班级名称&#39;, grade VARCHAR(30) NOT NULL COMMENT &#39;年级&#39;, )ENGINE=InnoDB CHARSET=UTF8 COMMENT=&#39;班级表&#39;; DROP TABLE IF EXISTS stu; CREATE TABLE stu( number BIGINT(20) AUTO_INCREMENT NOT NULL COMMENT &#39;学号&#39;, name VARCHAR(30) NOT NULL COMMENT &#39;姓名&#39;, sex VARCHAR(2) NOT NULL DEFAULT &#39;男&#39; COMMENT &#39;性别&#39;, age TINYINT(3) NOT NULL DEFAULT 0 COMMENT &#39;年龄&#39;, class_id INT(11) NOT NULL COMMENT &#39;所属班级&#39;, -- 指定number为主键 PRIMARY KEY(number), -- 指定class_id外键,关联的是class表中id字段 FOREIGN KEY(class_id) REFERENCES class(id) )ENGINE=InnoDB CHARSET=UTF8 COMMENT=&#39;学生表&#39;; 4.</description>
    </item>
    
    <item>
      <title>MySQL数据库的常用函数</title>
      <link>https://qingbingwei.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 08 Feb 2024 10:57:15 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>-- 创建数据库 CREATE DATABASE IF NOT EXISTS exercise DEFAULT CHARACTER SET UTF8 COLLATE UTF8_GENERAL_CI; -- 使用数据库 USE exercise; -- 创建一个员工表 CREATE TABLE IF NOT EXISTS emp( id BIGINT(20) AUTO_INCREMENT PRIMARY KEY NOT NULL COMMENT &#39;员工编号&#39;, name VARCHAR(20) NOT NULL COMMENT &#39;姓名&#39;, sex VARCHAR(2) DEFAULT &#39;男&#39; COMMENT &#39;性别&#39;, age TINYINT(3) UNSIGNED NOT NULL COMMENT &#39;年龄&#39;, dept VARCHAR(20) NOT NULL COMMENT &#39;所属部门&#39;, salary DOUBLE(10, 2) NOT NULL COMMENT &#39;薪资&#39; )ENGINE=InnoDB CHARSET=UTF8 COMMENT=&#39;员工表&#39;; -- 插入测试数据 INSERT INTO emp(id, name ,sex, age, dept, salary) VALUES(DEFAULT, &#39;张三&#39;, &#39;男&#39;,22, &#39;研发部&#39;, 13000); INSERT INTO emp(name ,sex, age, dept, salary) VALUES(&#39;李刚&#39;, &#39;男&#39;, 24, &#39;研发部&#39;,14000); INSERT INTO emp VALUES(DEFAULT, &#39;金凤&#39;, &#39;女&#39;, 23, &#39;财务部&#39;, 8000); INSERT INTO emp(name ,sex, age, dept, salary) VALUES(&#39;肖青&#39;, &#39;女&#39;, 26, &#39;财务部&#39;,9000), (&#39;张华&#39;, &#39;男&#39;, 28, &#39;研发部&#39;, 15000),(&#39;董钰&#39;, &#39;女&#39;, 24, &#39;研发部&#39;, 12000); INSERT INTO emp VALUES(DEFAULT, &#39;吴梅&#39;, &#39;女&#39;, 24, &#39;测试部&#39;, 9000),(DEFAULT, &#39;王玲&#39;,&#39;女&#39;, 26, &#39;测试部&#39;, 9500); -- 吴梅因工作出色而被提升为测试主管，薪资调整为11000 UPDATE emp SET salary=11000 WHERE name=&#39;吴梅&#39;; -- 研发部金凤离职 DELETE FROM emp WHERE name=&#39;金凤&#39;; -- 从员工表中查询出平均年龄小于25的部门 SELECT dept FROM emp GROUP BY dept HAVING AVG(age)&amp;lt;25; -- 从员工表中统计研发部的最高薪资、最低薪资、平均薪资和总薪资 SELECT MAX(salary),MIN(salary),AVG(salary),SUM(salary) FROM emp WHERE dept=&#39;研发部&#39;; -- 从员工表中统计各个部门的员工数量 SELECT dept, COUNT(*) FROM emp GROUP BY dept; -- 从员工表中查询薪资在10000以上的员工信息并按薪资从高到低排列 SELECT * FROM emp WHERE salary&amp;gt;10000 ORDER BY salary DESC; -- 从员工表中分页查询员工信息，每页显示5条员工信息，按薪资从高到低排列，查询第2页员工信息 SELECT * FROM emp ORDER BY salary DESC LIMIT 5,5; --MySQL修改root密码 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;; MySQL常用函数: 1.</description>
    </item>
    
    <item>
      <title>数据库的增删改查</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
      <pubDate>Thu, 08 Feb 2024 10:56:40 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
      <description>-- 创建数据库 CREATE DATABASE IF NOT EXISTS exercise DEFAULT CHARACTER SET UTF8 COLLATE UTF8_GENERAL_CI; -- 使用数据库 USE exercise; -- 创建数据表 CREATE TABLE IF NOT EXISTS stu_course( `number` INT(11) AUTO_INCREMENT PRIMARY KEY NOT NULL COMMENT &#39;课程编号&#39;, name VARCHAR(20) NOT NULL COMMENT &#39;课程名称&#39;, score DOUBLE(5,2) NOT NULL COMMENT &#39;学分&#39; ) ENGINE=InnoDB CHARSET=UTF8 COMMENT=&#39;课程表&#39;; -- 修改数据表 ALTER TABLE stu_course RENAME AS course; -- 增加字段 ALTER TABLE course ADD `time` INT(3) NOT NULL COMMENT &#39;学时&#39;; -- 修改字段 ALTER TABLE course MODIFY score DOUBLE(3,1) NOT NULL COMMENT &#39;学分&#39;; DML语句（Data Mainpulation Language）:数据操作语言，对数据操作，而非数据表 INSERT语句 -- 需要注意，VALUES后的字段值必须与表名后的字段名一一对应 INSERT INTO 表名(字段名1,字段名2.</description>
    </item>
    
    <item>
      <title>数据结构 归并和计数排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BD%92%E5%B9%B6%E5%92%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 04 Feb 2024 17:45:25 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BD%92%E5%B9%B6%E5%92%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>1.2-路归并排序：先将所有的数据完全分开，然后两两合并，在合并过程中将其排好序，最终得到一个完整的有序表。 时间复杂度：O(nlogn) 是否稳定：稳定 为非就地排序 2.基于统计的排序 1.计数排序：统计一下每个数出现的次数，然后直接按次数输出 //以空间换时间 时间复杂度：O(n) 是否稳定：稳定 缺点： 1.无法对负整数和浮点数排序 优化：引入偏移量便可以对负整数进行排序 对浮点数全部乘以10^n,便可以对浮点数排序 2.极其浪费空间内存 2.桶排序:桶编号规则人为确定，可以n/10，也可以n/100,将数据放入桶后，对每个桶进行排序 //以空间换时间 时间复杂度：O(nlogn) 3.基数排序：类似于将桶排序与计数排序结合，从待排序数组当中，元素的最低有效位到最⾼有效位,逐位进⾏⽐较排序；此外，基数排序使⽤计数排序作为⼀个排序的⼦过程。 时间复杂度:O(n * log以b为底n),b为进制数 为非就地排序 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; //将区间[left,mid][mid+1,right]数据合并 void Merge(vector&amp;lt;int&amp;gt;(&amp;amp;v), int left, int mid, int right) { int i(left); int j(mid + 1); //临时存储 vector&amp;lt;int&amp;gt; v2(v); int k(0); while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if (v[i] &amp;lt;= v[j]) { v2[k] = v[i]; ++i; ++k; } else { v2[k] = v[j]; ++j; ++k; } } while (i &amp;lt;= mid) { v2[k] = v[i]; ++i; ++k; } while (j &amp;lt;= right) { v2[k] = v[j]; ++j; ++k; } for (int q = 0; q &amp;lt; k; ++q) { v[left + q] = v2[q]; } } //将区间[left,right]数据二分 void Merge_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v),int left,int right) { //元素大于等于两个 if (left &amp;lt; right) { int mid((left + right) / 2); //left---mid Merge_Sort(v, left, mid); //mid + 1---right Merge_Sort(v, mid + 1, right); //合并函数,mid为合并的位置 Merge(v, left, mid, right); } } void Count_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v)) { vector&amp;lt;int&amp;gt; count; int max(-1); for (auto a : v) { if (a &amp;gt; max) { max = a; } } count.</description>
    </item>
    
    <item>
      <title>数据结构 选择排序和堆排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 02 Feb 2024 19:58:39 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>选择：每次选出一个合法（最大/最小）的数据放到其最终应该在的位置 1.（简单）选择排序：每趟从待排序区中，选择一个最小的数，放到待排序区的第一个位置，从而实现升序排列。 时间复杂度：O(n^2) 是否稳定：不稳定 为就地排序 2.对选择排序进行优化----&amp;gt;堆排序 对于一棵完全二叉树，进行编号，编号规则为：根节点为1，然后从上到下，从左到右。除根节点外，节点i的父亲节点编号为i/2(向下取整)。除叶子节点外，节点i的左孩子节点编号为2*i，右节点为2*i+1（可直接用数组存储） 堆(Heap):是一类基于完全二叉树的特殊数据结构 1.大顶堆：在大顶堆中，根节点的值必须大于等于其孩子节点的值，且所有子树均满足 2.小顶堆：在小顶堆中，根节点的值必须小于等于其孩子节点的值，且所有子树均满足 1.建堆：用一个数组保存 （1）自我初始化：在原数组基础上进行初始化 从子树入手，由小及大去调整每棵子树（不包含叶子节点）： 对于每棵子树，我们向下调整： 让根节点和其左右孩子作比较，最小值和根节点交换，继续向下调整子树 （2）通过插入建堆 数组中每多一个数据就调整一次，新插入的数据放在最后，如果其比父亲大或者新插入的数据是根节点就不用调整，否则就向上调整 堆排序： （1）建堆 （2）循环n次，每次输出最小数----&amp;gt;a[0] （3）删掉a[0]----&amp;gt;让堆中最后一个节点替换a[0],然后重新对a[0]向下调整 时间复杂度：O(nlogn) 是否稳定：不稳定 为就地排序 堆的应用： 1.优先队列：基于堆 2.1亿个数，选出前一百个最大的数，不能使用大顶堆，使用小顶堆 a[100]---&amp;gt;堆 先读入100个数，建立小顶堆 接下来，当读入一个数x时，如果x&amp;lt;=a[0],直接读入下一个数 否则a[0]=x,向下调整小顶堆 最后留下来的小顶堆就是答案 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; //i为根节点下标 void Down_Adjust(vector&amp;lt;int&amp;gt;(&amp;amp;v), int i,int size) { int parent(i);//根节点下标 int l_child(2 * i);//左孩子下标 int tmp(0); //因为调整后可能子树不再是小顶堆，所以循环向下调整 while (parent * 2 &amp;lt;= size) { l_child = 2 * parent; if (l_child + 1 &amp;lt;= size &amp;amp;&amp;amp; v[l_child + 1] &amp;lt; v[l_child]) { l_child = l_child + 1; } //此时，l_child是值较小的孩子 if (v[parent] &amp;lt; v[l_child]) { break; } else { tmp = v[l_child]; v[l_child] = v[parent]; v[parent] = tmp; parent = l_child; } } } void Up_Adjust(vector&amp;lt;int&amp;gt;(&amp;amp;v),int i) { int tmp(0); int child(i); int parent(0); //不是根节点就继续调整 while (child &amp;gt; 1) { parent = child / 2; if (v[parent] &amp;lt; v[child]) { break; } else { tmp = v[parent]; v[parent] = v[child]; v[child] = tmp; child = parent; } } } void Heap_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v)) { //1.</description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Fri, 02 Feb 2024 12:15:50 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>数据库类型： 1.关系型数据库:MySQL，Oracle，SQL Server,SQLite，DB2 2.非关系型数据库:Redis，MongoDB 数据库管理系统:Database Management System(DBMS): 主要用于科学组织和存储数据，高效获取和维护数据(如Navicat) 结构化查询语言： 1.结构化查询语句，Structured Query Language，简称SQL,分为如下四大类： （1）数据定义语言(DDL):数据库，数据表的创建，修改和删除 CREATE,ALTER,DROP （2）数据操作语言(DML):数据的增加，修改和删除 INSERT,UPDATE,DELETE （3）数据查询语言(DQL):数据的查询 SELECT （4）数据控制语言(DCL):用户授权，事物的提交和回滚 GRANT,COMMIT,ROLLBACK -- 创建数据库 CREATE DATABASE IF NOT EXISTS lesson DEFAULT CHARACTER SET GBK COLLATE GBK_CHINESE_CI; -- 修改数据库 ALTER DATABASE lesson CHARACTER SET UTF8 COLLATE UTF8_GENERAL_CI; -- 删除数据库 DROP DATABASE IF EXISTS lesson; -- 查看数据库 SHOW DATABASES; -- 使用数据库 USE lesson; -- 列类型 decimal(m,d) //字符串类型浮点数 m为数据总位数,d为小数点后位数,m-d为整数最大位数(可以小于) (1)数值类型 tinyint smallint mediumint int bigint float double decimal (2)日期时间类型 DATE YYYY-MM-dd ，日期格式 1000-01-01 ~ 9999-12-31 TIME HH:mm:ss ，时间格式 -838:59:59.</description>
    </item>
    
    <item>
      <title>数据结构 冒泡排序和快速排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 31 Jan 2024 11:42:51 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>交换：根据数据之间的比较，把每个数据都放在自己应该的位置 （1）冒泡排序：通过不断的比较两个相邻的元素，若这两个元素是乱序的，则交换位置。从而实现每趟都把最大的数据交换到最后面 时间复杂度：O(n^2) 是否稳定：稳定 为就地排序 （2）快速排序：首先选定一个基准数（比较的标准），把比基准数x小的数据放在x前面，比基准数x大的数据放在后面。排好一趟后，x把序列划分为了两部分，这两部分还都是乱序的，再分别对这两部分进行快速排序。//递归 选择基准数（排序区间[l.r]）:理论上谁都可以 (1)选择排序区间第一个 a[l]----为例 1.两个下标i=l,j=r;相对遍历 2.先用j找一个比x小的数，放在i位置，i++ 3.再用i找一个比x大的数，放在j位置，j-- 4.不断循环，直到i==j为止，此时i/j位置就是x的位置 5.然后再对x前后两个区域进行递归调用 (2)选择排序区间最后一个 a[r] (3)选择排序区间中间位置 a[(l+r)/2] 时间复杂度：O(nlogn) 是否稳定：不稳定 为就地排序 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; //left和right分别为排序区间范围 void Quick_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v), int left, int right) { int i(left); int j(right); //递归出口,即排序区间只有一个元素时不进行排序 if (left &amp;lt; right) { int x(v[i]); //排序 while (i &amp;lt; j) { while (i &amp;lt; j &amp;amp;&amp;amp; v[j] &amp;gt; x) { j--; } if (i &amp;lt; j) { v[i] = v[j]; i++; } while (i &amp;lt; j &amp;amp;&amp;amp; v[i] &amp;lt; x) { i++; } if (i &amp;lt; j) { v[j] = v[i]; j--; } } v[i] = x; //递归调用，以v[i] = x为基准 Quick_Sort(v, left, i - 1); Quick_Sort(v, i + 1, right); } //选取区间第一个作为基准数 } void Quick_Sort_2(vector&amp;lt;int&amp;gt;(&amp;amp;v),int left,int right) { int i(left); int j(right); //递归出口,即排序区间只有一个元素时不进行排序 if (left &amp;lt; right) { int x(v[j]); //排序 while (i &amp;lt; j) { while (i &amp;lt; j &amp;amp;&amp;amp; v[i] &amp;lt; x) { i++; } if (i &amp;lt; j) { v[j] = v[i]; j--; } while (i &amp;lt; j &amp;amp;&amp;amp; v[j] &amp;gt; x) { j--; } if (i &amp;lt; j) { v[i] = v[j]; i++; } } v[i] = x; //递归调用，以v[i] = x为基准 Quick_Sort(v,left,i-1); Quick_Sort(v,i+1,right); } //选取区间最后一个作为基准数 } void Bubble_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v)) { int tmp(0); //枚举趟数 for (int i = 0; i &amp;lt; v.</description>
    </item>
    
    <item>
      <title>数据结构 插入排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 29 Jan 2024 22:00:10 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>排序：基本概念 1.基于插入： （1）直接插入排序 （2）希尔（shell）排序算法 2.基于交换： （1）冒泡排序 （2）快速排序 3.基于选择： （1）简单选择排序 （2）堆排序 4.其他： （1）归并排序 （2）基于计数的排序 如何判断排序好坏： 1.就地排序/非就地排序（反映空间复杂度） （1）如果在排序过程中，只使用到了存储数据的空间，没有使用其他额外空间，称为是就地排序 2.内部排序/外部排序 （1）待排序数据能够一次性放到内存中----&amp;gt;内部排序 （2）待排序数据不能够一次性放到内存中----&amp;gt;外部排序 注：目前只有归并排序是外部排序 3.稳定排序/不稳定排序 （1）排序前后相同数据的相对位置没有发生变化----&amp;gt;稳定的 （2）排序前后相同数据的相对位置发生变化----&amp;gt;不稳定的 4.时间复杂度 （1）直接插入排序：在添加新的数据时，我们使用顺序查找（遍历）的方式，找到其要插入的位置，将其插入 //（将数据分为有序区与待排序区，基本所有排序算法都会将数据分为这两个区域） 时间复杂度：O(n^2) 注：第一版代码不稳定，略加优化后稳定，时间复杂度不变 是否稳定：稳定 为就地排序 -折半插入排序 //优化：将直接插入排序中顺序查找换成二分查找，时间复杂度不变，为稳定排序 -2路插入排序 //优化：在折半插入排序基础上，引入一个循环数组，将排序过程中移动次数减少，时间复杂度不变，为非就地排序 注：在使用直接插入排序时，如果表中记录只有个别是无序的，多数保持有序，这种情况下算法的效率也会比较高，此外，如果需要排序数据总量较少，算法效率同样会很高。下述希尔排序便是基于这两点进行改进。 （2）希尔（shell）排序算法（缩小增量排序算法）：在直接插入排序算法的基础上，对待排序数据进行分组，先对每组进行排序，然后不断缩小组数，不断排序，最终缩小为一组。 分组：分成组数与数据下标增量相同，如0--3四个数据，分为0 2，1 3 增量的选择：对n个数据进行排序，依次分为 n/2，n/4，n/8...1组 ----&amp;gt;希尔增量序列 时间复杂度：最坏为O(n^2) 是否稳定：不稳定 为就地排序 //上述为取希尔增量序列时的情况 注：直接插入排序就是增量为一的希尔排序 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; using namespace std; //直接插入排序（不稳定） void Insert_Sort(vector&amp;lt;int&amp;gt;(&amp;amp;v)) { //保存待排序数据 int tmp(0); //保存待排序数据应该所处位置下标 int ind(0); //第一趟可以不排 for (int i = 1; i &amp;lt; v.</description>
    </item>
    
    <item>
      <title>数据结构 关键路径</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 29 Jan 2024 20:36:40 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</guid>
      <description>AOV网：在DAG中，用顶点表示活动，用弧表示活动之间的优先关系的有向图称为顶点表示活动的网----&amp;gt;工程中小项目次序 AOE网：在DAG中，用顶点表示事件，用带权有向边表示活动，边权表示活动持续时间 ----&amp;gt;工程中小项目次序，每个小项目多久做完，整个工程多久做完 事件：刹那间发生的一件事情 活动：一个完整流程，可能由很多事件组成，有开始和结束 关键路径：整个项目工程中，耗时最长的路径称为关键路径，关键路径上的活动称为关键活动。----&amp;gt;注：关键路径不唯一，我们需要关注所有关键路径 关键路径：从起点到终点，最长的路径（们），由关键活动组成。 关键活动：最早开始时间 == 最晚开始时间 ETE == LTE 非关键活动：最早开始时间 != 最晚开始时间 ETE != LTE （1）事件最早发生时间（ETV） 1.起点事件start最早发生时间 == 0 ETV[start] == 0 2.其余事件的最早发生时间基于拓扑序列去算 ETV[j] = max(ETV[j],ETV[i]+wi) i------&amp;gt;j （2）事件最晚发生时间（LTV） 1.终点事件end的最晚发生时间 LTV[end] = ETV[end] (若未给出的话则按左式计算) 2.其余事件最晚发生时间基于逆拓扑序列计算 LTV[i] = min(LTV[i],LTV[j]-wj) i------&amp;gt;j 3.起点事件start最晚发生时间 == 0 LTV[start] == 0 == ETV[start] （3）活动最早开始时间（ETE/ES） 1.ETE==该边起点事件的ETV ETE = ETV[i] （4）活动最晚开始时间（LTE/LS） 注：保证终点事件在DDL之前按时发生 1.LTE==该边终点事件LTV - 该边权值 注：终点事件最早发生时间就是工程完成时间 时间复杂度：O(n+m) 注：n为点数，m为边数 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; //引入一个栈，用于保存所有入度为零的的点的下标 class Stack_Node { public: int data; Stack_Node* next; }; class m_stack { public: Stack_Node* head; public: m_stack() { head = new Stack_Node; if (head == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { head-&amp;gt;next = nullptr; } } void m_push(int k) { Stack_Node* p = new Stack_Node; p-&amp;gt;data = k; p-&amp;gt;next = head-&amp;gt;next; head-&amp;gt;next = p; } int m_pop() { if (head-&amp;gt;next == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;栈空&amp;quot; &amp;lt;&amp;lt; endl; return -1; } Stack_Node* p = head-&amp;gt;next; int ret = p-&amp;gt;data; head-&amp;gt;next = p-&amp;gt;next; delete p; p = nullptr; return ret; } }; class List_Node { public: int data; int wi;//权值 List_Node* next; }; class Graph_Node { public: char vi; List_Node* first; }; class Graph { public: int size1;//点的个数 int size2;//边的个数 Graph_Node* g;//邻接表 int* ind;//入度数组 int* topo;//拓扑序列,改为记录下标便于计算 int* etv;//事件最早发生时间 int* ltv;//事件最晚发生时间 public: Graph(int sz1,int sz2):size1(sz1),size2(sz2) { g = new Graph_Node[sz1]; ind = new int[sz1]; topo = new int[sz1]; etv = new int[sz1]; ltv = new int[sz1]; if (g == nullptr || ind == nullptr || topo == nullptr|| etv == nullptr || ltv == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { //初始化点 for (int i = 0; i &amp;lt; sz1; ++i) { cin &amp;gt;&amp;gt; g[i].</description>
    </item>
    
    <item>
      <title>数据结构 拓扑排序</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 27 Jan 2024 20:09:41 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>注：有向无环图（DAG图） AOV网：用顶点表示活动，用弧表示活动之间的优先关系的有向图称为顶点表示活动的网 注：AOV网一定是有向无环图 拓扑序列：对于一个有n个顶点的有向图，顶点序列v1,v2...vn若满足从顶点vi到vj有一条路径，则顶点序列中vi必在vj之前，这样的一个顶点序列为一个拓扑序列 拓扑排序：对一个有向无环图构造拓扑排序的过程（同时还可以判断图内部是否成环） 1.在有向图中选一个没有前驱的顶点并输出 2.从图中删除该顶点和所有以他为尾的弧 重复上述两步，直至全部顶点均已输出，或者当前图不存在无前驱的顶点为止，后一种情况说明有向图中存在环 应用：拓扑序列，关键路径 #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; //引入一个栈，用于保存所有入度为零的的点的下标 class Stack_Node { public: int data; Stack_Node* next; }; class m_Stack { public: Stack_Node* head; public: m_Stack() { head = new Stack_Node; if (head == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { head-&amp;gt;next = nullptr; } } void m_push(int k) { Stack_Node* s = new Stack_Node; s-&amp;gt;data = k; s-&amp;gt;next = head-&amp;gt;next; head-&amp;gt;next = s; } int m_pop() { if (head-&amp;gt;next == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;栈空&amp;quot; &amp;lt;&amp;lt; endl; return -1; } else { int ret(0); Stack_Node* p = head-&amp;gt;next; head-&amp;gt;next = p-&amp;gt;next; ret = p-&amp;gt;data; delete p; p = nullptr; return ret; } } }; //邻接表存有向图 class List_Node { public: int data;//邻接点下标 List_Node* next; }; class Graph_Node { public: char data;//顶点编号 List_Node* first;//出边链表头指针 }; class Graph { public: int size1;//点的个数 int size2;//边的个数 Graph_Node* g;//邻接表 int* ind;//入度数组 char* topo;//拓扑序列 public: Graph(int sz1,int sz2):size1(sz1),size2(sz2) { g = new Graph_Node[sz1]; ind = new int[sz1]; topo = new char[sz1]; if (g == nullptr || ind == nullptr || topo == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { //初始化点 for (int i = 0; i &amp;lt; sz1; ++i) { cin &amp;gt;&amp;gt; g[i].</description>
    </item>
    
    <item>
      <title>数据结构 最短路径</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 27 Jan 2024 10:19:17 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>注：对于无向无权图而言，最短路径就是经过边的条数，可以通过BFS求 对于无向带权图，有如下常用算法 单源最短路径算法 1.dijkstra算法----&amp;gt;贪心 单源最短路 O(n^2) 不能解决带负边权问题 多源最短路径算法 2.Floyd算法----&amp;gt;动态规划 多源最短路 o(n^3) 不能解决负边权回路 最短路径算法核心思想：用中转点找更短的路径 注：源点（即起点） dijkstra算法 循环n-1次，每次找到一 最小并且未确定最短路径的点y，点y的最短路径就确定下来，然后用y去更新y的邻接点到源点的最短路径长度 时间复杂度：O(n^2) 注：n为点的个数 dijkstra算法: #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; class Graph { public: int size1;//点的个数 int size2;//边的个数 int** graph; bool* visit;//标记点到源点的最短路径是否确定下来 int* pre;//记录点的上一个中转点下标，源点中转点为其自身 int* dist;//记录点到源点最小距离 public: Graph(int sz1, int sz2) :size1(sz1), size2(sz2) { graph = new int* [sz1]; visit = new bool[sz1]; pre = new int[sz1]; dist = new int[sz1]; if (graph == nullptr || visit == nullptr || pre == nullptr || dist == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { for (int i = 0; i &amp;lt; sz1; ++i) { graph[i] = new int[sz1]; if (graph[i] == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } } //初始化 for (int i = 0; i &amp;lt; sz1; ++i) { for (int j = 0; j &amp;lt; sz1; ++j) { if (i == j) { graph[i][j] = 0; } else { graph[i][j] = 999999; } } visit[i] = false; pre[i] = -1; dist[i] = 999999; } //输入边 int x(0); int y(0); int wi(0); for (int i = 0; i &amp;lt; sz2; ++i) { cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; wi; graph[x][y] = graph[y][x] = wi; } } } void dijkstra() { //输入起点 int x(0); cin &amp;gt;&amp;gt; x; visit[x] = true; pre[x] = x; dist[x] = 0; //更新邻接点 for (int i = 0; i &amp;lt; size1; ++i) { dist[i] = graph[x][i]; } //循环n-1次 int min_n(999999); int k(0);//dist[k]最小 for (int i = 0; i &amp;lt; size1 - 1; ++i) { min_n = 999999; for (int j = 0; j &amp;lt; size1; ++j) { if (visit[j] == false &amp;amp;&amp;amp; dist[j] &amp;lt; min_n) { k = j; min_n = dist[j]; } } //以k为中转点更新其邻接点dist //注：因为第一个k对应pre无法更新，所以单独判断 if (i == 0) { visit[k] = true; pre[k] = x; } else { visit[k] = true; } for (int j = 0; j &amp;lt; size1; ++j) { if (visit[j] == false &amp;amp;&amp;amp; dist[j] &amp;gt; (dist[k] + graph[k][j])) { dist[j] = dist[k] + graph[k][j]; pre[j] = k; } } } } }; int main() { Graph g(9, 16); g.</description>
    </item>
    
    <item>
      <title>数据结构 最小生成树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Wed, 24 Jan 2024 16:32:01 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>生成树：一个连通图的生成树时一个极小连通子图，包含n个顶点，但只有构成一棵树的n-1条边 注：包含n个顶点的无向完全图最多包含n^(n-2)棵生成树 注：只有无向图才有生成树（且必须为连通图），有向图对应概念为树型生成图 生成树的属性： 1.一个连通图可以有多个生成树 2.一个连通图的所有生成树都包含相同的顶点个数和边数 3.生成树当中不存在环 4.移除生成树中的任意一条边都会导致图的不连通 5.在生成树中添加一条边会构成环 6.对于包含n个顶点的连通图，生成树包含n个顶点和n-1条边 7.对于包含n个顶点的无向完全图最多包含包含n^(n-2)棵生成树 最小生成树：一个带权图的生成树，该生成树边权之和最小，则称该生成树为最小生成树 注：只有无向连通带权图才有最小生成树，且最小生成树不一定唯一 1.Kruskal算法----&amp;gt;从边出发 //基于贪心和并查集 1.选择权值尽可能小的n-1条边----&amp;gt;排序：选择排序算法 2.选边时，选的每一条边都得是连接未连通的两个节点才行，否则成环---&amp;gt;通过并查集判断一条边的两个点是否属于同一个集合，若不属于，则该边可选，并合并两个不同集合 时间复杂度：主要分为两块 选择排序O(m^2)+并查集O(m)----&amp;gt;O(m^2) 注：即Kruskal算法时间复杂度取决于排序算法时间复杂度，比如使用快速排序将会变为mlogm （m为边的数目） 2.Prim算法-----&amp;gt;从点出发 //基于贪心 点到生成树的距离dist： 1.已经在生成树中的点：0 2.不在生成树中的点：该点与生成树中任意若干点直接相连，其每条连接边对应的权值就是dist 注：不考虑间接相连，间接相连dist视为无穷大 点分为两类： 1.已经选中的点，已经构成一部分生成树 2.还未选中的点 选择n次： 第一次：任意选择一个点 接下来n-1一次：选则第二类中点，该点dist最小，同时通过选中的点更新与其相连的点到生成树的dist 思路： 维护一个点到生成树的最小距离dist[],初始化为无穷大 维护一个标记数组visit[] 1.任选一个点作为起点，把起点x加入到生成树中：visit[x]=1,dist[x]=0 2.更新x邻接点到生成树最小距离 3.执行n-1次循环（1）找到visit[]==0且dist[]最小的点下（2）把起点x加入到生成树中：visit[x]=1,dist[x]=0 (3)更新x邻接点到生成树最小距离 时间复杂度：O(n^2) 注：n为点的个数 注：点多边多（稠密图）Prim算法，点多边少（稀疏图）Kruskal算法 Kruskal算法: #define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; //并查集 class Tree_Node { public: int fi; int data;//注：本图所有点编号与其下标对应 }; class Tree { public: Tree_Node* pN; int size; public: Tree(int sz) :size(sz) { pN = new Tree_Node[size]; for (int i = 0; i &amp;lt; size; ++i) { pN[i].</description>
    </item>
    
    <item>
      <title>数据结构 图</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</link>
      <pubDate>Wed, 27 Dec 2023 19:57:55 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</guid>
      <description>图的概念： 逻辑结构：多对多 graph 图 g vertex 顶点 v edge 边\弧 e 图G是由两个集合V和E构成，G = (V,E),其中V是顶点的有限非空集合，E是V中顶点偶对的有限集，这些顶点偶对称为边（弧） 重边：两个顶点不只有一条边 自边：顶点自身形成一条边 图的分类： 不同的维度： 1.方向性：有向图和无向图 2.环：带环图和无环图 //环：从一个点x出发，沿着边走，最终可以回到x 注：有向无环图（DAG） 3.边权：无权图 带权图 图的基本术语： 1.简单图：若不存在顶点到自身的边，且同一条边不重复出现，则称这样的图为简单图 2.无向图：在图中，如果代表边的顶点偶对是无序的，则为无向图 3.有向图：在图中，如果代表边的顶点偶对是有序的，则为有向图 //有向边（弧） //起点：弧尾 //终点：弧头 //注：无向图可以看成有向图 4.完全图：图中每两个顶点都有一条边 //完全有向图：n（n-1）条边 //完全无向图：n（n-1）/2条边 5.端点，邻接点； 端点：边的两个顶点 邻接点：上述两个顶点互为邻接点 6.顶点的度，入度和出度 //对于无向图而言 度：该点所连的边数 //对于有向图而言 入度；入边的个数 出度：出边的个数 度：出度+入度（一定为偶数） 7.子集：与子树类似 8.路径，路径长度： 路径：顶点序列 路径长度：边的数目 简单路径：一条路径上除开始点和结束点可以相同外，其余顶点均不相同（路径中不含环） 9.回路，环 欧拉环路：经过图中各边一次且恰好一次的环路 哈密尔顿环路：经过图中各顶点一次且恰好一次的环路 10.连通，连通图和连通分量（针对无向图） 1.连通：如果顶点x和y之间存在可以相互抵达的路径，则称两个顶点连通 2.连通图：图中任意两个顶点都连通 3.连通分量：无向图中的极大连通子图称为图的连通分量 注：连通图只有一个极大连通子图（自身） 非连通图有多个极大连通子图 注:极大连通子图（连通分量） 极小连通子图（图的生成树）：在保证各点连通的情况下，边最少 11.强连通图和强连通分量（针对有向图，含义同上） 12.稠密图和稀疏图 一个图接近完全图时，称为稠密图，当一个图含有较少边数时，称为稀疏图，一般以nlogn作为分界线（n为节点个数） 13.权和网 边上带有权的图称为带权图，也称之为网 //注：自边权值看作零，两个点之间没有连接权值看作无穷大 14.连通图的生成树（针对无向图） 连通图的生成树是一个极小的连通子图 图的存储： 1.</description>
    </item>
    
    <item>
      <title>数据结构 时间复杂度</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Wed, 27 Dec 2023 19:57:28 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构 树,二叉树和森林的转换</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Wed, 20 Dec 2023 19:41:57 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid>
      <description>扩展补充一下树,二叉树和森林的转换
1.普通树转换为二叉树 1.加线，在所有兄弟节点之间加一条连线 2.断线，只保留每个节点第一个孩子（从左到右）
2.二叉树转换为普通树 上述过程的逆过程
3.森林转换为二叉树 1.先把森林中每棵树转换为二叉树 2.加线，第一棵二叉树不动，从第二棵树开始，依次把后一棵二叉树根节点作为前一棵二叉树的根节点的右孩子
4.二叉树转换为森林 上述过程逆过程
注：如何判断一棵二叉树是由森林还是普通的树转换而来呢？ 根据二叉树根节点是否有右孩子来判断： 1.由普通树转换而来没有右孩子 2.由森林转换而来的有右孩子</description>
    </item>
    
    <item>
      <title>数据结构 哈夫曼树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</link>
      <pubDate>Wed, 20 Dec 2023 16:49:51 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</guid>
      <description>1.节点i的路径长度：从根节点到节点i的路径上所经过边数
2.树的路径长度：所有节点的路径长度之和
内部路径长度：所有内部节点路径长度之和
外部路径长度（有时会把树的路径长度当作外部路径长度）：所有叶子节点路径长度之和
3.节点i的带权路径长度：节点i的路径长度*节点i权值
4.树的带权路径长度（WPL）：所有叶子节点的带权路径长度之和
给出n个节点（都带有权值），可以再自行加入若干节点（不确定），用这n个节点全部做叶子节点，自行加入的节点做内部节点去建立一棵二叉树，其中WPL最小的一棵二叉树称为哈夫曼树（最优二叉树）
注：哈夫曼树WPL的值唯一
但WPL的值最小的哈夫曼树不唯一
如何构建哈夫曼树？
给定n个节点（带权值且只做叶子节点）
1.一开始认为n个节点为n棵树
2.每次找根节点权值最小的两棵树（x，y），再新加入一个节点z做x和y的父亲，新的根节点权值为（x，y），此时将x，y两棵树合并出一棵新树，这棵树的根节点为z
哈夫曼树应用：通过编码进行数据压缩
哈夫曼编码&amp;mdash;&amp;gt;变长编码，压缩空间
定长编码：ASCII编码（8bit），Unicode编码（16bit）
缺陷：浪费空间
变长编码：比定长编码省空间
可以使用哈夫曼树来构造变长编码&amp;mdash;&amp;gt;哈夫曼编码
1.先统计一条消息中n个字符分别出现频率&amp;mdash;&amp;gt;节点权值
2.构造哈夫曼树
3.标上1和0
注：哈夫曼树WPL值即为信息编码所占bit位数
注：变长编码中遵循前缀属性原则（短的编码不能是长编码的前缀，避免二义性）
哈夫曼编码树实现：
1.建立哈夫曼树：把每个字符的频率看作节点的权值，建立哈夫曼树，通过结构体数组模拟存储
节点：权值，父亲的下标，左右孩子节点的下标
（1）查找最小的两个根节点 （2）合并，加入一个新的根节点 注：n个叶子节点，总共有2*n-1个节点
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; class Node { public: int w;//权值 int fi;//父亲节点坐标 int left;//左右孩子节点下标 int right; }; class HFM_Tree { public: int size;//节点个数 Node* tree;//指针模拟开数组 public: HFM_Tree(int w_arr[], int sz) :size(2 * sz - 1) { tree = new Node[size]; if (tree == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { //初始化哈夫曼树（从下标为零开始存储） for (int i = 0; i &amp;lt; size; ++i) { tree[i].</description>
    </item>
    
    <item>
      <title>数据结构 并查集</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Wed, 20 Dec 2023 16:28:15 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>今天学习并查集，一种常用的树的算法，之后还会学习哈夫曼树
并查集：利用树型结构来处理一些不相交的集合的合并和查询问题
合并两个集合（两棵树）：只需要合并两棵树的根节点，先找到各自的根节点，把根节点设立父子关系即可
查询两个节点是否在同一个集合（树）：只需要找到两个节点的根节点，看根节点是否相同
并查集用树型结构实现：双亲表示法
并查集算法优化：路径压缩（递归实现）
例题：洛谷p1551&amp;mdash;亲戚
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; class Tree_Node { public: int fi; int data; public: }; class Tree { public: int size; Tree_Node* pN; public: Tree(int sz):size(sz) { pN = new Tree_Node[sz]; for (int i = 0; i &amp;lt; sz; ++i) { pN[i].fi = pN[i].data = i + 1; } } int Find_fi(int k)//找祖先 { while (pN[k - 1].fi != k) { k = pN[k - 1].</description>
    </item>
    
    <item>
      <title>数据结构 平衡二叉树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 11 Dec 2023 22:25:55 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>开始学习AVL树了，目前简单了解了其相关概念
平衡因子：
基本旋转方式：
1.左单旋 记失衡节点为x x右孩子为y x-&amp;gt;right = y-&amp;gt;left y-&amp;gt;left = x 2.右单旋 记失衡节点为x x左孩子为y x-&amp;gt;left = y-&amp;gt;right y-&amp;gt;right = x 最小失衡子树：在新插入的节点向上查找，以第一个平衡因子的绝对值超过一的节点为根节点的子树 插入：
1.进行BST插入 2.算插入节点的所有祖先节点的平衡因子 节点x高度x-&amp;gt;h = max(x-&amp;gt;left-&amp;gt;h,x-&amp;gt;right-&amp;gt;h) + 1 节点平衡因子:x-&amp;gt;left-&amp;gt;h - x-&amp;gt;right-&amp;gt;h(左右子树高度差的绝对值) 3.插入导致失衡情况，进行旋转（优先调整最小失衡子树） 判断失衡：
1.先找出x-&amp;gt;left和x-&amp;gt;right中高度较高的 2.再去高度子树里面去看根节点的哪边的子树高 4.调用对应调整函数
假设最小失衡子树根节点为A 1.LL 在A节点左孩子的左子树插入节点破坏平衡 调整策略：对A进行一次右旋 2.LR 在A节点左孩子的右子树插入节点破坏平衡 调整策略：（1）以A-&amp;gt;left为中心进行左旋，转换成为了LL (2)按照LL情况进行操作 3.RR 在A节点右孩子的右子树插入节点破坏平衡 调整策略：对A进行一次左旋 4.RL 在A节点右孩子的左子树插入节点破坏平衡 调整策略：（1）以A-&amp;gt;right为中心进行右旋，转换为RR (2)按照RR情况进行操作 删除操作
1.执行二叉排序树删除 2.判断是否失衡 在x节点的一边子树中删除了一个节点，就等价于在其另一边子树插入了一个节点导致的失衡---&amp;gt;删除的失衡类型及调整方式和插入的一模一样 左删除 相当于 右边插入：RR RL 右删除 相当于 左边插入：LL LR 终于完成了AVL树了，接下来就学习一下哈夫曼树（似乎是另一条路线的样子）和时间复杂度了
日常：麻了，四级好像要寄了，算了一下，似乎430~440的样子（作文翻译全按及格算的），希望能过 下周二考工程师职业素养期末，坐大牢，本来说周末复习的，装一个远行星号装了一上午，下午还有文明经典，属实难绷
代码实现如下
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class AVL_Node { public: T data; AVL_Node&amp;lt;T&amp;gt;* left = nullptr; AVL_Node&amp;lt;T&amp;gt;* right = nullptr; int h = 1;//记录节点高度 }; template&amp;lt;class T&amp;gt; class AVL_Tree { public: AVL_Tree() { root = new AVL_Node&amp;lt;T&amp;gt;; if (root == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { root-&amp;gt;left = nullptr; root-&amp;gt;right = nullptr; } } AVL_Tree(T k) { root = new AVL_Node&amp;lt;T&amp;gt;; if (root == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { root-&amp;gt;left = nullptr; root-&amp;gt;right = nullptr; root-&amp;gt;data = k; } } AVL_Node&amp;lt;T&amp;gt;* AVL_Insert(AVL_Node&amp;lt;T&amp;gt;* ro, T k) { if (ro == nullptr) { AVL_Node&amp;lt;T&amp;gt;* s = new AVL_Node&amp;lt;T&amp;gt;; s-&amp;gt;data = k; return s; } else if (k &amp;lt; ro-&amp;gt;data) { ro-&amp;gt;left = AVL_Insert(ro-&amp;gt;left, k); //高度可能变化,判断是否失衡 if (Get_h(ro-&amp;gt;left) - Get_h(ro-&amp;gt;right) &amp;gt; 1) { AVL_Node&amp;lt;T&amp;gt;* l = ro-&amp;gt;left;//用于判断失衡类型 //也可以通过子树高度判断 //if (Get_h(l-&amp;gt;left) &amp;gt; Get_h(l-&amp;gt;right)) if (k &amp;lt; l-&amp;gt;data) { //LL ro = LL_rotation(ro); } else { //LR ro = LR_rotation(ro); } } //返回变化后子树根节点并且改变高度(因为都要进行，所以可以一起挪到函数末尾)	} else { ro-&amp;gt;right = AVL_Insert(ro-&amp;gt;right, k); //高度可能变化,判断是否失衡 if (Get_h(ro-&amp;gt;right) - Get_h(ro-&amp;gt;left) &amp;gt; 1) { AVL_Node&amp;lt;T&amp;gt;* r = ro-&amp;gt;right;//用于判断失衡类型 //也可以通过子树高度判断 //if(Get_h(r-&amp;gt;right) &amp;gt; Get_h(r-&amp;gt;left)) if (k &amp;gt; r-&amp;gt;data) { //RR ro = RR_rotation(ro); } else { //RL ro = RL_rotation(ro); } } //返回变化后子树根节点并且改变高度(因为都要进行，所以可以一起挪到函数末尾) } ro-&amp;gt;h = max(Get_h(ro-&amp;gt;left), Get_h(ro-&amp;gt;right)) + 1; return ro; } int Get_h(AVL_Node&amp;lt;T&amp;gt;* x) { if (x == nullptr) { return 0; } else { return x-&amp;gt;h; } } AVL_Node&amp;lt;T&amp;gt;* LL_rotation(AVL_Node&amp;lt;T&amp;gt;* ro) { AVL_Node&amp;lt;T&amp;gt;* y = ro-&amp;gt;left; ro-&amp;gt;left = y-&amp;gt;right; y-&amp;gt;right = ro; //高度可能改变 ro-&amp;gt;h = max(Get_h(ro-&amp;gt;left), Get_h(ro-&amp;gt;right)) + 1; y-&amp;gt;h = max(Get_h(y-&amp;gt;left), Get_h(y-&amp;gt;right)) + 1; return y; } AVL_Node&amp;lt;T&amp;gt;* LR_rotation(AVL_Node&amp;lt;T&amp;gt;* ro) { ro-&amp;gt;left = RR_rotation(ro-&amp;gt;left); ro = LL_rotation(ro); return ro; } AVL_Node&amp;lt;T&amp;gt;* RR_rotation(AVL_Node&amp;lt;T&amp;gt;* ro) { AVL_Node&amp;lt;T&amp;gt;* y = ro-&amp;gt;right; ro-&amp;gt;right = y-&amp;gt;left; y-&amp;gt;left = ro; //高度可能改变 ro-&amp;gt;h = max(Get_h(ro-&amp;gt;left), Get_h(ro-&amp;gt;right)) + 1; y-&amp;gt;h = max(Get_h(y-&amp;gt;left), Get_h(y-&amp;gt;right)) + 1; return y; } AVL_Node&amp;lt;T&amp;gt;* RL_rotation(AVL_Node&amp;lt;T&amp;gt;* ro) { ro-&amp;gt;right =LL_rotation(ro-&amp;gt;right); ro = RR_rotation(ro); return ro; } void mid_order(AVL_Node&amp;lt;T&amp;gt;* ro) { if (ro == nullptr) { return; } if (ro-&amp;gt;left !</description>
    </item>
    
    <item>
      <title>数据结构 排序二叉树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 11 Dec 2023 11:36:02 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>又一次被树折磨，这一次是排序二叉树，似乎能够理解为什么set容器能够实现插入后自动排序了，也去查了一下资料，set底层确实是以二叉树实现的。
一点点注意事项： 如果序列本身为升序或者降序，会形成斜树（即链表，起不到优化作用） BST + 限制 = AVL树
接下来就是AVL树（二叉平衡树）了，准备坐大牢，已经在思考红黑树会有多坐牢了，不过学完树之后似乎只剩图和串了，之后就要开始算法坐大牢了&amp;hellip;&amp;hellip;
日常： 快放假了，但是一堆期末考试在等着我，估计了一下约莫有八九门的样子，希望别挂科（应该不会，感觉学的还是挺好的，就是历史闭卷有点难绷），距离四级还有六天，似乎注定要裸考了，乐
代码实现：
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class BST_Node { public: T data; BST_Node&amp;lt;T&amp;gt;* left; BST_Node&amp;lt;T&amp;gt;* right; public: BST_Node() { left = nullptr; right = nullptr; } }; template&amp;lt;class T&amp;gt; class BST { public: BST_Node&amp;lt;T&amp;gt;* root; public: BST(T k) { root = new BST_Node&amp;lt;T&amp;gt;; if (root == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;建树失败&amp;quot; &amp;lt;&amp;lt; endl; } else { root-&amp;gt;data = k; } } //非递归实现插入 BST_Node&amp;lt;T&amp;gt;* Insert_non_recursion(T k) { BST_Node&amp;lt;T&amp;gt;* s = new BST_Node&amp;lt;T&amp;gt;; if (s == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;插入失败&amp;quot; &amp;lt;&amp;lt; endl; } else { s-&amp;gt;data = k; s-&amp;gt;left = nullptr; s-&amp;gt;right = nullptr; //通过p进行遍历，pre指向p父亲节点 BST_Node&amp;lt;T&amp;gt;* p = root; BST_Node&amp;lt;T&amp;gt;* pre = nullptr; while (p !</description>
    </item>
    
    <item>
      <title>数据结构 树</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</link>
      <pubDate>Wed, 22 Nov 2023 20:07:38 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</guid>
      <description>被文科折磨的百忙之中抽空学习(麻了，我还是个工科生吗)，学习完之后一堆文科小组作业等着我&amp;hellip;&amp;hellip;(主打一个裸考四级，乐)
树型结构：逻辑结构 概念：树是存储一对多关系的数据的逻辑结构，在树中，用节点存储数据
节点分类: 1.根节点(无前驱节点) 2.叶子节点(无子节点) 3.内部节点(有些教材把根节点归为内部节点)
父子关系和兄弟关系(一般理解为广义兄弟关系)
树：度/阶&amp;mdash;表示节点分了多少个叉
节点的度：该节点孩子节点的数目/分叉的数目 树的度：max(所有节点的度)，如果树的度为n，称为n叉树
树的高度和深度：在数值上一样(方向不一样，从上往下或从下往上) 结点的深度：注意方向即可
方便操作根节点，在之前增加一个空节点(与链表头节点类似) 方便操作叶子节点，在其之后增加一个空节点
存储结构:
存一棵树：1.节点数据 2.数据之间的关系&amp;ndash;父子
1.双亲(父亲)表示法：方便找父亲，不方便找孩子 1.顺序存储方式存数据：&amp;ndash;数组 2.在存数据的同时，把每个数据的父亲所在下标存一下
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class Node { public: T data;//存储数据 int fi;//father_i,fi == -1,认为是根节点 }; template&amp;lt;class T&amp;gt; class Tree { public: int size; Node&amp;lt;T&amp;gt;* pN;//指针开辟数组，存储节点 public: Tree(T k, int sz = 1) { //加入根节点 pN = new Node&amp;lt;T&amp;gt;[sz]; pN[0].data = k; pN[0].fi = -1; size = 1; } int Find(T fx) { for (int i = 0; i &amp;lt; size; i++) { if (pN[i].</description>
    </item>
    
    <item>
      <title>数据结构 队列</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 18 Nov 2023 11:14:33 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</guid>
      <description>学习完了线性结构的最后一个类型了，接下来似乎就是很难实现的分支结构了，一个红黑树似乎会有上千行代码的样子，不知道到时候要写多久。
实现了顺序队列，链式队列，循环队列，顺序双端队列，链式双端队列，同时对优先队列有了一定了解
代码实现如下：
顺序队列：
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class m_queue { public: m_queue(int n) { size = n; data = new T[size]; if (data == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } front = 0; rear = 0; //指向最后一个元素下一个位置 } void En_queue(T k) { //判满(牺牲一个位置) if (rear == size - 1) { cout &amp;lt;&amp;lt; &amp;quot;队满&amp;quot; &amp;lt;&amp;lt; endl; } else { data[rear] = k; cout &amp;lt;&amp;lt; k &amp;lt;&amp;lt; &amp;quot;入队&amp;quot; &amp;lt;&amp;lt; endl; rear++; } } void Del_queue() { int x(0);//记录出队元素 //判空 if (front == rear) { cout &amp;lt;&amp;lt; &amp;quot;队空&amp;quot; &amp;lt;&amp;lt; endl; } else { x = data[front]; cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;出队&amp;quot; &amp;lt;&amp;lt; endl; front++; } } void m_empty() { if (front == rear) { cout &amp;lt;&amp;lt; &amp;quot;队空&amp;quot; &amp;lt;&amp;lt; endl; } } void m_full() { if (rear == size) { cout &amp;lt;&amp;lt; &amp;quot;队满&amp;quot; &amp;lt;&amp;lt; endl; } } public: int size;//队列大小 T* data; int front; //队头指针 int rear; //队尾指针 }; int main() { m_queue&amp;lt;int&amp;gt; q(5); q.</description>
    </item>
    
    <item>
      <title>数据结构_栈</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</link>
      <pubDate>Tue, 14 Nov 2023 17:13:49 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</guid>
      <description>今天成功实现了栈，可能因为栈比较简单，没花太多时间，毕竟就是一种特殊的表，比上次链表好多了，这次写链栈快多了。
代码如下
顺序栈
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class m_stack { public: m_stack(int n) { size = n; data = new T[n]; if (data == nullptr) { cerr &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } top = -1;//初始化栈顶指针 } void m_push(T k) { if (this-&amp;gt;top == this-&amp;gt;size - 1) { cout &amp;lt;&amp;lt; &amp;quot;栈满&amp;quot; &amp;lt;&amp;lt; endl; } else { this-&amp;gt;top++; this-&amp;gt;data[top] = k; //若top初始值为0 /* *if(s.top == s.size) { } else { s.</description>
    </item>
    
    <item>
      <title>数据结构 双链表及循环链表</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 11 Nov 2023 18:15:45 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</guid>
      <description>学习过后成功实现了双链表与单向循环链表及双向循环链表，虽然改bug改了一天就是了。
本来以为双链表本身没什么问题，只要稍作修改就可以变为循环链表，但没考虑到nullptr在循环链表中不存在，导致改了好久，最后才意识到
代码如下
双链表
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;cassert&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class Node { public: T date; Node* next; Node* pre; }; template&amp;lt;class T&amp;gt; class LinkList { public: Node&amp;lt;T&amp;gt;* m_head; public: LinkList() { m_head = new Node&amp;lt;T&amp;gt;; if (m_head == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { m_head-&amp;gt;next = nullptr; m_head-&amp;gt;pre = nullptr; } } //查找函数 LinkList* Find(LinkList* head, T k) { Node&amp;lt;T&amp;gt;* pt = head-&amp;gt;m_head-&amp;gt;next; while (pt-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>数据结构 链表</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 08 Nov 2023 20:13:05 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</guid>
      <description>单链表：
1.节点（结点）：数据加指向下一个数据的地址（指向下一个数据的指针），组成了了一个节点 2.链表由若干节点组成 3.头指针：存储第一个节点的地址的指针，头指针可以标记一个链表
两个特殊节点： 1.首元节点：第一个存储真实数据的节点。（非空链表，一定有首元节点） 2.头节点：链表中第一个不存储真实数据的节点（头节点可有可无），如果头节点存在，那么头节点一定是链表的第一个节点
声明链表==声明节点
增强可读性，声明头指针 linklist l;
头节点作用： 1.当不带头节点时，对首元节点的操作需要涉及到头指针，非常特殊； 带头节点时，首元节点与其他节点无异 2.对空链表的操作：带头节点，空链表与非空链表均有节点，统一起来了
1.增： 不带头节点的链表：在首元节点前插入一个节点，需要改变头指针
初步代码实现如下： #define _CRT_SECURE_NO_WARNINGS
#include&amp;lt;iostream&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class Node { public: T date; Node* next; }; template&amp;lt;class T&amp;gt; class LinkList { public: Node&amp;lt;T&amp;gt;* m_head; public: LinkList() { m_head = new Node&amp;lt;T&amp;gt;; if (m_head == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } else { m_head-&amp;gt;next = nullptr; } } //查找函数 LinkList* Find(LinkList* head, T k) { Node&amp;lt;T&amp;gt;* pt = head-&amp;gt;m_head-&amp;gt;next; while (pt-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>数据结构 顺序表</title>
      <link>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</link>
      <pubDate>Tue, 07 Nov 2023 23:01:00 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</guid>
      <description>今天尝试实现顺序表，基本的增，删，查，插，改功能基本实现，但扩容时存在部分问题，只能部分扩容，原因尚未找出，等待后续优化（鬼晓得什么时候，也许明天）
2023.11.11 今天提交链表顺便修复一下之前的bug，扩容时忘了size++
代码如下（博客显示有点问题，不知道为什么，之后去修复一下）
#define _CRT_SECURE_NO_WARNINGS #include&amp;lt;iostream&amp;gt; #include&amp;lt;stdexcept&amp;gt; using namespace std; template&amp;lt;class T&amp;gt; class ArrayList { public: ArrayList(int Num) :size(0) //初始化构造函数 { date = new T[Num]; if (date == nullptr) { cout &amp;lt;&amp;lt; &amp;quot;开辟失败&amp;quot; &amp;lt;&amp;lt; endl; } length = Num; } void AddEle(T ele)//增添元素 { //判断是否超过最大容量 try { if (size &amp;lt;length) { date[size] = ele; size++; } else { throw runtime_error(&amp;quot;空间已满，是否扩容 Y/N&amp;quot;); } } catch (runtime_error err) { cout &amp;lt;&amp;lt; err.</description>
    </item>
    
    <item>
      <title>《C&#43;&#43;Primer》读后感2</title>
      <link>https://qingbingwei.github.io/post/c&#43;&#43;primer%E8%AF%BB%E5%90%8E%E6%84%9F2/</link>
      <pubDate>Thu, 02 Nov 2023 22:14:27 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/c&#43;&#43;primer%E8%AF%BB%E5%90%8E%E6%84%9F2/</guid>
      <description>这两天在阅读过程中又遇到了一些问题，同时也学习到了一些新的语法，具体如下:
1.顶层const与底层const拷贝规则
其中顶层const不会受到什么影响，但是底层const的限制不能忽视，这是为了防止拷贝对象能够修改底层const指针指向对象 即 const int a = 0; const int *const p1 = &amp;amp;a; int *p2 = p1; //错误 2.constexpr变量
如果变量为常量表达式，最好声明为constexpr类型 3.constexpr和指针
限定符constexpr仅对指针有效，对其所指对象无效 4.类型别名
1.typedef 2.using 注：typedef char *pstring; const char *cstr = 0; 与 const pstring cstr = 0;含义不同 5.auto
1.auto auto定义变量必须有初始值 2.auto和引用 编译器以引用对象的类型作为auto的类型 设置类型为auto的引用时，初始值中的顶层常量属性仍然保留 3.auto和const auto一般会忽略顶层const（希望推断出则需明确指出p62），保留底层const 6.decltype
1.decltype 编译器分析表达式得到类型，但不计算 2.decltype与引用 如果表达式内容为解引用操作，将得到引用类型 **** decltype（（variable））结果永远是引用 p63 7.左值和右值
使用左值地址，使用右值数据 8.预处理与头文件
9.using与命名空间
头文件不应包含using声明 **** 10.cin与文件末尾 p78
11.string与字符串字面值
可以使用 + 进行追加 注：string类 .</description>
    </item>
    
    <item>
      <title>《C&#43;&#43;primer》读后感</title>
      <link>https://qingbingwei.github.io/post/c&#43;&#43;primer%E8%AF%BB%E5%90%8E%E6%84%9F/</link>
      <pubDate>Mon, 30 Oct 2023 22:06:01 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/c&#43;&#43;primer%E8%AF%BB%E5%90%8E%E6%84%9F/</guid>
      <description>阅读了《C++primer》后，发现自己确实对C++的认识过于浅薄，还有很多我不了解的语法与注意事项需要学习。
1.初始化的四种方式 1.int a = 0; 2.int a = {0}; 3.int a(0); 4.int a{0};
其中方式2，4（初始化列表）对于类型检查更加严格，若会出现丢失数据风险则编译器报错。
2.定义 ！= 声明 1.任何包含显式声明的声明即成为定义 int a = 0;为定义而非声明 extern int a;为声明而非定义 extern int a = 0;为定义而非声明 3.初始化 ！= 赋值 4.建议使用nullptr为指针赋空值 int *p = nullptr;
5.指针值的四种状态 p47 对第二种理解不了&amp;mdash;指向紧邻对象所指空间下一个位置 6.加深对于const的理解 1.常量引用与指向常量指针：前者可绑定非常量值，后者可指向非常量对象 2.顶层const与底层const：前者狭义即指针本身是常量，广义即表示任意对象为常量，后者表示指针所指对象为一个常量
今天阅读收获颇多。</description>
    </item>
    
    <item>
      <title>Git学习</title>
      <link>https://qingbingwei.github.io/post/git%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 30 Oct 2023 11:37:24 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/git%E5%AD%A6%E4%B9%A0/</guid>
      <description>对git进行了学习，了解了基本git操作指令与远程仓库相关指令，了解了分支概念及其相关指令（合并，拉取，获取等），在之后的学习中通过多加使用git以实现巩固目的。
日后目标：Qt学习，阅读《C++ Primer》</description>
    </item>
    
    <item>
      <title>C&#43;&#43;学习感想</title>
      <link>https://qingbingwei.github.io/post/c&#43;&#43;%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/</link>
      <pubDate>Mon, 23 Oct 2023 23:00:26 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/c&#43;&#43;%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/</guid>
      <description>历时四个月，学习完了C语言及C++语法，对于面向过程，面向对象（封装，继承和多态），泛型编程（模板）以及STL有了基本的了解。
后续准备开始学习数据结构与算法，git的使用和qt开发流程，同时阅读《effective C++》与《C++ primer》对所学知识进行巩固。
ps：被某重庆985的特色通识课折磨的想死，同时在数学中苦苦挣扎。。。</description>
    </item>
    
    <item>
      <title>Blog2</title>
      <link>https://qingbingwei.github.io/post/blog2/</link>
      <pubDate>Sun, 20 Aug 2023 22:01:48 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/blog2/</guid>
      <description>尝试更新博客，不晓得什么时候才能换头像&amp;hellip;
现在是晚上11点，在大佬远程连线下成功解决了本地显示问题及public文件夹生成失败问题，一番交流过后，得知这位大佬竟是中学生（给我这种小县城的人震撼到了），实在是佩服。 感谢一般路过热心网友的帮助，赞美大佬</description>
    </item>
    
    <item>
      <title>Blog</title>
      <link>https://qingbingwei.github.io/post/blog/</link>
      <pubDate>Sat, 19 Aug 2023 10:37:33 +0800</pubDate>
      
      <guid>https://qingbingwei.github.io/post/blog/</guid>
      <description>第二次部署，因为不知道如何更新而重新部署，真就遇事不决就重装</description>
    </item>
    
  </channel>
</rss>
